   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	setupPWM
  12               	setupPWM:
  13               	.LFB6:
  14               		.file 1 "pwm.h"
   1:pwm.h         **** #include <avr/io.h>
   2:pwm.h         **** #include "cpu_def.h"
   3:pwm.h         **** 
   4:pwm.h         **** //Define PWM Channels
   5:pwm.h         **** #define CH_A 0
   6:pwm.h         **** #define CH_B 1
   7:pwm.h         **** 
   8:pwm.h         **** void setupPWM(void);
   9:pwm.h         **** void pwm(uint8_t channel, uint16_t onTime, uint16_t period);
  10:pwm.h         **** 
  11:pwm.h         **** //Initializing PWM
  12:pwm.h         **** void setupPWM(void){
  15               		.loc 1 12 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  13:pwm.h         **** 	OC1x_DDR |= (1 << OC1A_PIN) | (1 << OC1B_PIN);
  21               		.loc 1 13 0
  22 0000 84B1      		in r24,0x4
  23 0002 8660      		ori r24,lo8(6)
  24 0004 84B9      		out 0x4,r24
  14:pwm.h         **** 	TCCR1A = (1 << COM1A1) | (1 << COM1B1) | (1 << WGM11);	
  25               		.loc 1 14 0
  26 0006 82EA      		ldi r24,lo8(-94)
  27 0008 8093 8000 		sts 128,r24
  15:pwm.h         **** 	TCCR1B = (1 << WGM13) | (1 << WGM12) | (1 << CS11);
  28               		.loc 1 15 0
  29 000c 8AE1      		ldi r24,lo8(26)
  30 000e 8093 8100 		sts 129,r24
  31               	/* epilogue start */
  16:pwm.h         **** }
  32               		.loc 1 16 0
  33 0012 0895      		ret
  34               		.cfi_endproc
  35               	.LFE6:
  37               	.global	pwm
  39               	pwm:
  40               	.LFB7:
  17:pwm.h         **** 
  18:pwm.h         **** //Set PWM of the selected channel
  19:pwm.h         **** void pwm(uint8_t channel, uint16_t onTime, uint16_t period){
  41               		.loc 1 19 0
  42               		.cfi_startproc
  43               	.LVL0:
  44               	/* prologue: function */
  45               	/* frame size = 0 */
  46               	/* stack size = 0 */
  47               	.L__stack_usage = 0
  20:pwm.h         **** 	ICR1 = period;
  48               		.loc 1 20 0
  49 0014 5093 8700 		sts 134+1,r21
  50 0018 4093 8600 		sts 134,r20
  21:pwm.h         **** 	(channel == CH_B) ? (OCR1B = onTime) : (OCR1A = onTime);
  51               		.loc 1 21 0
  52 001c 8130      		cpi r24,lo8(1)
  53 001e 01F4      		brne .L3
  54               		.loc 1 21 0 is_stmt 0 discriminator 1
  55 0020 7093 8B00 		sts 138+1,r23
  56 0024 6093 8A00 		sts 138,r22
  57 0028 0895      		ret
  58               	.L3:
  59               		.loc 1 21 0 discriminator 2
  60 002a 7093 8900 		sts 136+1,r23
  61 002e 6093 8800 		sts 136,r22
  62               	/* epilogue start */
  22:pwm.h         **** }...
  63               		.loc 1 22 0 is_stmt 1 discriminator 2
  64 0032 0895      		ret
  65               		.cfi_endproc
  66               	.LFE7:
  68               	.global	controlMotor
  70               	controlMotor:
  71               	.LFB9:
  72               		.file 2 "motor_control.h"
   1:motor_control.h **** #define FORWARD 0x00
   2:motor_control.h **** #define REVERSE	0x01
   3:motor_control.h **** #define RIGHT	0x02
   4:motor_control.h **** #define LEFT	0x03
   5:motor_control.h **** #define STOP 	0x04
   6:motor_control.h **** #define NEUTRAL	0x05
   7:motor_control.h **** 
   8:motor_control.h **** #define TRUE 	1
   9:motor_control.h **** #define FALSE 	0
  10:motor_control.h **** 
  11:motor_control.h **** #define MOTOR_DDR	DDRC
  12:motor_control.h **** #define MOTOR_PORT	PORTC
  13:motor_control.h **** 
  14:motor_control.h **** #define MOTOR_RIGHT_FWD_PIN		PC0
  15:motor_control.h **** #define MOTOR_RIGHT_REV_PIN		PC1
  16:motor_control.h **** #define MOTOR_LEFT_FWD_PIN		PC2
  17:motor_control.h **** #define MOTOR_LEFT_REV_PIN		PC3
  18:motor_control.h **** 
  19:motor_control.h **** #define FORWARD_MODE() { MOTOR_PORT |= (1 << MOTOR_RIGHT_FWD_PIN) | (1 << MOTOR_LEFT_FWD_PIN); MOTO
  20:motor_control.h **** #define REVERSE_MODE() { MOTOR_PORT |= (1 << MOTOR_RIGHT_REV_PIN) | (1 << MOTOR_LEFT_REV_PIN); MOTO
  21:motor_control.h **** #define RIGHT_MODE()   { MOTOR_PORT |= (1 << MOTOR_RIGHT_REV_PIN) | (1 << MOTOR_LEFT_FWD_PIN); MOTO
  22:motor_control.h **** #define LEFT_MODE()    { MOTOR_PORT |= (1 << MOTOR_RIGHT_FWD_PIN) | (1 << MOTOR_LEFT_REV_PIN); MOTO
  23:motor_control.h **** 
  24:motor_control.h **** #define MAX_PWM_SPEED	20000
  25:motor_control.h **** #define MIN_PWM_SPEED	2000
  26:motor_control.h **** 
  27:motor_control.h **** #define MAX_SPEED 10000
  28:motor_control.h **** #define SPEED_INCREASE_RATE		10
  29:motor_control.h **** #define SPEED_DECREASE_RATE		5
  30:motor_control.h **** #define BREAK_RATE				30
  31:motor_control.h **** 
  32:motor_control.h **** #include "pwm.h"
  33:motor_control.h **** 
  34:motor_control.h **** uint16_t channelA = 0, channelB = 0;
  35:motor_control.h **** uint8_t channelA_status = FORWARD, channelB_status = FORWARD, left_status = FALSE, right_status=FAL
  36:motor_control.h **** 
  37:motor_control.h **** void controlMotor(uint8_t status);
  38:motor_control.h **** void setupMotor(void);
  39:motor_control.h **** 
  40:motor_control.h **** void setupMotor(void){
  41:motor_control.h **** 	MOTOR_DDR = 0x0F;
  42:motor_control.h **** 
  43:motor_control.h **** 	pwm(CH_A, 0, MAX_PWM_SPEED);
  44:motor_control.h **** 	pwm(CH_B, 0, MAX_PWM_SPEED);
  45:motor_control.h **** 
  46:motor_control.h **** 	controlMotor(NEUTRAL);
  47:motor_control.h **** }
  48:motor_control.h **** 
  49:motor_control.h **** void controlMotor(uint8_t status){
  73               		.loc 2 49 0
  74               		.cfi_startproc
  75               	.LVL1:
  76               	/* prologue: function */
  77               	/* frame size = 0 */
  78               	/* stack size = 0 */
  79               	.L__stack_usage = 0
  50:motor_control.h **** 	switch(status){
  80               		.loc 2 50 0
  81 0034 8230      		cpi r24,lo8(2)
  82 0036 01F4      		brne .+2
  83 0038 00C0      		rjmp .L7
  84 003a 00F4      		brsh .L8
  85 003c 2091 0000 		lds r18,channelA
  86 0040 3091 0000 		lds r19,channelA+1
  87 0044 8823      		tst r24
  88 0046 01F4      		brne .+2
  89 0048 00C0      		rjmp .L9
  90 004a 8130      		cpi r24,lo8(1)
  91 004c 01F4      		brne .+2
  92 004e 00C0      		rjmp .L10
  93               	.LVL2:
  94               	.L6:
  51:motor_control.h **** 		case FORWARD:
  52:motor_control.h **** 			if(channelA_status == FORWARD && channelB_status == FORWARD){
  53:motor_control.h **** 				(channelA == MAX_SPEED) ? (channelA = MAX_SPEED) : (channelA += SPEED_INCREASE_RATE);
  54:motor_control.h **** 				channelB = channelA;
  55:motor_control.h **** 			}else if(channelA_status == REVERSE && channelB_status == REVERSE){
  56:motor_control.h **** 				if(channelA > MIN_PWM_SPEED){
  57:motor_control.h **** 					channelA -= BREAK_RATE;
  58:motor_control.h **** 					channelB = channelA;
  59:motor_control.h **** 				}else{
  60:motor_control.h **** 					FORWARD_MODE();
  61:motor_control.h **** 					channelA_status = FORWARD;
  62:motor_control.h **** 					channelB_status = FORWARD;
  63:motor_control.h **** 				}
  64:motor_control.h **** 			}
  65:motor_control.h **** 			break;
  66:motor_control.h **** 		
  67:motor_control.h **** 		case REVERSE:
  68:motor_control.h **** 			if(channelA_status == REVERSE && channelB_status == REVERSE){
  69:motor_control.h **** 				(channelA == MAX_SPEED) ? (channelA = MAX_SPEED) : (channelA += SPEED_INCREASE_RATE);
  70:motor_control.h **** 				channelB = channelA;
  71:motor_control.h **** 			}else if(channelA_status == FORWARD && channelB_status == FORWARD){
  72:motor_control.h **** 				if(channelA > MIN_PWM_SPEED){
  73:motor_control.h **** 					channelA -= BREAK_RATE;
  74:motor_control.h **** 					channelB = channelA;
  75:motor_control.h **** 				}else{
  76:motor_control.h **** 					REVERSE_MODE();
  77:motor_control.h **** 					channelA_status = REVERSE;
  78:motor_control.h **** 					channelB_status = REVERSE;
  79:motor_control.h **** 				}
  80:motor_control.h **** 			}
  81:motor_control.h **** 			break;
  82:motor_control.h **** 		
  83:motor_control.h **** 		case STOP:
  84:motor_control.h **** 			channelA = 0x00;
  85:motor_control.h **** 			channelB = 0x00;
  86:motor_control.h **** 			break;
  87:motor_control.h **** 
  88:motor_control.h **** 		case NEUTRAL:
  89:motor_control.h **** 			if(channelA > MIN_PWM_SPEED){
  90:motor_control.h **** 				channelA -= SPEED_DECREASE_RATE;
  91:motor_control.h **** 				channelB = channelA;
  92:motor_control.h **** 			}
  93:motor_control.h **** 
  94:motor_control.h **** 			if(channelB_status == FORWARD && channelB_status == FORWARD){
  95:motor_control.h **** 				FORWARD_MODE();
  96:motor_control.h **** 			}
  97:motor_control.h **** 			else{
  98:motor_control.h **** 				REVERSE_MODE();
  99:motor_control.h **** 			}
 100:motor_control.h **** 
 101:motor_control.h **** 			if(left_status || right_status){
 102:motor_control.h **** 				channelA = 0x00;
 103:motor_control.h **** 				channelB = 0x00;
 104:motor_control.h **** 				left_status = FALSE;
 105:motor_control.h **** 				right_status = FALSE;
 106:motor_control.h **** 			}
 107:motor_control.h **** 			break;
 108:motor_control.h **** 
 109:motor_control.h **** 		case RIGHT:
 110:motor_control.h **** 			RIGHT_MODE();
 111:motor_control.h **** 			if(channelA < MIN_PWM_SPEED){
 112:motor_control.h **** 				left_status = FALSE;
 113:motor_control.h **** 				right_status = TRUE;
 114:motor_control.h **** 				channelA = 15000;
 115:motor_control.h **** 				channelB = 15000;
 116:motor_control.h **** 			}
 117:motor_control.h **** 			break;
 118:motor_control.h **** 
 119:motor_control.h **** 		case LEFT:
 120:motor_control.h **** 			LEFT_MODE();
 121:motor_control.h **** 			if(channelA < MIN_PWM_SPEED){
 122:motor_control.h **** 				left_status = TRUE;
 123:motor_control.h **** 				right_status = FALSE;
 124:motor_control.h **** 				channelA = MAX_PWM_SPEED / 2;
 125:motor_control.h **** 				channelB = MAX_PWM_SPEED / 2;
 126:motor_control.h **** 			}
 127:motor_control.h **** 			break;
 128:motor_control.h **** 	}
 129:motor_control.h **** 
 130:motor_control.h **** 	pwm(CH_A, channelA, MAX_PWM_SPEED);
  95               		.loc 2 130 0
  96 0050 2091 0000 		lds r18,channelA
  97 0054 3091 0000 		lds r19,channelA+1
  98               	.LVL3:
  99               	.LBB10:
 100               	.LBB11:
  20:pwm.h         **** 	ICR1 = period;
 101               		.loc 1 20 0
 102 0058 80E2      		ldi r24,lo8(32)
 103 005a 9EE4      		ldi r25,lo8(78)
 104 005c 9093 8700 		sts 134+1,r25
 105 0060 8093 8600 		sts 134,r24
  21:pwm.h         **** 	(channel == CH_B) ? (OCR1B = onTime) : (OCR1A = onTime);
 106               		.loc 1 21 0
 107 0064 3093 8900 		sts 136+1,r19
 108 0068 2093 8800 		sts 136,r18
 109               	.LVL4:
 110               	.LBE11:
 111               	.LBE10:
 131:motor_control.h **** 	pwm(CH_B, channelB, MAX_PWM_SPEED);
 112               		.loc 2 131 0
 113 006c 2091 0000 		lds r18,channelB
 114 0070 3091 0000 		lds r19,channelB+1
 115               	.LVL5:
 116               	.LBB12:
 117               	.LBB13:
  20:pwm.h         **** 	ICR1 = period;
 118               		.loc 1 20 0
 119 0074 9093 8700 		sts 134+1,r25
 120 0078 8093 8600 		sts 134,r24
  21:pwm.h         **** 	(channel == CH_B) ? (OCR1B = onTime) : (OCR1A = onTime);
 121               		.loc 1 21 0
 122 007c 3093 8B00 		sts 138+1,r19
 123 0080 2093 8A00 		sts 138,r18
 124               	.LVL6:
 125               	/* epilogue start */
 126               	.LBE13:
 127               	.LBE12:
 132:motor_control.h **** }...
 128               		.loc 2 132 0
 129 0084 0895      		ret
 130               	.LVL7:
 131               	.L8:
  50:motor_control.h **** 	switch(status){
 132               		.loc 2 50 0
 133 0086 8430      		cpi r24,lo8(4)
 134 0088 01F4      		brne .+2
 135 008a 00C0      		rjmp .L11
 136 008c 00F4      		brsh .+2
 137 008e 00C0      		rjmp .L12
 138 0090 8530      		cpi r24,lo8(5)
 139 0092 01F4      		brne .L6
  89:motor_control.h **** 			if(channelA > MIN_PWM_SPEED){
 140               		.loc 2 89 0
 141 0094 8091 0000 		lds r24,channelA
 142 0098 9091 0000 		lds r25,channelA+1
 143               	.LVL8:
 144 009c 813D      		cpi r24,-47
 145 009e 27E0      		ldi r18,7
 146 00a0 9207      		cpc r25,r18
 147 00a2 00F0      		brlo .L22
  90:motor_control.h **** 				channelA -= SPEED_DECREASE_RATE;
 148               		.loc 2 90 0
 149 00a4 0597      		sbiw r24,5
 150 00a6 9093 0000 		sts channelA+1,r25
 151 00aa 8093 0000 		sts channelA,r24
  91:motor_control.h **** 				channelB = channelA;
 152               		.loc 2 91 0
 153 00ae 9093 0000 		sts channelB+1,r25
 154 00b2 8093 0000 		sts channelB,r24
 155               	.L22:
  94:motor_control.h **** 			if(channelB_status == FORWARD && channelB_status == FORWARD){
 156               		.loc 2 94 0
 157 00b6 8091 0000 		lds r24,channelB_status
 158 00ba 8111      		cpse r24,__zero_reg__
 159 00bc 00C0      		rjmp .L23
  95:motor_control.h **** 				FORWARD_MODE();
 160               		.loc 2 95 0
 161 00be 88B1      		in r24,0x8
 162 00c0 8560      		ori r24,lo8(5)
 163 00c2 88B9      		out 0x8,r24
 164 00c4 88B1      		in r24,0x8
 165 00c6 857F      		andi r24,lo8(-11)
 166               	.L35:
  98:motor_control.h **** 				REVERSE_MODE();
 167               		.loc 2 98 0
 168 00c8 88B9      		out 0x8,r24
 101:motor_control.h **** 			if(left_status || right_status){
 169               		.loc 2 101 0
 170 00ca 8091 0000 		lds r24,left_status
 171 00ce 8111      		cpse r24,__zero_reg__
 172 00d0 00C0      		rjmp .L25
 101:motor_control.h **** 			if(left_status || right_status){
 173               		.loc 2 101 0 is_stmt 0 discriminator 1
 174 00d2 8091 0000 		lds r24,right_status
 175 00d6 8823      		tst r24
 176 00d8 01F4      		brne .+2
 177 00da 00C0      		rjmp .L6
 178               	.L25:
 102:motor_control.h **** 				channelA = 0x00;
 179               		.loc 2 102 0 is_stmt 1
 180 00dc 1092 0000 		sts channelA+1,__zero_reg__
 181 00e0 1092 0000 		sts channelA,__zero_reg__
 103:motor_control.h **** 				channelB = 0x00;
 182               		.loc 2 103 0
 183 00e4 1092 0000 		sts channelB+1,__zero_reg__
 184 00e8 1092 0000 		sts channelB,__zero_reg__
 104:motor_control.h **** 				left_status = FALSE;
 185               		.loc 2 104 0
 186 00ec 1092 0000 		sts left_status,__zero_reg__
 105:motor_control.h **** 				right_status = FALSE;
 187               		.loc 2 105 0
 188 00f0 1092 0000 		sts right_status,__zero_reg__
 189 00f4 00C0      		rjmp .L6
 190               	.LVL9:
 191               	.L9:
  52:motor_control.h **** 			if(channelA_status == FORWARD && channelB_status == FORWARD){
 192               		.loc 2 52 0
 193 00f6 8091 0000 		lds r24,channelA_status
 194               	.LVL10:
 195 00fa 8111      		cpse r24,__zero_reg__
 196 00fc 00C0      		rjmp .L14
  52:motor_control.h **** 			if(channelA_status == FORWARD && channelB_status == FORWARD){
 197               		.loc 2 52 0 is_stmt 0 discriminator 1
 198 00fe 8091 0000 		lds r24,channelB_status
 199 0102 8111      		cpse r24,__zero_reg__
 200 0104 00C0      		rjmp .L6
 201               	.L40:
  69:motor_control.h **** 				(channelA == MAX_SPEED) ? (channelA = MAX_SPEED) : (channelA += SPEED_INCREASE_RATE);
 202               		.loc 2 69 0 is_stmt 1
 203 0106 2031      		cpi r18,16
 204 0108 87E2      		ldi r24,39
 205 010a 3807      		cpc r19,r24
 206 010c 01F0      		breq .L20
  69:motor_control.h **** 				(channelA == MAX_SPEED) ? (channelA = MAX_SPEED) : (channelA += SPEED_INCREASE_RATE);
 207               		.loc 2 69 0 is_stmt 0 discriminator 2
 208 010e 265F      		subi r18,-10
 209 0110 3F4F      		sbci r19,-1
 210 0112 3093 0000 		sts channelA+1,r19
 211 0116 2093 0000 		sts channelA,r18
 212               	.L20:
  70:motor_control.h **** 				channelB = channelA;
 213               		.loc 2 70 0 is_stmt 1
 214 011a 8091 0000 		lds r24,channelA
 215 011e 9091 0000 		lds r25,channelA+1
 216               	.L36:
 125:motor_control.h **** 				channelB = MAX_PWM_SPEED / 2;
 217               		.loc 2 125 0
 218 0122 9093 0000 		sts channelB+1,r25
 219 0126 8093 0000 		sts channelB,r24
 220 012a 00C0      		rjmp .L6
 221               	.L14:
  55:motor_control.h **** 			}else if(channelA_status == REVERSE && channelB_status == REVERSE){
 222               		.loc 2 55 0
 223 012c 8130      		cpi r24,lo8(1)
 224 012e 01F0      		breq .+2
 225 0130 00C0      		rjmp .L6
  55:motor_control.h **** 			}else if(channelA_status == REVERSE && channelB_status == REVERSE){
 226               		.loc 2 55 0 is_stmt 0 discriminator 1
 227 0132 8091 0000 		lds r24,channelB_status
 228 0136 8130      		cpi r24,lo8(1)
 229 0138 01F0      		breq .+2
 230 013a 00C0      		rjmp .L6
  56:motor_control.h **** 				if(channelA > MIN_PWM_SPEED){
 231               		.loc 2 56 0 is_stmt 1
 232 013c 213D      		cpi r18,-47
 233 013e 97E0      		ldi r25,7
 234 0140 3907      		cpc r19,r25
 235 0142 00F0      		brlo .L18
 236               	.L38:
  73:motor_control.h **** 					channelA -= BREAK_RATE;
 237               		.loc 2 73 0
 238 0144 2E51      		subi r18,30
 239 0146 3109      		sbc r19,__zero_reg__
 240 0148 3093 0000 		sts channelA+1,r19
 241 014c 2093 0000 		sts channelA,r18
  74:motor_control.h **** 					channelB = channelA;
 242               		.loc 2 74 0
 243 0150 3093 0000 		sts channelB+1,r19
 244 0154 2093 0000 		sts channelB,r18
 245 0158 00C0      		rjmp .L6
 246               	.L18:
  60:motor_control.h **** 					FORWARD_MODE();
 247               		.loc 2 60 0
 248 015a 88B1      		in r24,0x8
 249 015c 8560      		ori r24,lo8(5)
 250 015e 88B9      		out 0x8,r24
 251 0160 88B1      		in r24,0x8
 252 0162 857F      		andi r24,lo8(-11)
 253 0164 88B9      		out 0x8,r24
  61:motor_control.h **** 					channelA_status = FORWARD;
 254               		.loc 2 61 0
 255 0166 1092 0000 		sts channelA_status,__zero_reg__
  62:motor_control.h **** 					channelB_status = FORWARD;
 256               		.loc 2 62 0
 257 016a 1092 0000 		sts channelB_status,__zero_reg__
 258 016e 00C0      		rjmp .L6
 259               	.LVL11:
 260               	.L10:
  68:motor_control.h **** 			if(channelA_status == REVERSE && channelB_status == REVERSE){
 261               		.loc 2 68 0
 262 0170 9091 0000 		lds r25,channelA_status
 263 0174 9130      		cpi r25,lo8(1)
 264 0176 01F4      		brne .L19
  68:motor_control.h **** 			if(channelA_status == REVERSE && channelB_status == REVERSE){
 265               		.loc 2 68 0 is_stmt 0 discriminator 1
 266 0178 8091 0000 		lds r24,channelB_status
 267               	.LVL12:
 268 017c 8130      		cpi r24,lo8(1)
 269 017e 01F0      		breq .+2
 270 0180 00C0      		rjmp .L6
 271 0182 00C0      		rjmp .L40
 272               	.LVL13:
 273               	.L19:
  71:motor_control.h **** 			}else if(channelA_status == FORWARD && channelB_status == FORWARD){
 274               		.loc 2 71 0 is_stmt 1
 275 0184 9111      		cpse r25,__zero_reg__
 276 0186 00C0      		rjmp .L6
  71:motor_control.h **** 			}else if(channelA_status == FORWARD && channelB_status == FORWARD){
 277               		.loc 2 71 0 is_stmt 0 discriminator 1
 278 0188 9091 0000 		lds r25,channelB_status
 279 018c 9111      		cpse r25,__zero_reg__
 280 018e 00C0      		rjmp .L6
  72:motor_control.h **** 				if(channelA > MIN_PWM_SPEED){
 281               		.loc 2 72 0 is_stmt 1
 282 0190 213D      		cpi r18,-47
 283 0192 97E0      		ldi r25,7
 284 0194 3907      		cpc r19,r25
 285 0196 00F4      		brsh .L38
  76:motor_control.h **** 					REVERSE_MODE();
 286               		.loc 2 76 0
 287 0198 98B1      		in r25,0x8
 288 019a 9A60      		ori r25,lo8(10)
 289 019c 98B9      		out 0x8,r25
 290 019e 98B1      		in r25,0x8
 291 01a0 9A7F      		andi r25,lo8(-6)
 292 01a2 98B9      		out 0x8,r25
  77:motor_control.h **** 					channelA_status = REVERSE;
 293               		.loc 2 77 0
 294 01a4 8093 0000 		sts channelA_status,r24
  78:motor_control.h **** 					channelB_status = REVERSE;
 295               		.loc 2 78 0
 296 01a8 8093 0000 		sts channelB_status,r24
 297 01ac 00C0      		rjmp .L6
 298               	.L11:
  84:motor_control.h **** 			channelA = 0x00;
 299               		.loc 2 84 0
 300 01ae 1092 0000 		sts channelA+1,__zero_reg__
 301 01b2 1092 0000 		sts channelA,__zero_reg__
  85:motor_control.h **** 			channelB = 0x00;
 302               		.loc 2 85 0
 303 01b6 1092 0000 		sts channelB+1,__zero_reg__
 304 01ba 1092 0000 		sts channelB,__zero_reg__
  86:motor_control.h **** 			break;
 305               		.loc 2 86 0
 306 01be 00C0      		rjmp .L6
 307               	.LVL14:
 308               	.L23:
  98:motor_control.h **** 				REVERSE_MODE();
 309               		.loc 2 98 0
 310 01c0 88B1      		in r24,0x8
 311 01c2 8A60      		ori r24,lo8(10)
 312 01c4 88B9      		out 0x8,r24
 313 01c6 88B1      		in r24,0x8
 314 01c8 8A7F      		andi r24,lo8(-6)
 315 01ca 00C0      		rjmp .L35
 316               	.LVL15:
 317               	.L7:
 110:motor_control.h **** 			RIGHT_MODE();
 318               		.loc 2 110 0
 319 01cc 88B1      		in r24,0x8
 320               	.LVL16:
 321 01ce 8660      		ori r24,lo8(6)
 322 01d0 88B9      		out 0x8,r24
 323 01d2 88B1      		in r24,0x8
 324 01d4 867F      		andi r24,lo8(-10)
 325 01d6 88B9      		out 0x8,r24
 111:motor_control.h **** 			if(channelA < MIN_PWM_SPEED){
 326               		.loc 2 111 0
 327 01d8 8091 0000 		lds r24,channelA
 328 01dc 9091 0000 		lds r25,channelA+1
 329 01e0 803D      		cpi r24,-48
 330 01e2 9740      		sbci r25,7
 331 01e4 00F0      		brlo .+2
 332 01e6 00C0      		rjmp .L6
 112:motor_control.h **** 				left_status = FALSE;
 333               		.loc 2 112 0
 334 01e8 1092 0000 		sts left_status,__zero_reg__
 113:motor_control.h **** 				right_status = TRUE;
 335               		.loc 2 113 0
 336 01ec 81E0      		ldi r24,lo8(1)
 337 01ee 8093 0000 		sts right_status,r24
 114:motor_control.h **** 				channelA = 15000;
 338               		.loc 2 114 0
 339 01f2 88E9      		ldi r24,lo8(-104)
 340 01f4 9AE3      		ldi r25,lo8(58)
 341               	.L37:
 124:motor_control.h **** 				channelA = MAX_PWM_SPEED / 2;
 342               		.loc 2 124 0
 343 01f6 9093 0000 		sts channelA+1,r25
 344 01fa 8093 0000 		sts channelA,r24
 345 01fe 00C0      		rjmp .L36
 346               	.LVL17:
 347               	.L12:
 120:motor_control.h **** 			LEFT_MODE();
 348               		.loc 2 120 0
 349 0200 88B1      		in r24,0x8
 350               	.LVL18:
 351 0202 8960      		ori r24,lo8(9)
 352 0204 88B9      		out 0x8,r24
 353 0206 88B1      		in r24,0x8
 354 0208 897F      		andi r24,lo8(-7)
 355 020a 88B9      		out 0x8,r24
 121:motor_control.h **** 			if(channelA < MIN_PWM_SPEED){
 356               		.loc 2 121 0
 357 020c 8091 0000 		lds r24,channelA
 358 0210 9091 0000 		lds r25,channelA+1
 359 0214 803D      		cpi r24,-48
 360 0216 9740      		sbci r25,7
 361 0218 00F0      		brlo .+2
 362 021a 00C0      		rjmp .L6
 122:motor_control.h **** 				left_status = TRUE;
 363               		.loc 2 122 0
 364 021c 81E0      		ldi r24,lo8(1)
 365 021e 8093 0000 		sts left_status,r24
 123:motor_control.h **** 				right_status = FALSE;
 366               		.loc 2 123 0
 367 0222 1092 0000 		sts right_status,__zero_reg__
 124:motor_control.h **** 				channelA = MAX_PWM_SPEED / 2;
 368               		.loc 2 124 0
 369 0226 80E1      		ldi r24,lo8(16)
 370 0228 97E2      		ldi r25,lo8(39)
 371 022a 00C0      		rjmp .L37
 372               		.cfi_endproc
 373               	.LFE9:
 375               	.global	setupMotor
 377               	setupMotor:
 378               	.LFB8:
  40:motor_control.h **** void setupMotor(void){
 379               		.loc 2 40 0
 380               		.cfi_startproc
 381               	/* prologue: function */
 382               	/* frame size = 0 */
 383               	/* stack size = 0 */
 384               	.L__stack_usage = 0
  41:motor_control.h **** 	MOTOR_DDR = 0x0F;
 385               		.loc 2 41 0
 386 022c 8FE0      		ldi r24,lo8(15)
 387 022e 87B9      		out 0x7,r24
 388               	.LVL19:
 389               	.LBB14:
 390               	.LBB15:
  20:pwm.h         **** 	ICR1 = period;
 391               		.loc 1 20 0
 392 0230 E6E8      		ldi r30,lo8(-122)
 393 0232 F0E0      		ldi r31,0
 394 0234 80E2      		ldi r24,lo8(32)
 395 0236 9EE4      		ldi r25,lo8(78)
 396 0238 9183      		std Z+1,r25
 397 023a 8083      		st Z,r24
  21:pwm.h         **** 	(channel == CH_B) ? (OCR1B = onTime) : (OCR1A = onTime);
 398               		.loc 1 21 0
 399 023c 1092 8900 		sts 136+1,__zero_reg__
 400 0240 1092 8800 		sts 136,__zero_reg__
 401               	.LVL20:
 402               	.LBE15:
 403               	.LBE14:
 404               	.LBB16:
 405               	.LBB17:
  20:pwm.h         **** 	ICR1 = period;
 406               		.loc 1 20 0
 407 0244 9183      		std Z+1,r25
 408 0246 8083      		st Z,r24
  21:pwm.h         **** 	(channel == CH_B) ? (OCR1B = onTime) : (OCR1A = onTime);
 409               		.loc 1 21 0
 410 0248 1092 8B00 		sts 138+1,__zero_reg__
 411 024c 1092 8A00 		sts 138,__zero_reg__
 412               	.LVL21:
 413               	.LBE17:
 414               	.LBE16:
  46:motor_control.h **** 	controlMotor(NEUTRAL);
 415               		.loc 2 46 0
 416 0250 85E0      		ldi r24,lo8(5)
 417 0252 0C94 0000 		jmp controlMotor
 418               	.LVL22:
 419               		.cfi_endproc
 420               	.LFE8:
 422               	.global	initUSART
 424               	initUSART:
 425               	.LFB10:
 426               		.file 3 "serial.h"
   1:serial.h      **** #define BAUD_RATE 9600
   2:serial.h      **** 
   3:serial.h      **** #include <avr/io.h>
   4:serial.h      **** #include "cpu_def.h"
   5:serial.h      **** 
   6:serial.h      **** void initUSART(void);
   7:serial.h      **** uint8_t getCh(void);
   8:serial.h      **** void putCh(uint8_t data);
   9:serial.h      **** 
  10:serial.h      **** void initUSART(void){
 427               		.loc 3 10 0
 428               		.cfi_startproc
 429               	/* prologue: function */
 430               	/* frame size = 0 */
 431               	/* stack size = 0 */
 432               	.L__stack_usage = 0
 433               	.LVL23:
  11:serial.h      ****    //Set Baud rate; ubrr_value = F_OSC/(16 x Baud_rate) - 1; e.g. 16e6/(9600*16) -1 = 103
  12:serial.h      **** 	uint32_t ubrr_value;
  13:serial.h      **** 	ubrr_value = F_CPU/16/BAUD_RATE -1; 
  14:serial.h      **** 	UBRRL_REG = ubrr_value;
 434               		.loc 3 14 0
 435 0256 87E6      		ldi r24,lo8(103)
 436 0258 8093 C400 		sts 196,r24
  15:serial.h      **** 	UBRRH_REG = (ubrr_value >> 8);
 437               		.loc 3 15 0
 438 025c 1092 C500 		sts 197,__zero_reg__
  16:serial.h      **** 	UCSRC_REG |= (1 << UCSZ1_BIT) | (1 << UCSZ0_BIT);
 439               		.loc 3 16 0
 440 0260 E2EC      		ldi r30,lo8(-62)
 441 0262 F0E0      		ldi r31,0
 442 0264 8081      		ld r24,Z
 443 0266 8660      		ori r24,lo8(6)
 444 0268 8083      		st Z,r24
  17:serial.h      **** 
  18:serial.h      **** 	#ifdef ATMEGA_32A
  19:serial.h      **** 	UCSRC_REG |= (1 << URSEL_BIT);
  20:serial.h      **** 	#endif
  21:serial.h      **** 
  22:serial.h      **** 	//Enable The receiver and transmitter
  23:serial.h      **** 	UCSRB_REG = (1 << RXEN_BIT) | (1 << TXEN_BIT);
 445               		.loc 3 23 0
 446 026a 88E1      		ldi r24,lo8(24)
 447 026c 8093 C100 		sts 193,r24
 448               	/* epilogue start */
  24:serial.h      **** }
 449               		.loc 3 24 0
 450 0270 0895      		ret
 451               		.cfi_endproc
 452               	.LFE10:
 454               	.global	getCh
 456               	getCh:
 457               	.LFB11:
  25:serial.h      **** 
  26:serial.h      **** uint8_t getCh(void){
 458               		.loc 3 26 0
 459               		.cfi_startproc
 460               	/* prologue: function */
 461               	/* frame size = 0 */
 462               	/* stack size = 0 */
 463               	.L__stack_usage = 0
 464               	.L44:
  27:serial.h      **** 	while(!(UCSRA_REG & (1 << RXC_BIT)));
 465               		.loc 3 27 0 discriminator 1
 466 0272 8091 C000 		lds r24,192
 467 0276 87FF      		sbrs r24,7
 468 0278 00C0      		rjmp .L44
  28:serial.h      **** 	return UDR_REG;
 469               		.loc 3 28 0
 470 027a 8091 C600 		lds r24,198
 471               	/* epilogue start */
  29:serial.h      **** }
 472               		.loc 3 29 0
 473 027e 0895      		ret
 474               		.cfi_endproc
 475               	.LFE11:
 477               	.global	putCh
 479               	putCh:
 480               	.LFB12:
  30:serial.h      **** 
  31:serial.h      **** void putCh(uint8_t data){
 481               		.loc 3 31 0
 482               		.cfi_startproc
 483               	/* prologue: function */
 484               	/* frame size = 0 */
 485               	/* stack size = 0 */
 486               	.L__stack_usage = 0
 487               	.LVL24:
 488               	.L47:
  32:serial.h      **** 	while(!(UCSRA_REG & (1 << UDRE_BIT)));
 489               		.loc 3 32 0 discriminator 1
 490 0280 9091 C000 		lds r25,192
 491 0284 95FF      		sbrs r25,5
 492 0286 00C0      		rjmp .L47
  33:serial.h      **** 	UDR_REG = data;
 493               		.loc 3 33 0
 494 0288 8093 C600 		sts 198,r24
 495               	/* epilogue start */
  34:serial.h      **** }...
 496               		.loc 3 34 0
 497 028c 0895      		ret
 498               		.cfi_endproc
 499               	.LFE12:
 501               	.global	initIR
 503               	initIR:
 504               	.LFB13:
 505               		.file 4 "ir_array.h"
   1:ir_array.h    **** #define IR_LEFT_DDR DDRD
   2:ir_array.h    **** #define IR_LEFT_PIN PIND
   3:ir_array.h    **** 
   4:ir_array.h    **** #define IR_L_01 PD2
   5:ir_array.h    **** #define IR_L_02 PD3
   6:ir_array.h    **** #define IR_L_03 PD4
   7:ir_array.h    **** #define IR_L_04 PD5
   8:ir_array.h    **** 
   9:ir_array.h    **** #define IR_RIGHT_DDR DDRB
  10:ir_array.h    **** #define IR_RIGHT_PIN PINB
  11:ir_array.h    **** 
  12:ir_array.h    **** #define IR_R_05 PB5
  13:ir_array.h    **** #define IR_R_06 PB3
  14:ir_array.h    **** #define IR_R_07 PB4
  15:ir_array.h    **** #define IR_R_08 PB0
  16:ir_array.h    **** 
  17:ir_array.h    **** #define IR01_VAL() ({ uint8_t retVal = (IR_LEFT_PIN & (1 << IR_L_01)) ? (1 << 0) : 0; retVal;})
  18:ir_array.h    **** #define IR02_VAL() ({uint8_t retVal = (IR_LEFT_PIN & (1 << IR_L_02)) ? (1 << 1) : 0; retVal;})
  19:ir_array.h    **** #define IR03_VAL() ({uint8_t retVal = (IR_LEFT_PIN & (1 << IR_L_03)) ? (1 << 2) : 0; retVal;})
  20:ir_array.h    **** #define IR04_VAL() ({uint8_t retVal = (IR_LEFT_PIN & (1 << IR_L_04)) ? (1 << 3) : 0; retVal;})
  21:ir_array.h    **** #define IR05_VAL() ({uint8_t retVal = (IR_RIGHT_PIN & (1 << IR_R_05)) ? (1 << 4) : 0; retVal;})
  22:ir_array.h    **** #define IR06_VAL() ({uint8_t retVal = (IR_RIGHT_PIN & (1 << IR_R_06)) ? (1 << 5) : 0; retVal;})
  23:ir_array.h    **** #define IR07_VAL() ({uint8_t retVal = (IR_RIGHT_PIN & (1 << IR_R_07)) ? (1 << 6) : 0; retVal;})
  24:ir_array.h    **** #define IR08_VAL() ({uint8_t retVal = (IR_RIGHT_PIN & (1 << IR_R_08)) ? (1 << 7) : 0; retVal;})
  25:ir_array.h    **** 
  26:ir_array.h    **** #define IR_ARR_VAL IR01_VAL() | IR02_VAL() | IR03_VAL() | IR04_VAL() | IR05_VAL() | IR06_VAL() | IR
  27:ir_array.h    **** 
  28:ir_array.h    **** #define SETUP_IR() {IR_LEFT_DDR &= ~((1 << IR_L_01) | (1 << IR_L_02) | (1 << IR_L_03) | (1 << IR_L_
  29:ir_array.h    **** 
  30:ir_array.h    **** #include "motor_control.h"
  31:ir_array.h    **** #include "serial.h"
  32:ir_array.h    **** 
  33:ir_array.h    **** uint8_t width = 0;
  34:ir_array.h    **** uint32_t count = 0;
  35:ir_array.h    **** 
  36:ir_array.h    **** void initIR(void);
  37:ir_array.h    **** void stableCar(void);
  38:ir_array.h    **** uint8_t lineSize(void);
  39:ir_array.h    ****  
  40:ir_array.h    **** void initIR(void){
 506               		.loc 4 40 0
 507               		.cfi_startproc
 508               	/* prologue: function */
 509               	/* frame size = 0 */
 510               	/* stack size = 0 */
 511               	.L__stack_usage = 0
  41:ir_array.h    **** 	SETUP_IR();
 512               		.loc 4 41 0
 513 028e 8AB1      		in r24,0xa
 514 0290 837C      		andi r24,lo8(-61)
 515 0292 8AB9      		out 0xa,r24
 516 0294 84B1      		in r24,0x4
 517 0296 867C      		andi r24,lo8(-58)
 518 0298 84B9      		out 0x4,r24
  42:ir_array.h    **** 	initUSART();
 519               		.loc 4 42 0
 520 029a 0C94 0000 		jmp initUSART
 521               	.LVL25:
 522               		.cfi_endproc
 523               	.LFE13:
 525               	.global	lineSize
 527               	lineSize:
 528               	.LFB15:
  43:ir_array.h    **** }
  44:ir_array.h    **** 
  45:ir_array.h    **** void stableCar(void){
  46:ir_array.h    **** 	//putCh(IR_ARR_VAL);
  47:ir_array.h    **** 	//_delay_ms(100);
  48:ir_array.h    **** 	if(width == 0 || width >= 8){
  49:ir_array.h    **** 		controlMotor(STOP);
  50:ir_array.h    **** 	}else{
  51:ir_array.h    **** 		
  52:ir_array.h    **** 		controlMotor(FORWARD);
  53:ir_array.h    **** 	}
  54:ir_array.h    **** 
  55:ir_array.h    **** 	uint8_t size = lineSize();
  56:ir_array.h    **** 
  57:ir_array.h    **** 	if(width == 0 && size != 0){
  58:ir_array.h    **** 		width = size;
  59:ir_array.h    **** 	}else if(width == size){
  60:ir_array.h    **** 		count++;
  61:ir_array.h    **** 	}
  62:ir_array.h    **** 
  63:ir_array.h    **** 	if(count >= 255){
  64:ir_array.h    **** 		width = size;
  65:ir_array.h    **** 
  66:ir_array.h    **** 		if(width % 2 != 0)
  67:ir_array.h    **** 			width --;
  68:ir_array.h    **** 	}
  69:ir_array.h    **** }
  70:ir_array.h    **** 
  71:ir_array.h    **** uint8_t lineSize(void){
 529               		.loc 4 71 0
 530               		.cfi_startproc
 531               	/* prologue: function */
 532               	/* frame size = 0 */
 533               	/* stack size = 0 */
 534               	.L__stack_usage = 0
 535               	.LVL26:
 536               	.LBB18:
  72:ir_array.h    **** 	uint8_t size = 0;
  73:ir_array.h    **** 
  74:ir_array.h    **** 	if(~IR01_VAL()) size++;
 537               		.loc 4 74 0
 538 029e 89B1      		in r24,0x9
 539               	.LVL27:
 540               	.LBE18:
 541               	.LBB19:
  75:ir_array.h    **** 	if(~IR02_VAL()) size++;
 542               		.loc 4 75 0
 543 02a0 89B1      		in r24,0x9
 544               	.LVL28:
 545               	.LBE19:
 546               	.LBB20:
  76:ir_array.h    **** 	if(~IR03_VAL()) size++;
 547               		.loc 4 76 0
 548 02a2 89B1      		in r24,0x9
 549               	.LVL29:
 550               	.LBE20:
 551               	.LBB21:
  77:ir_array.h    **** 	if(~IR04_VAL()) size++;
 552               		.loc 4 77 0
 553 02a4 89B1      		in r24,0x9
 554               	.LVL30:
 555               	.LBE21:
 556               	.LBB22:
  78:ir_array.h    **** 	if(~IR05_VAL()) size++;
 557               		.loc 4 78 0
 558 02a6 83B1      		in r24,0x3
 559               	.LVL31:
 560               	.LBE22:
 561               	.LBB23:
  79:ir_array.h    **** 	if(~IR06_VAL()) size++;
 562               		.loc 4 79 0
 563 02a8 83B1      		in r24,0x3
 564               	.LVL32:
 565               	.LBE23:
 566               	.LBB24:
  80:ir_array.h    **** 	if(~IR07_VAL()) size++;
 567               		.loc 4 80 0
 568 02aa 83B1      		in r24,0x3
 569               	.LVL33:
 570               	.LBE24:
 571               	.LBB25:
  81:ir_array.h    **** 	if(~IR08_VAL()) size++;
 572               		.loc 4 81 0
 573 02ac 83B1      		in r24,0x3
 574               	.LVL34:
 575               	.LBE25:
  82:ir_array.h    **** 
  83:ir_array.h    **** 	return size;
  84:ir_array.h    **** }...
 576               		.loc 4 84 0
 577 02ae 88E0      		ldi r24,lo8(8)
 578               	/* epilogue start */
 579 02b0 0895      		ret
 580               		.cfi_endproc
 581               	.LFE15:
 583               	.global	stableCar
 585               	stableCar:
 586               	.LFB14:
  45:ir_array.h    **** void stableCar(void){
 587               		.loc 4 45 0
 588               		.cfi_startproc
 589               	/* prologue: function */
 590               	/* frame size = 0 */
 591               	/* stack size = 0 */
 592               	.L__stack_usage = 0
  48:ir_array.h    **** 	if(width == 0 || width >= 8){
 593               		.loc 4 48 0
 594 02b2 8091 0000 		lds r24,width
 595 02b6 8150      		subi r24,lo8(-(-1))
 596 02b8 8730      		cpi r24,lo8(7)
 597 02ba 00F0      		brlo .L53
  49:ir_array.h    **** 		controlMotor(STOP);
 598               		.loc 4 49 0
 599 02bc 84E0      		ldi r24,lo8(4)
 600               	.L65:
  52:ir_array.h    **** 		controlMotor(FORWARD);
 601               		.loc 4 52 0
 602 02be 0E94 0000 		call controlMotor
 603               	.LVL35:
  55:ir_array.h    **** 	uint8_t size = lineSize();
 604               		.loc 4 55 0
 605 02c2 0E94 0000 		call lineSize
 606               	.LVL36:
  57:ir_array.h    **** 	if(width == 0 && size != 0){
 607               		.loc 4 57 0
 608 02c6 9091 0000 		lds r25,width
 609 02ca 9111      		cpse r25,__zero_reg__
 610 02cc 00C0      		rjmp .L55
  57:ir_array.h    **** 	if(width == 0 && size != 0){
 611               		.loc 4 57 0 is_stmt 0 discriminator 1
 612 02ce 8823      		tst r24
 613 02d0 01F0      		breq .L56
  58:ir_array.h    **** 		width = size;
 614               		.loc 4 58 0 is_stmt 1
 615 02d2 8093 0000 		sts width,r24
 616               	.L57:
  63:ir_array.h    **** 	if(count >= 255){
 617               		.loc 4 63 0
 618 02d6 4091 0000 		lds r20,count
 619 02da 5091 0000 		lds r21,count+1
 620 02de 6091 0000 		lds r22,count+2
 621 02e2 7091 0000 		lds r23,count+3
 622 02e6 4F3F      		cpi r20,-1
 623 02e8 5105      		cpc r21,__zero_reg__
 624 02ea 6105      		cpc r22,__zero_reg__
 625 02ec 7105      		cpc r23,__zero_reg__
 626 02ee 00F0      		brlo .L52
  66:ir_array.h    **** 		if(width % 2 != 0)
 627               		.loc 4 66 0
 628 02f0 80FD      		sbrc r24,0
 629 02f2 00C0      		rjmp .L60
 630               	.LVL37:
 631               	.L66:
  67:ir_array.h    **** 			width --;
 632               		.loc 4 67 0
 633 02f4 8093 0000 		sts width,r24
 634               	.L52:
 635               	/* epilogue start */
  69:ir_array.h    **** }
 636               		.loc 4 69 0
 637 02f8 0895      		ret
 638               	.L53:
  52:ir_array.h    **** 		controlMotor(FORWARD);
 639               		.loc 4 52 0
 640 02fa 80E0      		ldi r24,0
 641 02fc 00C0      		rjmp .L65
 642               	.LVL38:
 643               	.L55:
  59:ir_array.h    **** 	}else if(width == size){
 644               		.loc 4 59 0
 645 02fe 9813      		cpse r25,r24
 646 0300 00C0      		rjmp .L57
 647               	.L56:
  60:ir_array.h    **** 		count++;
 648               		.loc 4 60 0
 649 0302 4091 0000 		lds r20,count
 650 0306 5091 0000 		lds r21,count+1
 651 030a 6091 0000 		lds r22,count+2
 652 030e 7091 0000 		lds r23,count+3
 653 0312 4F5F      		subi r20,-1
 654 0314 5F4F      		sbci r21,-1
 655 0316 6F4F      		sbci r22,-1
 656 0318 7F4F      		sbci r23,-1
 657 031a 4093 0000 		sts count,r20
 658 031e 5093 0000 		sts count+1,r21
 659 0322 6093 0000 		sts count+2,r22
 660 0326 7093 0000 		sts count+3,r23
 661 032a 00C0      		rjmp .L57
 662               	.L60:
  67:ir_array.h    **** 			width --;
 663               		.loc 4 67 0
 664 032c 8150      		subi r24,lo8(-(-1))
 665               	.LVL39:
 666 032e 00C0      		rjmp .L66
 667               		.cfi_endproc
 668               	.LFE14:
 670               		.section	.text.startup,"ax",@progbits
 671               	.global	main
 673               	main:
 674               	.LFB16:
 675               		.file 5 "main.c"
   1:main.c        **** #define F_CPU 16000000UL
   2:main.c        **** 
   3:main.c        **** //Comment the MCU which you're not using.
   4:main.c        **** #define ATMEGA_328P
   5:main.c        **** //#define ATMEGA_32A
   6:main.c        **** 
   7:main.c        **** #include <avr/io.h>
   8:main.c        **** #include <util/delay.h>
   9:main.c        **** #include "ir_array.h"
  10:main.c        **** 
  11:main.c        **** int main(void){
 676               		.loc 5 11 0
 677               		.cfi_startproc
 678               	/* prologue: function */
 679               	/* frame size = 0 */
 680               	/* stack size = 0 */
 681               	.L__stack_usage = 0
  12:main.c        **** 
  13:main.c        **** 	setupPWM();
 682               		.loc 5 13 0
 683 0000 0E94 0000 		call setupPWM
 684               	.LVL40:
  14:main.c        **** 	setupMotor();
 685               		.loc 5 14 0
 686 0004 0E94 0000 		call setupMotor
 687               	.LVL41:
  15:main.c        **** 	initIR();
 688               		.loc 5 15 0
 689 0008 0E94 0000 		call initIR
 690               	.LVL42:
 691               	.L68:
  16:main.c        **** 
  17:main.c        **** 	while(1){
  18:main.c        **** 		//stableCar();
  19:main.c        **** 		controlMotor(FORWARD);
 692               		.loc 5 19 0 discriminator 1
 693 000c 80E0      		ldi r24,0
 694 000e 0E94 0000 		call controlMotor
 695               	.LVL43:
 696 0012 00C0      		rjmp .L68
 697               		.cfi_endproc
 698               	.LFE16:
 700               	.global	count
 701               		.section .bss
 704               	count:
 705 0000 0000 0000 		.zero	4
 706               	.global	width
 709               	width:
 710 0004 00        		.zero	1
 711               	.global	right_status
 714               	right_status:
 715 0005 00        		.zero	1
 716               	.global	left_status
 719               	left_status:
 720 0006 00        		.zero	1
 721               	.global	channelB_status
 724               	channelB_status:
 725 0007 00        		.zero	1
 726               	.global	channelA_status
 729               	channelA_status:
 730 0008 00        		.zero	1
 731               	.global	channelB
 734               	channelB:
 735 0009 0000      		.zero	2
 736               	.global	channelA
 739               	channelA:
 740 000b 0000      		.zero	2
 741               		.text
 742               	.Letext0:
 743               		.file 6 "/usr/avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccx3RB7T.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccx3RB7T.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccx3RB7T.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccx3RB7T.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccx3RB7T.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccx3RB7T.s:12     .text:0000000000000000 setupPWM
     /tmp/ccx3RB7T.s:39     .text:0000000000000014 pwm
     /tmp/ccx3RB7T.s:70     .text:0000000000000034 controlMotor
     /tmp/ccx3RB7T.s:739    .bss:000000000000000b channelA
     /tmp/ccx3RB7T.s:734    .bss:0000000000000009 channelB
     /tmp/ccx3RB7T.s:724    .bss:0000000000000007 channelB_status
     /tmp/ccx3RB7T.s:719    .bss:0000000000000006 left_status
     /tmp/ccx3RB7T.s:714    .bss:0000000000000005 right_status
     /tmp/ccx3RB7T.s:729    .bss:0000000000000008 channelA_status
     /tmp/ccx3RB7T.s:377    .text:000000000000022c setupMotor
     /tmp/ccx3RB7T.s:424    .text:0000000000000256 initUSART
     /tmp/ccx3RB7T.s:456    .text:0000000000000272 getCh
     /tmp/ccx3RB7T.s:479    .text:0000000000000280 putCh
     /tmp/ccx3RB7T.s:503    .text:000000000000028e initIR
     /tmp/ccx3RB7T.s:527    .text:000000000000029e lineSize
     /tmp/ccx3RB7T.s:585    .text:00000000000002b2 stableCar
     /tmp/ccx3RB7T.s:709    .bss:0000000000000004 width
     /tmp/ccx3RB7T.s:704    .bss:0000000000000000 count
     /tmp/ccx3RB7T.s:673    .text.startup:0000000000000000 main

UNDEFINED SYMBOLS
__do_clear_bss

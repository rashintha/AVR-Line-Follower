   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	setupPWM
  12               	setupPWM:
  13               	.LFB6:
  14               		.file 1 "pwm.h"
   1:pwm.h         **** #include <avr/io.h>
   2:pwm.h         **** #include "cpu_def.h"
   3:pwm.h         **** 
   4:pwm.h         **** //Define PWM Channels
   5:pwm.h         **** #define CH_A 0
   6:pwm.h         **** #define CH_B 1
   7:pwm.h         **** 
   8:pwm.h         **** void setupPWM(void);
   9:pwm.h         **** void pwm(uint8_t channel, uint16_t onTime, uint16_t period);
  10:pwm.h         **** 
  11:pwm.h         **** //Initializing PWM
  12:pwm.h         **** void setupPWM(void){
  15               		.loc 1 12 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  13:pwm.h         **** 	OC1x_DDR |= (1 << OC1A_PIN) | (1 << OC1B_PIN);
  21               		.loc 1 13 0
  22 0000 84B1      		in r24,0x4
  23 0002 8660      		ori r24,lo8(6)
  24 0004 84B9      		out 0x4,r24
  14:pwm.h         **** 	TCCR1A = (1 << COM1A1) | (1 << COM1B1) | (1 << WGM11);	
  25               		.loc 1 14 0
  26 0006 82EA      		ldi r24,lo8(-94)
  27 0008 8093 8000 		sts 128,r24
  15:pwm.h         **** 	TCCR1B = (1 << WGM13) | (1 << WGM12) | (1 << CS11);
  28               		.loc 1 15 0
  29 000c 8AE1      		ldi r24,lo8(26)
  30 000e 8093 8100 		sts 129,r24
  31               	/* epilogue start */
  16:pwm.h         **** }
  32               		.loc 1 16 0
  33 0012 0895      		ret
  34               		.cfi_endproc
  35               	.LFE6:
  37               	.global	pwm
  39               	pwm:
  40               	.LFB7:
  17:pwm.h         **** 
  18:pwm.h         **** //Set PWM of the selected channel
  19:pwm.h         **** void pwm(uint8_t channel, uint16_t onTime, uint16_t period){
  41               		.loc 1 19 0
  42               		.cfi_startproc
  43               	.LVL0:
  44               	/* prologue: function */
  45               	/* frame size = 0 */
  46               	/* stack size = 0 */
  47               	.L__stack_usage = 0
  20:pwm.h         **** 	ICR1 = period;
  48               		.loc 1 20 0
  49 0014 5093 8700 		sts 134+1,r21
  50 0018 4093 8600 		sts 134,r20
  21:pwm.h         **** 	(channel == CH_B) ? (OCR1B = onTime) : (OCR1A = onTime);
  51               		.loc 1 21 0
  52 001c 8130      		cpi r24,lo8(1)
  53 001e 01F4      		brne .L3
  54               		.loc 1 21 0 is_stmt 0 discriminator 1
  55 0020 7093 8B00 		sts 138+1,r23
  56 0024 6093 8A00 		sts 138,r22
  57 0028 0895      		ret
  58               	.L3:
  59               		.loc 1 21 0 discriminator 2
  60 002a 7093 8900 		sts 136+1,r23
  61 002e 6093 8800 		sts 136,r22
  62               	/* epilogue start */
  22:pwm.h         **** }...
  63               		.loc 1 22 0 is_stmt 1 discriminator 2
  64 0032 0895      		ret
  65               		.cfi_endproc
  66               	.LFE7:
  68               	.global	controlMotor
  70               	controlMotor:
  71               	.LFB9:
  72               		.file 2 "motor_control.h"
   1:motor_control.h **** #define FORWARD 0x00
   2:motor_control.h **** #define REVERSE	0x01
   3:motor_control.h **** #define RIGHT	0x02
   4:motor_control.h **** #define LEFT	0x03
   5:motor_control.h **** #define STOP 	0x04
   6:motor_control.h **** #define NEUTRAL	0x05
   7:motor_control.h **** 
   8:motor_control.h **** #define TRUE 	1
   9:motor_control.h **** #define FALSE 	0
  10:motor_control.h **** 
  11:motor_control.h **** #define MOTOR_DDR	DDRC
  12:motor_control.h **** #define MOTOR_PORT	PORTC
  13:motor_control.h **** 
  14:motor_control.h **** #define MOTOR_RIGHT_FWD_PIN		PC0
  15:motor_control.h **** #define MOTOR_RIGHT_REV_PIN		PC1
  16:motor_control.h **** #define MOTOR_LEFT_FWD_PIN		PC2
  17:motor_control.h **** #define MOTOR_LEFT_REV_PIN		PC3
  18:motor_control.h **** 
  19:motor_control.h **** #define FORWARD_MODE() { MOTOR_PORT |= (1 << MOTOR_RIGHT_FWD_PIN) | (1 << MOTOR_LEFT_FWD_PIN); MOTO
  20:motor_control.h **** #define REVERSE_MODE() { MOTOR_PORT |= (1 << MOTOR_RIGHT_REV_PIN) | (1 << MOTOR_LEFT_REV_PIN); MOTO
  21:motor_control.h **** #define RIGHT_MODE()   { MOTOR_PORT |= (1 << MOTOR_RIGHT_REV_PIN) | (1 << MOTOR_LEFT_FWD_PIN); MOTO
  22:motor_control.h **** #define LEFT_MODE()    { MOTOR_PORT |= (1 << MOTOR_RIGHT_FWD_PIN) | (1 << MOTOR_LEFT_REV_PIN); MOTO
  23:motor_control.h **** 
  24:motor_control.h **** #define MAX_PWM_SPEED	20000
  25:motor_control.h **** #define MIN_PWM_SPEED	2000
  26:motor_control.h **** 
  27:motor_control.h **** #define MAX_SPEED 10000
  28:motor_control.h **** #define SPEED_INCREASE_RATE		10
  29:motor_control.h **** #define SPEED_DECREASE_RATE		5
  30:motor_control.h **** #define BREAK_RATE				30
  31:motor_control.h **** 
  32:motor_control.h **** #include "pwm.h"
  33:motor_control.h **** 
  34:motor_control.h **** uint16_t channelA = 0, channelB = 0;
  35:motor_control.h **** uint8_t channelA_status = FORWARD, channelB_status = FORWARD, left_status = FALSE, right_status=FAL
  36:motor_control.h **** 
  37:motor_control.h **** void controlMotor(uint8_t status);
  38:motor_control.h **** void setupMotor(void);
  39:motor_control.h **** 
  40:motor_control.h **** void setupMotor(void){
  41:motor_control.h **** 	MOTOR_DDR = 0x0F;
  42:motor_control.h **** 
  43:motor_control.h **** 	pwm(CH_A, 0, MAX_PWM_SPEED);
  44:motor_control.h **** 	pwm(CH_B, 0, MAX_PWM_SPEED);
  45:motor_control.h **** 
  46:motor_control.h **** 	controlMotor(NEUTRAL);
  47:motor_control.h **** }
  48:motor_control.h **** 
  49:motor_control.h **** void controlMotor(uint8_t status){
  73               		.loc 2 49 0
  74               		.cfi_startproc
  75               	.LVL1:
  76               	/* prologue: function */
  77               	/* frame size = 0 */
  78               	/* stack size = 0 */
  79               	.L__stack_usage = 0
  50:motor_control.h **** 	switch(status){
  80               		.loc 2 50 0
  81 0034 8230      		cpi r24,lo8(2)
  82 0036 01F4      		brne .+2
  83 0038 00C0      		rjmp .L7
  84 003a 00F4      		brsh .L8
  85 003c 2091 0000 		lds r18,channelA
  86 0040 3091 0000 		lds r19,channelA+1
  87 0044 8823      		tst r24
  88 0046 01F4      		brne .+2
  89 0048 00C0      		rjmp .L9
  90 004a 8130      		cpi r24,lo8(1)
  91 004c 01F4      		brne .+2
  92 004e 00C0      		rjmp .L10
  93               	.LVL2:
  94               	.L6:
  51:motor_control.h **** 		case FORWARD:
  52:motor_control.h **** 			if(channelA_status == FORWARD && channelB_status == FORWARD){
  53:motor_control.h **** 				(channelA == MAX_SPEED) ? (channelA = MAX_SPEED) : (channelA += SPEED_INCREASE_RATE);
  54:motor_control.h **** 				channelB = channelA;
  55:motor_control.h **** 			}else if(channelA_status == REVERSE && channelB_status == REVERSE){
  56:motor_control.h **** 				if(channelA > MIN_PWM_SPEED){
  57:motor_control.h **** 					channelA -= BREAK_RATE;
  58:motor_control.h **** 					channelB = channelA;
  59:motor_control.h **** 				}else{
  60:motor_control.h **** 					FORWARD_MODE();
  61:motor_control.h **** 					channelA_status = FORWARD;
  62:motor_control.h **** 					channelB_status = FORWARD;
  63:motor_control.h **** 				}
  64:motor_control.h **** 			}
  65:motor_control.h **** 			break;
  66:motor_control.h **** 		
  67:motor_control.h **** 		case REVERSE:
  68:motor_control.h **** 			if(channelA_status == REVERSE && channelB_status == REVERSE){
  69:motor_control.h **** 				(channelA == MAX_SPEED) ? (channelA = MAX_SPEED) : (channelA += SPEED_INCREASE_RATE);
  70:motor_control.h **** 				channelB = channelA;
  71:motor_control.h **** 			}else if(channelA_status == FORWARD && channelB_status == FORWARD){
  72:motor_control.h **** 				if(channelA > MIN_PWM_SPEED){
  73:motor_control.h **** 					channelA -= BREAK_RATE;
  74:motor_control.h **** 					channelB = channelA;
  75:motor_control.h **** 				}else{
  76:motor_control.h **** 					REVERSE_MODE();
  77:motor_control.h **** 					channelA_status = REVERSE;
  78:motor_control.h **** 					channelB_status = REVERSE;
  79:motor_control.h **** 				}
  80:motor_control.h **** 			}
  81:motor_control.h **** 			break;
  82:motor_control.h **** 		
  83:motor_control.h **** 		case STOP:
  84:motor_control.h **** 			channelA = 0x00;
  85:motor_control.h **** 			channelB = 0x00;
  86:motor_control.h **** 			break;
  87:motor_control.h **** 
  88:motor_control.h **** 		case NEUTRAL:
  89:motor_control.h **** 			if(channelA > MIN_PWM_SPEED){
  90:motor_control.h **** 				channelA -= SPEED_DECREASE_RATE;
  91:motor_control.h **** 				channelB = channelA;
  92:motor_control.h **** 			}
  93:motor_control.h **** 
  94:motor_control.h **** 			if(channelB_status == FORWARD && channelB_status == FORWARD){
  95:motor_control.h **** 				FORWARD_MODE();
  96:motor_control.h **** 			}
  97:motor_control.h **** 			else{
  98:motor_control.h **** 				REVERSE_MODE();
  99:motor_control.h **** 			}
 100:motor_control.h **** 
 101:motor_control.h **** 			if(left_status || right_status){
 102:motor_control.h **** 				channelA = 0x00;
 103:motor_control.h **** 				channelB = 0x00;
 104:motor_control.h **** 				left_status = FALSE;
 105:motor_control.h **** 				right_status = FALSE;
 106:motor_control.h **** 			}
 107:motor_control.h **** 			break;
 108:motor_control.h **** 
 109:motor_control.h **** 		case RIGHT:
 110:motor_control.h **** 			RIGHT_MODE();
 111:motor_control.h **** 			if(channelA < MIN_PWM_SPEED){
 112:motor_control.h **** 				left_status = FALSE;
 113:motor_control.h **** 				right_status = TRUE;
 114:motor_control.h **** 				channelA = 15000;
 115:motor_control.h **** 				channelB = 15000;
 116:motor_control.h **** 			}
 117:motor_control.h **** 			break;
 118:motor_control.h **** 
 119:motor_control.h **** 		case LEFT:
 120:motor_control.h **** 			LEFT_MODE();
 121:motor_control.h **** 			if(channelA < MIN_PWM_SPEED){
 122:motor_control.h **** 				left_status = TRUE;
 123:motor_control.h **** 				right_status = FALSE;
 124:motor_control.h **** 				channelA = MAX_PWM_SPEED / 2;
 125:motor_control.h **** 				channelB = MAX_PWM_SPEED / 2;
 126:motor_control.h **** 			}
 127:motor_control.h **** 			break;
 128:motor_control.h **** 	}
 129:motor_control.h **** 
 130:motor_control.h **** 	pwm(CH_A, channelA, MAX_PWM_SPEED);
  95               		.loc 2 130 0
  96 0050 2091 0000 		lds r18,channelA
  97 0054 3091 0000 		lds r19,channelA+1
  98               	.LVL3:
  99               	.LBB20:
 100               	.LBB21:
  20:pwm.h         **** 	ICR1 = period;
 101               		.loc 1 20 0
 102 0058 80E2      		ldi r24,lo8(32)
 103 005a 9EE4      		ldi r25,lo8(78)
 104 005c 9093 8700 		sts 134+1,r25
 105 0060 8093 8600 		sts 134,r24
  21:pwm.h         **** 	(channel == CH_B) ? (OCR1B = onTime) : (OCR1A = onTime);
 106               		.loc 1 21 0
 107 0064 3093 8900 		sts 136+1,r19
 108 0068 2093 8800 		sts 136,r18
 109               	.LVL4:
 110               	.LBE21:
 111               	.LBE20:
 131:motor_control.h **** 	pwm(CH_B, channelB, MAX_PWM_SPEED);
 112               		.loc 2 131 0
 113 006c 2091 0000 		lds r18,channelB
 114 0070 3091 0000 		lds r19,channelB+1
 115               	.LVL5:
 116               	.LBB22:
 117               	.LBB23:
  20:pwm.h         **** 	ICR1 = period;
 118               		.loc 1 20 0
 119 0074 9093 8700 		sts 134+1,r25
 120 0078 8093 8600 		sts 134,r24
  21:pwm.h         **** 	(channel == CH_B) ? (OCR1B = onTime) : (OCR1A = onTime);
 121               		.loc 1 21 0
 122 007c 3093 8B00 		sts 138+1,r19
 123 0080 2093 8A00 		sts 138,r18
 124               	.LVL6:
 125               	/* epilogue start */
 126               	.LBE23:
 127               	.LBE22:
 132:motor_control.h **** }...
 128               		.loc 2 132 0
 129 0084 0895      		ret
 130               	.LVL7:
 131               	.L8:
  50:motor_control.h **** 	switch(status){
 132               		.loc 2 50 0
 133 0086 8430      		cpi r24,lo8(4)
 134 0088 01F4      		brne .+2
 135 008a 00C0      		rjmp .L11
 136 008c 00F4      		brsh .+2
 137 008e 00C0      		rjmp .L12
 138 0090 8530      		cpi r24,lo8(5)
 139 0092 01F4      		brne .L6
  89:motor_control.h **** 			if(channelA > MIN_PWM_SPEED){
 140               		.loc 2 89 0
 141 0094 8091 0000 		lds r24,channelA
 142 0098 9091 0000 		lds r25,channelA+1
 143               	.LVL8:
 144 009c 813D      		cpi r24,-47
 145 009e 27E0      		ldi r18,7
 146 00a0 9207      		cpc r25,r18
 147 00a2 00F0      		brlo .L22
  90:motor_control.h **** 				channelA -= SPEED_DECREASE_RATE;
 148               		.loc 2 90 0
 149 00a4 0597      		sbiw r24,5
 150 00a6 9093 0000 		sts channelA+1,r25
 151 00aa 8093 0000 		sts channelA,r24
  91:motor_control.h **** 				channelB = channelA;
 152               		.loc 2 91 0
 153 00ae 9093 0000 		sts channelB+1,r25
 154 00b2 8093 0000 		sts channelB,r24
 155               	.L22:
  94:motor_control.h **** 			if(channelB_status == FORWARD && channelB_status == FORWARD){
 156               		.loc 2 94 0
 157 00b6 8091 0000 		lds r24,channelB_status
 158 00ba 8111      		cpse r24,__zero_reg__
 159 00bc 00C0      		rjmp .L23
  95:motor_control.h **** 				FORWARD_MODE();
 160               		.loc 2 95 0
 161 00be 88B1      		in r24,0x8
 162 00c0 8560      		ori r24,lo8(5)
 163 00c2 88B9      		out 0x8,r24
 164 00c4 88B1      		in r24,0x8
 165 00c6 857F      		andi r24,lo8(-11)
 166               	.L35:
  98:motor_control.h **** 				REVERSE_MODE();
 167               		.loc 2 98 0
 168 00c8 88B9      		out 0x8,r24
 101:motor_control.h **** 			if(left_status || right_status){
 169               		.loc 2 101 0
 170 00ca 8091 0000 		lds r24,left_status
 171 00ce 8111      		cpse r24,__zero_reg__
 172 00d0 00C0      		rjmp .L25
 101:motor_control.h **** 			if(left_status || right_status){
 173               		.loc 2 101 0 is_stmt 0 discriminator 1
 174 00d2 8091 0000 		lds r24,right_status
 175 00d6 8823      		tst r24
 176 00d8 01F4      		brne .+2
 177 00da 00C0      		rjmp .L6
 178               	.L25:
 102:motor_control.h **** 				channelA = 0x00;
 179               		.loc 2 102 0 is_stmt 1
 180 00dc 1092 0000 		sts channelA+1,__zero_reg__
 181 00e0 1092 0000 		sts channelA,__zero_reg__
 103:motor_control.h **** 				channelB = 0x00;
 182               		.loc 2 103 0
 183 00e4 1092 0000 		sts channelB+1,__zero_reg__
 184 00e8 1092 0000 		sts channelB,__zero_reg__
 104:motor_control.h **** 				left_status = FALSE;
 185               		.loc 2 104 0
 186 00ec 1092 0000 		sts left_status,__zero_reg__
 105:motor_control.h **** 				right_status = FALSE;
 187               		.loc 2 105 0
 188 00f0 1092 0000 		sts right_status,__zero_reg__
 189 00f4 00C0      		rjmp .L6
 190               	.LVL9:
 191               	.L9:
  52:motor_control.h **** 			if(channelA_status == FORWARD && channelB_status == FORWARD){
 192               		.loc 2 52 0
 193 00f6 8091 0000 		lds r24,channelA_status
 194               	.LVL10:
 195 00fa 8111      		cpse r24,__zero_reg__
 196 00fc 00C0      		rjmp .L14
  52:motor_control.h **** 			if(channelA_status == FORWARD && channelB_status == FORWARD){
 197               		.loc 2 52 0 is_stmt 0 discriminator 1
 198 00fe 8091 0000 		lds r24,channelB_status
 199 0102 8111      		cpse r24,__zero_reg__
 200 0104 00C0      		rjmp .L6
 201               	.L40:
  69:motor_control.h **** 				(channelA == MAX_SPEED) ? (channelA = MAX_SPEED) : (channelA += SPEED_INCREASE_RATE);
 202               		.loc 2 69 0 is_stmt 1
 203 0106 2031      		cpi r18,16
 204 0108 87E2      		ldi r24,39
 205 010a 3807      		cpc r19,r24
 206 010c 01F0      		breq .L20
  69:motor_control.h **** 				(channelA == MAX_SPEED) ? (channelA = MAX_SPEED) : (channelA += SPEED_INCREASE_RATE);
 207               		.loc 2 69 0 is_stmt 0 discriminator 2
 208 010e 265F      		subi r18,-10
 209 0110 3F4F      		sbci r19,-1
 210 0112 3093 0000 		sts channelA+1,r19
 211 0116 2093 0000 		sts channelA,r18
 212               	.L20:
  70:motor_control.h **** 				channelB = channelA;
 213               		.loc 2 70 0 is_stmt 1
 214 011a 8091 0000 		lds r24,channelA
 215 011e 9091 0000 		lds r25,channelA+1
 216               	.L36:
 125:motor_control.h **** 				channelB = MAX_PWM_SPEED / 2;
 217               		.loc 2 125 0
 218 0122 9093 0000 		sts channelB+1,r25
 219 0126 8093 0000 		sts channelB,r24
 220 012a 00C0      		rjmp .L6
 221               	.L14:
  55:motor_control.h **** 			}else if(channelA_status == REVERSE && channelB_status == REVERSE){
 222               		.loc 2 55 0
 223 012c 8130      		cpi r24,lo8(1)
 224 012e 01F0      		breq .+2
 225 0130 00C0      		rjmp .L6
  55:motor_control.h **** 			}else if(channelA_status == REVERSE && channelB_status == REVERSE){
 226               		.loc 2 55 0 is_stmt 0 discriminator 1
 227 0132 8091 0000 		lds r24,channelB_status
 228 0136 8130      		cpi r24,lo8(1)
 229 0138 01F0      		breq .+2
 230 013a 00C0      		rjmp .L6
  56:motor_control.h **** 				if(channelA > MIN_PWM_SPEED){
 231               		.loc 2 56 0 is_stmt 1
 232 013c 213D      		cpi r18,-47
 233 013e 97E0      		ldi r25,7
 234 0140 3907      		cpc r19,r25
 235 0142 00F0      		brlo .L18
 236               	.L38:
  73:motor_control.h **** 					channelA -= BREAK_RATE;
 237               		.loc 2 73 0
 238 0144 2E51      		subi r18,30
 239 0146 3109      		sbc r19,__zero_reg__
 240 0148 3093 0000 		sts channelA+1,r19
 241 014c 2093 0000 		sts channelA,r18
  74:motor_control.h **** 					channelB = channelA;
 242               		.loc 2 74 0
 243 0150 3093 0000 		sts channelB+1,r19
 244 0154 2093 0000 		sts channelB,r18
 245 0158 00C0      		rjmp .L6
 246               	.L18:
  60:motor_control.h **** 					FORWARD_MODE();
 247               		.loc 2 60 0
 248 015a 88B1      		in r24,0x8
 249 015c 8560      		ori r24,lo8(5)
 250 015e 88B9      		out 0x8,r24
 251 0160 88B1      		in r24,0x8
 252 0162 857F      		andi r24,lo8(-11)
 253 0164 88B9      		out 0x8,r24
  61:motor_control.h **** 					channelA_status = FORWARD;
 254               		.loc 2 61 0
 255 0166 1092 0000 		sts channelA_status,__zero_reg__
  62:motor_control.h **** 					channelB_status = FORWARD;
 256               		.loc 2 62 0
 257 016a 1092 0000 		sts channelB_status,__zero_reg__
 258 016e 00C0      		rjmp .L6
 259               	.LVL11:
 260               	.L10:
  68:motor_control.h **** 			if(channelA_status == REVERSE && channelB_status == REVERSE){
 261               		.loc 2 68 0
 262 0170 9091 0000 		lds r25,channelA_status
 263 0174 9130      		cpi r25,lo8(1)
 264 0176 01F4      		brne .L19
  68:motor_control.h **** 			if(channelA_status == REVERSE && channelB_status == REVERSE){
 265               		.loc 2 68 0 is_stmt 0 discriminator 1
 266 0178 8091 0000 		lds r24,channelB_status
 267               	.LVL12:
 268 017c 8130      		cpi r24,lo8(1)
 269 017e 01F0      		breq .+2
 270 0180 00C0      		rjmp .L6
 271 0182 00C0      		rjmp .L40
 272               	.LVL13:
 273               	.L19:
  71:motor_control.h **** 			}else if(channelA_status == FORWARD && channelB_status == FORWARD){
 274               		.loc 2 71 0 is_stmt 1
 275 0184 9111      		cpse r25,__zero_reg__
 276 0186 00C0      		rjmp .L6
  71:motor_control.h **** 			}else if(channelA_status == FORWARD && channelB_status == FORWARD){
 277               		.loc 2 71 0 is_stmt 0 discriminator 1
 278 0188 9091 0000 		lds r25,channelB_status
 279 018c 9111      		cpse r25,__zero_reg__
 280 018e 00C0      		rjmp .L6
  72:motor_control.h **** 				if(channelA > MIN_PWM_SPEED){
 281               		.loc 2 72 0 is_stmt 1
 282 0190 213D      		cpi r18,-47
 283 0192 97E0      		ldi r25,7
 284 0194 3907      		cpc r19,r25
 285 0196 00F4      		brsh .L38
  76:motor_control.h **** 					REVERSE_MODE();
 286               		.loc 2 76 0
 287 0198 98B1      		in r25,0x8
 288 019a 9A60      		ori r25,lo8(10)
 289 019c 98B9      		out 0x8,r25
 290 019e 98B1      		in r25,0x8
 291 01a0 9A7F      		andi r25,lo8(-6)
 292 01a2 98B9      		out 0x8,r25
  77:motor_control.h **** 					channelA_status = REVERSE;
 293               		.loc 2 77 0
 294 01a4 8093 0000 		sts channelA_status,r24
  78:motor_control.h **** 					channelB_status = REVERSE;
 295               		.loc 2 78 0
 296 01a8 8093 0000 		sts channelB_status,r24
 297 01ac 00C0      		rjmp .L6
 298               	.L11:
  84:motor_control.h **** 			channelA = 0x00;
 299               		.loc 2 84 0
 300 01ae 1092 0000 		sts channelA+1,__zero_reg__
 301 01b2 1092 0000 		sts channelA,__zero_reg__
  85:motor_control.h **** 			channelB = 0x00;
 302               		.loc 2 85 0
 303 01b6 1092 0000 		sts channelB+1,__zero_reg__
 304 01ba 1092 0000 		sts channelB,__zero_reg__
  86:motor_control.h **** 			break;
 305               		.loc 2 86 0
 306 01be 00C0      		rjmp .L6
 307               	.LVL14:
 308               	.L23:
  98:motor_control.h **** 				REVERSE_MODE();
 309               		.loc 2 98 0
 310 01c0 88B1      		in r24,0x8
 311 01c2 8A60      		ori r24,lo8(10)
 312 01c4 88B9      		out 0x8,r24
 313 01c6 88B1      		in r24,0x8
 314 01c8 8A7F      		andi r24,lo8(-6)
 315 01ca 00C0      		rjmp .L35
 316               	.LVL15:
 317               	.L7:
 110:motor_control.h **** 			RIGHT_MODE();
 318               		.loc 2 110 0
 319 01cc 88B1      		in r24,0x8
 320               	.LVL16:
 321 01ce 8660      		ori r24,lo8(6)
 322 01d0 88B9      		out 0x8,r24
 323 01d2 88B1      		in r24,0x8
 324 01d4 867F      		andi r24,lo8(-10)
 325 01d6 88B9      		out 0x8,r24
 111:motor_control.h **** 			if(channelA < MIN_PWM_SPEED){
 326               		.loc 2 111 0
 327 01d8 8091 0000 		lds r24,channelA
 328 01dc 9091 0000 		lds r25,channelA+1
 329 01e0 803D      		cpi r24,-48
 330 01e2 9740      		sbci r25,7
 331 01e4 00F0      		brlo .+2
 332 01e6 00C0      		rjmp .L6
 112:motor_control.h **** 				left_status = FALSE;
 333               		.loc 2 112 0
 334 01e8 1092 0000 		sts left_status,__zero_reg__
 113:motor_control.h **** 				right_status = TRUE;
 335               		.loc 2 113 0
 336 01ec 81E0      		ldi r24,lo8(1)
 337 01ee 8093 0000 		sts right_status,r24
 114:motor_control.h **** 				channelA = 15000;
 338               		.loc 2 114 0
 339 01f2 88E9      		ldi r24,lo8(-104)
 340 01f4 9AE3      		ldi r25,lo8(58)
 341               	.L37:
 124:motor_control.h **** 				channelA = MAX_PWM_SPEED / 2;
 342               		.loc 2 124 0
 343 01f6 9093 0000 		sts channelA+1,r25
 344 01fa 8093 0000 		sts channelA,r24
 345 01fe 00C0      		rjmp .L36
 346               	.LVL17:
 347               	.L12:
 120:motor_control.h **** 			LEFT_MODE();
 348               		.loc 2 120 0
 349 0200 88B1      		in r24,0x8
 350               	.LVL18:
 351 0202 8960      		ori r24,lo8(9)
 352 0204 88B9      		out 0x8,r24
 353 0206 88B1      		in r24,0x8
 354 0208 897F      		andi r24,lo8(-7)
 355 020a 88B9      		out 0x8,r24
 121:motor_control.h **** 			if(channelA < MIN_PWM_SPEED){
 356               		.loc 2 121 0
 357 020c 8091 0000 		lds r24,channelA
 358 0210 9091 0000 		lds r25,channelA+1
 359 0214 803D      		cpi r24,-48
 360 0216 9740      		sbci r25,7
 361 0218 00F0      		brlo .+2
 362 021a 00C0      		rjmp .L6
 122:motor_control.h **** 				left_status = TRUE;
 363               		.loc 2 122 0
 364 021c 81E0      		ldi r24,lo8(1)
 365 021e 8093 0000 		sts left_status,r24
 123:motor_control.h **** 				right_status = FALSE;
 366               		.loc 2 123 0
 367 0222 1092 0000 		sts right_status,__zero_reg__
 124:motor_control.h **** 				channelA = MAX_PWM_SPEED / 2;
 368               		.loc 2 124 0
 369 0226 80E1      		ldi r24,lo8(16)
 370 0228 97E2      		ldi r25,lo8(39)
 371 022a 00C0      		rjmp .L37
 372               		.cfi_endproc
 373               	.LFE9:
 375               	.global	setupMotor
 377               	setupMotor:
 378               	.LFB8:
  40:motor_control.h **** void setupMotor(void){
 379               		.loc 2 40 0
 380               		.cfi_startproc
 381               	/* prologue: function */
 382               	/* frame size = 0 */
 383               	/* stack size = 0 */
 384               	.L__stack_usage = 0
  41:motor_control.h **** 	MOTOR_DDR = 0x0F;
 385               		.loc 2 41 0
 386 022c 8FE0      		ldi r24,lo8(15)
 387 022e 87B9      		out 0x7,r24
 388               	.LVL19:
 389               	.LBB24:
 390               	.LBB25:
  20:pwm.h         **** 	ICR1 = period;
 391               		.loc 1 20 0
 392 0230 E6E8      		ldi r30,lo8(-122)
 393 0232 F0E0      		ldi r31,0
 394 0234 80E2      		ldi r24,lo8(32)
 395 0236 9EE4      		ldi r25,lo8(78)
 396 0238 9183      		std Z+1,r25
 397 023a 8083      		st Z,r24
  21:pwm.h         **** 	(channel == CH_B) ? (OCR1B = onTime) : (OCR1A = onTime);
 398               		.loc 1 21 0
 399 023c 1092 8900 		sts 136+1,__zero_reg__
 400 0240 1092 8800 		sts 136,__zero_reg__
 401               	.LVL20:
 402               	.LBE25:
 403               	.LBE24:
 404               	.LBB26:
 405               	.LBB27:
  20:pwm.h         **** 	ICR1 = period;
 406               		.loc 1 20 0
 407 0244 9183      		std Z+1,r25
 408 0246 8083      		st Z,r24
  21:pwm.h         **** 	(channel == CH_B) ? (OCR1B = onTime) : (OCR1A = onTime);
 409               		.loc 1 21 0
 410 0248 1092 8B00 		sts 138+1,__zero_reg__
 411 024c 1092 8A00 		sts 138,__zero_reg__
 412               	.LVL21:
 413               	.LBE27:
 414               	.LBE26:
  46:motor_control.h **** 	controlMotor(NEUTRAL);
 415               		.loc 2 46 0
 416 0250 85E0      		ldi r24,lo8(5)
 417 0252 0C94 0000 		jmp controlMotor
 418               	.LVL22:
 419               		.cfi_endproc
 420               	.LFE8:
 422               	.global	initUSART
 424               	initUSART:
 425               	.LFB10:
 426               		.file 3 "serial.h"
   1:serial.h      **** #define BAUD_RATE 9600
   2:serial.h      **** 
   3:serial.h      **** #include <avr/io.h>
   4:serial.h      **** #include "cpu_def.h"
   5:serial.h      **** 
   6:serial.h      **** void initUSART(void);
   7:serial.h      **** uint8_t getCh(void);
   8:serial.h      **** void putCh(uint8_t data);
   9:serial.h      **** 
  10:serial.h      **** void initUSART(void){
 427               		.loc 3 10 0
 428               		.cfi_startproc
 429               	/* prologue: function */
 430               	/* frame size = 0 */
 431               	/* stack size = 0 */
 432               	.L__stack_usage = 0
 433               	.LVL23:
  11:serial.h      ****    //Set Baud rate; ubrr_value = F_OSC/(16 x Baud_rate) - 1; e.g. 16e6/(9600*16) -1 = 103
  12:serial.h      **** 	uint32_t ubrr_value;
  13:serial.h      **** 	ubrr_value = F_CPU/16/BAUD_RATE -1; 
  14:serial.h      **** 	UBRRL_REG = ubrr_value;
 434               		.loc 3 14 0
 435 0256 87E6      		ldi r24,lo8(103)
 436 0258 8093 C400 		sts 196,r24
  15:serial.h      **** 	UBRRH_REG = (ubrr_value >> 8);
 437               		.loc 3 15 0
 438 025c 1092 C500 		sts 197,__zero_reg__
  16:serial.h      **** 	UCSRC_REG |= (1 << UCSZ1_BIT) | (1 << UCSZ0_BIT);
 439               		.loc 3 16 0
 440 0260 E2EC      		ldi r30,lo8(-62)
 441 0262 F0E0      		ldi r31,0
 442 0264 8081      		ld r24,Z
 443 0266 8660      		ori r24,lo8(6)
 444 0268 8083      		st Z,r24
  17:serial.h      **** 
  18:serial.h      **** 	#ifdef ATMEGA_32A
  19:serial.h      **** 	UCSRC_REG |= (1 << URSEL_BIT);
  20:serial.h      **** 	#endif
  21:serial.h      **** 
  22:serial.h      **** 	//Enable The receiver and transmitter
  23:serial.h      **** 	UCSRB_REG = (1 << RXEN_BIT) | (1 << TXEN_BIT);
 445               		.loc 3 23 0
 446 026a 88E1      		ldi r24,lo8(24)
 447 026c 8093 C100 		sts 193,r24
 448               	/* epilogue start */
  24:serial.h      **** }
 449               		.loc 3 24 0
 450 0270 0895      		ret
 451               		.cfi_endproc
 452               	.LFE10:
 454               	.global	getCh
 456               	getCh:
 457               	.LFB11:
  25:serial.h      **** 
  26:serial.h      **** uint8_t getCh(void){
 458               		.loc 3 26 0
 459               		.cfi_startproc
 460               	/* prologue: function */
 461               	/* frame size = 0 */
 462               	/* stack size = 0 */
 463               	.L__stack_usage = 0
 464               	.L44:
  27:serial.h      **** 	while(!(UCSRA_REG & (1 << RXC_BIT)));
 465               		.loc 3 27 0 discriminator 1
 466 0272 8091 C000 		lds r24,192
 467 0276 87FF      		sbrs r24,7
 468 0278 00C0      		rjmp .L44
  28:serial.h      **** 	return UDR_REG;
 469               		.loc 3 28 0
 470 027a 8091 C600 		lds r24,198
 471               	/* epilogue start */
  29:serial.h      **** }
 472               		.loc 3 29 0
 473 027e 0895      		ret
 474               		.cfi_endproc
 475               	.LFE11:
 477               	.global	putCh
 479               	putCh:
 480               	.LFB12:
  30:serial.h      **** 
  31:serial.h      **** void putCh(uint8_t data){
 481               		.loc 3 31 0
 482               		.cfi_startproc
 483               	/* prologue: function */
 484               	/* frame size = 0 */
 485               	/* stack size = 0 */
 486               	.L__stack_usage = 0
 487               	.LVL24:
 488               	.L47:
  32:serial.h      **** 	while(!(UCSRA_REG & (1 << UDRE_BIT)));
 489               		.loc 3 32 0 discriminator 1
 490 0280 9091 C000 		lds r25,192
 491 0284 95FF      		sbrs r25,5
 492 0286 00C0      		rjmp .L47
  33:serial.h      **** 	UDR_REG = data;
 493               		.loc 3 33 0
 494 0288 8093 C600 		sts 198,r24
 495               	/* epilogue start */
  34:serial.h      **** }...
 496               		.loc 3 34 0
 497 028c 0895      		ret
 498               		.cfi_endproc
 499               	.LFE12:
 501               	.global	initIR
 503               	initIR:
 504               	.LFB13:
 505               		.file 4 "ir_array.h"
   1:ir_array.h    **** #define IR_LEFT_DDR DDRD
   2:ir_array.h    **** #define IR_LEFT_PIN PIND
   3:ir_array.h    **** 
   4:ir_array.h    **** #define IR_L_01 PD2
   5:ir_array.h    **** #define IR_L_02 PD3
   6:ir_array.h    **** #define IR_L_03 PD4
   7:ir_array.h    **** #define IR_L_04 PD5
   8:ir_array.h    **** 
   9:ir_array.h    **** #define IR_RIGHT_DDR DDRB
  10:ir_array.h    **** #define IR_RIGHT_PIN PINB
  11:ir_array.h    **** 
  12:ir_array.h    **** #define IR_R_05 PB5
  13:ir_array.h    **** #define IR_R_06 PB3
  14:ir_array.h    **** #define IR_R_07 PB4
  15:ir_array.h    **** #define IR_R_08 PB0
  16:ir_array.h    **** 
  17:ir_array.h    **** #define IR01_VAL() ({ uint8_t retVal = (IR_LEFT_PIN & (1 << IR_L_01)) ? (1 << 0) : 0; retVal;})
  18:ir_array.h    **** #define IR02_VAL() ({uint8_t retVal = (IR_LEFT_PIN & (1 << IR_L_02)) ? (1 << 1) : 0; retVal;})
  19:ir_array.h    **** #define IR03_VAL() ({uint8_t retVal = (IR_LEFT_PIN & (1 << IR_L_03)) ? (1 << 2) : 0; retVal;})
  20:ir_array.h    **** #define IR04_VAL() ({uint8_t retVal = (IR_LEFT_PIN & (1 << IR_L_04)) ? (1 << 3) : 0; retVal;})
  21:ir_array.h    **** #define IR05_VAL() ({uint8_t retVal = (IR_RIGHT_PIN & (1 << IR_R_05)) ? (1 << 4) : 0; retVal;})
  22:ir_array.h    **** #define IR06_VAL() ({uint8_t retVal = (IR_RIGHT_PIN & (1 << IR_R_06)) ? (1 << 5) : 0; retVal;})
  23:ir_array.h    **** #define IR07_VAL() ({uint8_t retVal = (IR_RIGHT_PIN & (1 << IR_R_07)) ? (1 << 6) : 0; retVal;})
  24:ir_array.h    **** #define IR08_VAL() ({uint8_t retVal = (IR_RIGHT_PIN & (1 << IR_R_08)) ? (1 << 7) : 0; retVal;})
  25:ir_array.h    **** 
  26:ir_array.h    **** #define IR_ARR_VAL IR01_VAL() | IR02_VAL() | IR03_VAL() | IR04_VAL() | IR05_VAL() | IR06_VAL() | IR
  27:ir_array.h    **** 
  28:ir_array.h    **** #define SETUP_IR() {IR_LEFT_DDR &= ~((1 << IR_L_01) | (1 << IR_L_02) | (1 << IR_L_03) | (1 << IR_L_
  29:ir_array.h    **** 
  30:ir_array.h    **** #include "motor_control.h"
  31:ir_array.h    **** #include "serial.h"
  32:ir_array.h    **** 
  33:ir_array.h    **** uint8_t width = 0;
  34:ir_array.h    **** uint32_t count = 0;
  35:ir_array.h    **** 
  36:ir_array.h    **** void initIR(void);
  37:ir_array.h    **** void stableCar(void);
  38:ir_array.h    **** uint8_t lineSize(void);
  39:ir_array.h    ****  
  40:ir_array.h    **** void initIR(void){
 506               		.loc 4 40 0
 507               		.cfi_startproc
 508               	/* prologue: function */
 509               	/* frame size = 0 */
 510               	/* stack size = 0 */
 511               	.L__stack_usage = 0
  41:ir_array.h    **** 	SETUP_IR();
 512               		.loc 4 41 0
 513 028e 8AB1      		in r24,0xa
 514 0290 837C      		andi r24,lo8(-61)
 515 0292 8AB9      		out 0xa,r24
 516 0294 84B1      		in r24,0x4
 517 0296 867C      		andi r24,lo8(-58)
 518 0298 84B9      		out 0x4,r24
  42:ir_array.h    **** 	initUSART();
 519               		.loc 4 42 0
 520 029a 0C94 0000 		jmp initUSART
 521               	.LVL25:
 522               		.cfi_endproc
 523               	.LFE13:
 525               	.global	lineSize
 527               	lineSize:
 528               	.LFB15:
  43:ir_array.h    **** }
  44:ir_array.h    **** 
  45:ir_array.h    **** void stableCar(void){
  46:ir_array.h    **** 	putCh(IR_ARR_VAL);
  47:ir_array.h    **** 	_delay_ms(100);
  48:ir_array.h    **** 	if(width == 0 || width >= 8){
  49:ir_array.h    **** 		controlMotor(STOP);
  50:ir_array.h    **** 	}else{
  51:ir_array.h    **** 		
  52:ir_array.h    **** 		controlMotor(FORWARD);
  53:ir_array.h    **** 	}
  54:ir_array.h    **** 
  55:ir_array.h    **** 	uint8_t size = lineSize();
  56:ir_array.h    **** 
  57:ir_array.h    **** 	if(width == 0 && size != 0){
  58:ir_array.h    **** 		width = size;
  59:ir_array.h    **** 	}else if(width == size){
  60:ir_array.h    **** 		count++;
  61:ir_array.h    **** 	}
  62:ir_array.h    **** 
  63:ir_array.h    **** 	if(count >= 255){
  64:ir_array.h    **** 		width = size;
  65:ir_array.h    **** 
  66:ir_array.h    **** 		if(width % 2 != 0)
  67:ir_array.h    **** 			width --;
  68:ir_array.h    **** 	}
  69:ir_array.h    **** }
  70:ir_array.h    **** 
  71:ir_array.h    **** uint8_t lineSize(void){
 529               		.loc 4 71 0
 530               		.cfi_startproc
 531               	/* prologue: function */
 532               	/* frame size = 0 */
 533               	/* stack size = 0 */
 534               	.L__stack_usage = 0
 535               	.LVL26:
 536               	.LBB28:
  72:ir_array.h    **** 	uint8_t size = 0;
  73:ir_array.h    **** 
  74:ir_array.h    **** 	if(~IR01_VAL()) size++;
 537               		.loc 4 74 0
 538 029e 89B1      		in r24,0x9
 539               	.LVL27:
 540               	.LBE28:
 541               	.LBB29:
  75:ir_array.h    **** 	if(~IR02_VAL()) size++;
 542               		.loc 4 75 0
 543 02a0 89B1      		in r24,0x9
 544               	.LVL28:
 545               	.LBE29:
 546               	.LBB30:
  76:ir_array.h    **** 	if(~IR03_VAL()) size++;
 547               		.loc 4 76 0
 548 02a2 89B1      		in r24,0x9
 549               	.LVL29:
 550               	.LBE30:
 551               	.LBB31:
  77:ir_array.h    **** 	if(~IR04_VAL()) size++;
 552               		.loc 4 77 0
 553 02a4 89B1      		in r24,0x9
 554               	.LVL30:
 555               	.LBE31:
 556               	.LBB32:
  78:ir_array.h    **** 	if(~IR05_VAL()) size++;
 557               		.loc 4 78 0
 558 02a6 83B1      		in r24,0x3
 559               	.LVL31:
 560               	.LBE32:
 561               	.LBB33:
  79:ir_array.h    **** 	if(~IR06_VAL()) size++;
 562               		.loc 4 79 0
 563 02a8 83B1      		in r24,0x3
 564               	.LVL32:
 565               	.LBE33:
 566               	.LBB34:
  80:ir_array.h    **** 	if(~IR07_VAL()) size++;
 567               		.loc 4 80 0
 568 02aa 83B1      		in r24,0x3
 569               	.LVL33:
 570               	.LBE34:
 571               	.LBB35:
  81:ir_array.h    **** 	if(~IR08_VAL()) size++;
 572               		.loc 4 81 0
 573 02ac 83B1      		in r24,0x3
 574               	.LVL34:
 575               	.LBE35:
  82:ir_array.h    **** 
  83:ir_array.h    **** 	return size;
  84:ir_array.h    **** }...
 576               		.loc 4 84 0
 577 02ae 88E0      		ldi r24,lo8(8)
 578               	/* epilogue start */
 579 02b0 0895      		ret
 580               		.cfi_endproc
 581               	.LFE15:
 583               	.global	stableCar
 585               	stableCar:
 586               	.LFB14:
  45:ir_array.h    **** void stableCar(void){
 587               		.loc 4 45 0
 588               		.cfi_startproc
 589               	/* prologue: function */
 590               	/* frame size = 0 */
 591               	/* stack size = 0 */
 592               	.L__stack_usage = 0
 593               	.LBB36:
  46:ir_array.h    **** 	putCh(IR_ARR_VAL);
 594               		.loc 4 46 0
 595 02b2 89B1      		in r24,0x9
 596 02b4 82FB      		bst r24,2
 597 02b6 9927      		clr r25
 598 02b8 90F9      		bld r25,0
 599               	.LVL35:
 600               	.LBE36:
 601               	.LBB37:
 602 02ba 4B99      		sbic 0x9,3
 603 02bc 00C0      		rjmp .L69
 604 02be 80E0      		ldi r24,0
 605               	.L53:
 606               	.LVL36:
 607               	.LBE37:
  46:ir_array.h    **** 	putCh(IR_ARR_VAL);
 608               		.loc 4 46 0 is_stmt 0 discriminator 4
 609 02c0 892B      		or r24,r25
 610               	.LVL37:
 611               	.LBB38:
 612 02c2 4C99      		sbic 0x9,4
 613 02c4 00C0      		rjmp .L70
  46:ir_array.h    **** 	putCh(IR_ARR_VAL);
 614               		.loc 4 46 0
 615 02c6 90E0      		ldi r25,0
 616               	.LVL38:
 617               	.L54:
 618               	.LBE38:
  46:ir_array.h    **** 	putCh(IR_ARR_VAL);
 619               		.loc 4 46 0 discriminator 8
 620 02c8 892B      		or r24,r25
 621               	.LBB39:
 622 02ca 4D99      		sbic 0x9,5
 623 02cc 00C0      		rjmp .L71
  46:ir_array.h    **** 	putCh(IR_ARR_VAL);
 624               		.loc 4 46 0
 625 02ce 90E0      		ldi r25,0
 626               	.LVL39:
 627               	.L55:
 628               	.LBE39:
  46:ir_array.h    **** 	putCh(IR_ARR_VAL);
 629               		.loc 4 46 0 discriminator 12
 630 02d0 892B      		or r24,r25
 631               	.LBB40:
 632 02d2 1D99      		sbic 0x3,5
 633 02d4 00C0      		rjmp .L72
  46:ir_array.h    **** 	putCh(IR_ARR_VAL);
 634               		.loc 4 46 0
 635 02d6 90E0      		ldi r25,0
 636               	.LVL40:
 637               	.L56:
 638               	.LBE40:
  46:ir_array.h    **** 	putCh(IR_ARR_VAL);
 639               		.loc 4 46 0 discriminator 16
 640 02d8 892B      		or r24,r25
 641               	.LBB41:
 642 02da 1B99      		sbic 0x3,3
 643 02dc 00C0      		rjmp .L73
  46:ir_array.h    **** 	putCh(IR_ARR_VAL);
 644               		.loc 4 46 0
 645 02de 90E0      		ldi r25,0
 646               	.LVL41:
 647               	.L57:
 648               	.LBE41:
  46:ir_array.h    **** 	putCh(IR_ARR_VAL);
 649               		.loc 4 46 0 discriminator 20
 650 02e0 892B      		or r24,r25
 651               	.LBB42:
 652 02e2 1C99      		sbic 0x3,4
 653 02e4 00C0      		rjmp .L74
  46:ir_array.h    **** 	putCh(IR_ARR_VAL);
 654               		.loc 4 46 0
 655 02e6 90E0      		ldi r25,0
 656               	.LVL42:
 657               	.L58:
 658               	.LBE42:
  46:ir_array.h    **** 	putCh(IR_ARR_VAL);
 659               		.loc 4 46 0 discriminator 24
 660 02e8 892B      		or r24,r25
 661               	.LBB43:
 662 02ea 1899      		sbic 0x3,0
 663 02ec 00C0      		rjmp .L75
  46:ir_array.h    **** 	putCh(IR_ARR_VAL);
 664               		.loc 4 46 0
 665 02ee 90E0      		ldi r25,0
 666               	.LVL43:
 667               	.L59:
 668               	.LBE43:
  46:ir_array.h    **** 	putCh(IR_ARR_VAL);
 669               		.loc 4 46 0 discriminator 28
 670 02f0 892B      		or r24,r25
 671 02f2 0E94 0000 		call putCh
 672               	.LVL44:
 673               	.LBB44:
 674               	.LBB45:
 675               		.file 5 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/avr/include/util/delay.h **** #  endif
  42:/usr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/avr/include/util/delay.h **** 
  44:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/avr/include/util/delay.h **** #include <math.h>
  47:/usr/avr/include/util/delay.h **** 
  48:/usr/avr/include/util/delay.h **** /** \file */
  49:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/avr/include/util/delay.h ****     \code
  51:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/avr/include/util/delay.h ****     \endcode
  55:/usr/avr/include/util/delay.h **** 
  56:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/avr/include/util/delay.h ****     used.
  60:/usr/avr/include/util/delay.h **** 
  61:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/avr/include/util/delay.h **** 
  70:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/avr/include/util/delay.h **** 
  79:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** */
  84:/usr/avr/include/util/delay.h **** 
  85:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/avr/include/util/delay.h **** #endif
  89:/usr/avr/include/util/delay.h **** 
  90:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/avr/include/util/delay.h **** 
  97:/usr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/avr/include/util/delay.h **** 
 103:/usr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/avr/include/util/delay.h ****     integer value.
 107:/usr/avr/include/util/delay.h ****  */
 108:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/avr/include/util/delay.h **** #endif
 110:/usr/avr/include/util/delay.h **** 
 111:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/avr/include/util/delay.h **** #endif
 114:/usr/avr/include/util/delay.h **** 
 115:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/avr/include/util/delay.h **** #endif
 120:/usr/avr/include/util/delay.h **** 
 121:/usr/avr/include/util/delay.h **** /**
 122:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/avr/include/util/delay.h **** 
 124:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/avr/include/util/delay.h **** 
 126:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/avr/include/util/delay.h **** 
 131:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/avr/include/util/delay.h **** 
 137:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/avr/include/util/delay.h **** 
 142:/usr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/avr/include/util/delay.h **** 
 147:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/avr/include/util/delay.h ****    respectively.
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h ****    \note
 153:/usr/avr/include/util/delay.h **** 
 154:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h ****  */
 165:/usr/avr/include/util/delay.h **** void
 166:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/avr/include/util/delay.h **** {
 168:/usr/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/avr/include/util/delay.h **** 
 176:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/avr/include/util/delay.h **** 
 179:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/avr/include/util/delay.h **** 
 182:/usr/avr/include/util/delay.h **** 	#else
 183:/usr/avr/include/util/delay.h **** 		//round up by default
 184:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/avr/include/util/delay.h **** 	#endif
 186:/usr/avr/include/util/delay.h **** 
 187:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 676               		.loc 5 187 0 is_stmt 1 discriminator 28
 677 02f6 2FEF      		ldi r18,lo8(319999)
 678 02f8 81EE      		ldi r24,hi8(319999)
 679 02fa 94E0      		ldi r25,hlo8(319999)
 680 02fc 2150      	1:	subi r18,1
 681 02fe 8040      		sbci r24,0
 682 0300 9040      		sbci r25,0
 683 0302 01F4      		brne 1b
 684 0304 00C0      		rjmp .
 685 0306 0000      		nop
 686               	.LVL45:
 687               	.LBE45:
 688               	.LBE44:
  48:ir_array.h    **** 	if(width == 0 || width >= 8){
 689               		.loc 4 48 0 discriminator 28
 690 0308 8091 0000 		lds r24,width
 691 030c 8150      		subi r24,lo8(-(-1))
 692 030e 8730      		cpi r24,lo8(7)
 693 0310 00F0      		brlo .L60
  49:ir_array.h    **** 		controlMotor(STOP);
 694               		.loc 4 49 0
 695 0312 84E0      		ldi r24,lo8(4)
 696               	.L79:
  52:ir_array.h    **** 		controlMotor(FORWARD);
 697               		.loc 4 52 0
 698 0314 0E94 0000 		call controlMotor
 699               	.LVL46:
  55:ir_array.h    **** 	uint8_t size = lineSize();
 700               		.loc 4 55 0
 701 0318 0E94 0000 		call lineSize
 702               	.LVL47:
  57:ir_array.h    **** 	if(width == 0 && size != 0){
 703               		.loc 4 57 0
 704 031c 9091 0000 		lds r25,width
 705 0320 9111      		cpse r25,__zero_reg__
 706 0322 00C0      		rjmp .L62
  57:ir_array.h    **** 	if(width == 0 && size != 0){
 707               		.loc 4 57 0 is_stmt 0 discriminator 1
 708 0324 8823      		tst r24
 709 0326 01F0      		breq .L63
  58:ir_array.h    **** 		width = size;
 710               		.loc 4 58 0 is_stmt 1
 711 0328 8093 0000 		sts width,r24
 712               	.L64:
  63:ir_array.h    **** 	if(count >= 255){
 713               		.loc 4 63 0
 714 032c 4091 0000 		lds r20,count
 715 0330 5091 0000 		lds r21,count+1
 716 0334 6091 0000 		lds r22,count+2
 717 0338 7091 0000 		lds r23,count+3
 718 033c 4F3F      		cpi r20,-1
 719 033e 5105      		cpc r21,__zero_reg__
 720 0340 6105      		cpc r22,__zero_reg__
 721 0342 7105      		cpc r23,__zero_reg__
 722 0344 00F0      		brlo .L52
  66:ir_array.h    **** 		if(width % 2 != 0)
 723               		.loc 4 66 0
 724 0346 80FD      		sbrc r24,0
 725 0348 00C0      		rjmp .L67
 726               	.LVL48:
 727               	.L80:
  67:ir_array.h    **** 			width --;
 728               		.loc 4 67 0
 729 034a 8093 0000 		sts width,r24
 730               	.L52:
 731               	/* epilogue start */
  69:ir_array.h    **** }
 732               		.loc 4 69 0
 733 034e 0895      		ret
 734               	.LVL49:
 735               	.L69:
 736               	.LBB46:
  46:ir_array.h    **** 	putCh(IR_ARR_VAL);
 737               		.loc 4 46 0
 738 0350 82E0      		ldi r24,lo8(2)
 739 0352 00C0      		rjmp .L53
 740               	.L70:
 741               	.LBE46:
 742               	.LBB47:
 743 0354 94E0      		ldi r25,lo8(4)
 744               	.LVL50:
 745 0356 00C0      		rjmp .L54
 746               	.LVL51:
 747               	.L71:
 748               	.LBE47:
 749               	.LBB48:
 750 0358 98E0      		ldi r25,lo8(8)
 751               	.LVL52:
 752 035a 00C0      		rjmp .L55
 753               	.LVL53:
 754               	.L72:
 755               	.LBE48:
 756               	.LBB49:
 757 035c 90E1      		ldi r25,lo8(16)
 758               	.LVL54:
 759 035e 00C0      		rjmp .L56
 760               	.LVL55:
 761               	.L73:
 762               	.LBE49:
 763               	.LBB50:
 764 0360 90E2      		ldi r25,lo8(32)
 765               	.LVL56:
 766 0362 00C0      		rjmp .L57
 767               	.LVL57:
 768               	.L74:
 769               	.LBE50:
 770               	.LBB51:
 771 0364 90E4      		ldi r25,lo8(64)
 772               	.LVL58:
 773 0366 00C0      		rjmp .L58
 774               	.LVL59:
 775               	.L75:
 776               	.LBE51:
 777               	.LBB52:
 778 0368 90E8      		ldi r25,lo8(-128)
 779               	.LVL60:
 780 036a 00C0      		rjmp .L59
 781               	.L60:
 782               	.LBE52:
  52:ir_array.h    **** 		controlMotor(FORWARD);
 783               		.loc 4 52 0
 784 036c 80E0      		ldi r24,0
 785 036e 00C0      		rjmp .L79
 786               	.LVL61:
 787               	.L62:
  59:ir_array.h    **** 	}else if(width == size){
 788               		.loc 4 59 0
 789 0370 9813      		cpse r25,r24
 790 0372 00C0      		rjmp .L64
 791               	.L63:
  60:ir_array.h    **** 		count++;
 792               		.loc 4 60 0
 793 0374 4091 0000 		lds r20,count
 794 0378 5091 0000 		lds r21,count+1
 795 037c 6091 0000 		lds r22,count+2
 796 0380 7091 0000 		lds r23,count+3
 797 0384 4F5F      		subi r20,-1
 798 0386 5F4F      		sbci r21,-1
 799 0388 6F4F      		sbci r22,-1
 800 038a 7F4F      		sbci r23,-1
 801 038c 4093 0000 		sts count,r20
 802 0390 5093 0000 		sts count+1,r21
 803 0394 6093 0000 		sts count+2,r22
 804 0398 7093 0000 		sts count+3,r23
 805 039c 00C0      		rjmp .L64
 806               	.L67:
  67:ir_array.h    **** 			width --;
 807               		.loc 4 67 0
 808 039e 8150      		subi r24,lo8(-(-1))
 809               	.LVL62:
 810 03a0 00C0      		rjmp .L80
 811               		.cfi_endproc
 812               	.LFE14:
 814               		.section	.text.startup,"ax",@progbits
 815               	.global	main
 817               	main:
 818               	.LFB16:
 819               		.file 6 "main.c"
   1:main.c        **** #define F_CPU 16000000UL
   2:main.c        **** 
   3:main.c        **** //Comment the MCU which you're not using.
   4:main.c        **** #define ATMEGA_328P
   5:main.c        **** //#define ATMEGA_32A
   6:main.c        **** 
   7:main.c        **** #include <avr/io.h>
   8:main.c        **** #include <util/delay.h>
   9:main.c        **** #include "ir_array.h"
  10:main.c        **** 
  11:main.c        **** int main(void){
 820               		.loc 6 11 0
 821               		.cfi_startproc
 822               	/* prologue: function */
 823               	/* frame size = 0 */
 824               	/* stack size = 0 */
 825               	.L__stack_usage = 0
  12:main.c        **** 
  13:main.c        **** 	setupPWM();
 826               		.loc 6 13 0
 827 0000 0E94 0000 		call setupPWM
 828               	.LVL63:
  14:main.c        **** 	setupMotor();
 829               		.loc 6 14 0
 830 0004 0E94 0000 		call setupMotor
 831               	.LVL64:
  15:main.c        **** 	initIR();
 832               		.loc 6 15 0
 833 0008 0E94 0000 		call initIR
 834               	.LVL65:
 835               	.L82:
  16:main.c        **** 
  17:main.c        **** 	while(1){
  18:main.c        **** 		stableCar();
 836               		.loc 6 18 0 discriminator 1
 837 000c 0E94 0000 		call stableCar
 838               	.LVL66:
 839 0010 00C0      		rjmp .L82
 840               		.cfi_endproc
 841               	.LFE16:
 843               	.global	count
 844               		.section .bss
 847               	count:
 848 0000 0000 0000 		.zero	4
 849               	.global	width
 852               	width:
 853 0004 00        		.zero	1
 854               	.global	right_status
 857               	right_status:
 858 0005 00        		.zero	1
 859               	.global	left_status
 862               	left_status:
 863 0006 00        		.zero	1
 864               	.global	channelB_status
 867               	channelB_status:
 868 0007 00        		.zero	1
 869               	.global	channelA_status
 872               	channelA_status:
 873 0008 00        		.zero	1
 874               	.global	channelB
 877               	channelB:
 878 0009 0000      		.zero	2
 879               	.global	channelA
 882               	channelA:
 883 000b 0000      		.zero	2
 884               		.text
 885               	.Letext0:
 886               		.file 7 "/usr/avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccNbSYQY.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccNbSYQY.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccNbSYQY.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccNbSYQY.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccNbSYQY.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccNbSYQY.s:12     .text:0000000000000000 setupPWM
     /tmp/ccNbSYQY.s:39     .text:0000000000000014 pwm
     /tmp/ccNbSYQY.s:70     .text:0000000000000034 controlMotor
     /tmp/ccNbSYQY.s:882    .bss:000000000000000b channelA
     /tmp/ccNbSYQY.s:877    .bss:0000000000000009 channelB
     /tmp/ccNbSYQY.s:867    .bss:0000000000000007 channelB_status
     /tmp/ccNbSYQY.s:862    .bss:0000000000000006 left_status
     /tmp/ccNbSYQY.s:857    .bss:0000000000000005 right_status
     /tmp/ccNbSYQY.s:872    .bss:0000000000000008 channelA_status
     /tmp/ccNbSYQY.s:377    .text:000000000000022c setupMotor
     /tmp/ccNbSYQY.s:424    .text:0000000000000256 initUSART
     /tmp/ccNbSYQY.s:456    .text:0000000000000272 getCh
     /tmp/ccNbSYQY.s:479    .text:0000000000000280 putCh
     /tmp/ccNbSYQY.s:503    .text:000000000000028e initIR
     /tmp/ccNbSYQY.s:527    .text:000000000000029e lineSize
     /tmp/ccNbSYQY.s:585    .text:00000000000002b2 stableCar
     /tmp/ccNbSYQY.s:852    .bss:0000000000000004 width
     /tmp/ccNbSYQY.s:847    .bss:0000000000000000 count
     /tmp/ccNbSYQY.s:817    .text.startup:0000000000000000 main

UNDEFINED SYMBOLS
__do_clear_bss

   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	setupPWM
  12               	setupPWM:
  13               	.LFB6:
  14               		.file 1 "pwm.h"
   1:pwm.h         **** #include <avr/io.h>
   2:pwm.h         **** #include "cpu_def.h"
   3:pwm.h         **** 
   4:pwm.h         **** //Define PWM Channels
   5:pwm.h         **** #define CH_A 0
   6:pwm.h         **** #define CH_B 1
   7:pwm.h         **** 
   8:pwm.h         **** void setupPWM(void);
   9:pwm.h         **** void pwm(uint8_t channel, uint16_t onTime, uint16_t period);
  10:pwm.h         **** 
  11:pwm.h         **** //Initializing PWM
  12:pwm.h         **** void setupPWM(void){
  15               		.loc 1 12 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  13:pwm.h         **** 	OC1x_DDR |= (1 << OC1A_PIN) | (1 << OC1B_PIN);
  21               		.loc 1 13 0
  22 0000 84B1      		in r24,0x4
  23 0002 8660      		ori r24,lo8(6)
  24 0004 84B9      		out 0x4,r24
  14:pwm.h         **** 	TCCR1A = (1 << COM1A1) | (1 << COM1B1) | (1 << WGM11);	
  25               		.loc 1 14 0
  26 0006 82EA      		ldi r24,lo8(-94)
  27 0008 8093 8000 		sts 128,r24
  15:pwm.h         **** 	TCCR1B = (1 << WGM13) | (1 << WGM12) | (1 << CS11);
  28               		.loc 1 15 0
  29 000c 8AE1      		ldi r24,lo8(26)
  30 000e 8093 8100 		sts 129,r24
  31               	/* epilogue start */
  16:pwm.h         **** }
  32               		.loc 1 16 0
  33 0012 0895      		ret
  34               		.cfi_endproc
  35               	.LFE6:
  37               	.global	pwm
  39               	pwm:
  40               	.LFB7:
  17:pwm.h         **** 
  18:pwm.h         **** //Set PWM of the selected channel
  19:pwm.h         **** void pwm(uint8_t channel, uint16_t onTime, uint16_t period){
  41               		.loc 1 19 0
  42               		.cfi_startproc
  43               	.LVL0:
  44               	/* prologue: function */
  45               	/* frame size = 0 */
  46               	/* stack size = 0 */
  47               	.L__stack_usage = 0
  20:pwm.h         **** 	ICR1 = period;
  48               		.loc 1 20 0
  49 0014 5093 8700 		sts 134+1,r21
  50 0018 4093 8600 		sts 134,r20
  21:pwm.h         **** 	(channel == CH_B) ? (OCR1B = onTime) : (OCR1A = onTime);
  51               		.loc 1 21 0
  52 001c 8130      		cpi r24,lo8(1)
  53 001e 01F4      		brne .L3
  54               		.loc 1 21 0 is_stmt 0 discriminator 1
  55 0020 7093 8B00 		sts 138+1,r23
  56 0024 6093 8A00 		sts 138,r22
  57 0028 0895      		ret
  58               	.L3:
  59               		.loc 1 21 0 discriminator 2
  60 002a 7093 8900 		sts 136+1,r23
  61 002e 6093 8800 		sts 136,r22
  62               	/* epilogue start */
  22:pwm.h         **** }...
  63               		.loc 1 22 0 is_stmt 1 discriminator 2
  64 0032 0895      		ret
  65               		.cfi_endproc
  66               	.LFE7:
  68               	.global	initUSART
  70               	initUSART:
  71               	.LFB8:
  72               		.file 2 "serial.h"
   1:serial.h      **** #define BAUD_RATE 9600
   2:serial.h      **** 
   3:serial.h      **** #include <avr/io.h>
   4:serial.h      **** #include "cpu_def.h"
   5:serial.h      **** 
   6:serial.h      **** void initUSART(void);
   7:serial.h      **** uint8_t getCh(void);
   8:serial.h      **** void putCh(uint8_t data);
   9:serial.h      **** 
  10:serial.h      **** void initUSART(void){
  73               		.loc 2 10 0
  74               		.cfi_startproc
  75               	/* prologue: function */
  76               	/* frame size = 0 */
  77               	/* stack size = 0 */
  78               	.L__stack_usage = 0
  79               	.LVL1:
  11:serial.h      ****    //Set Baud rate; ubrr_value = F_OSC/(16 x Baud_rate) - 1; e.g. 16e6/(9600*16) -1 = 103
  12:serial.h      **** 	uint32_t ubrr_value;
  13:serial.h      **** 	ubrr_value = F_CPU/16/BAUD_RATE -1; 
  14:serial.h      **** 	UBRRL_REG = ubrr_value;
  80               		.loc 2 14 0
  81 0034 87E6      		ldi r24,lo8(103)
  82 0036 8093 C400 		sts 196,r24
  15:serial.h      **** 	UBRRH_REG = (ubrr_value >> 8);
  83               		.loc 2 15 0
  84 003a 1092 C500 		sts 197,__zero_reg__
  16:serial.h      **** 	UCSRC_REG |= (1 << UCSZ1_BIT) | (1 << UCSZ0_BIT);
  85               		.loc 2 16 0
  86 003e E2EC      		ldi r30,lo8(-62)
  87 0040 F0E0      		ldi r31,0
  88 0042 8081      		ld r24,Z
  89 0044 8660      		ori r24,lo8(6)
  90 0046 8083      		st Z,r24
  17:serial.h      **** 
  18:serial.h      **** 	#ifdef ATMEGA_32A
  19:serial.h      **** 	UCSRC_REG |= (1 << URSEL_BIT);
  20:serial.h      **** 	#endif
  21:serial.h      **** 
  22:serial.h      **** 	//Enable The receiver and transmitter
  23:serial.h      **** 	UCSRB_REG = (1 << RXEN_BIT) | (1 << TXEN_BIT);
  91               		.loc 2 23 0
  92 0048 88E1      		ldi r24,lo8(24)
  93 004a 8093 C100 		sts 193,r24
  94               	/* epilogue start */
  24:serial.h      **** }
  95               		.loc 2 24 0
  96 004e 0895      		ret
  97               		.cfi_endproc
  98               	.LFE8:
 100               	.global	getCh
 102               	getCh:
 103               	.LFB9:
  25:serial.h      **** 
  26:serial.h      **** uint8_t getCh(void){
 104               		.loc 2 26 0
 105               		.cfi_startproc
 106               	/* prologue: function */
 107               	/* frame size = 0 */
 108               	/* stack size = 0 */
 109               	.L__stack_usage = 0
 110               	.L7:
  27:serial.h      **** 	while(!(UCSRA_REG & (1 << RXC_BIT)));
 111               		.loc 2 27 0 discriminator 1
 112 0050 8091 C000 		lds r24,192
 113 0054 87FF      		sbrs r24,7
 114 0056 00C0      		rjmp .L7
  28:serial.h      **** 	return UDR_REG;
 115               		.loc 2 28 0
 116 0058 8091 C600 		lds r24,198
 117               	/* epilogue start */
  29:serial.h      **** }
 118               		.loc 2 29 0
 119 005c 0895      		ret
 120               		.cfi_endproc
 121               	.LFE9:
 123               	.global	putCh
 125               	putCh:
 126               	.LFB10:
  30:serial.h      **** 
  31:serial.h      **** void putCh(uint8_t data){
 127               		.loc 2 31 0
 128               		.cfi_startproc
 129               	/* prologue: function */
 130               	/* frame size = 0 */
 131               	/* stack size = 0 */
 132               	.L__stack_usage = 0
 133               	.LVL2:
 134               	.L10:
  32:serial.h      **** 	while(!(UCSRA_REG & (1 << UDRE_BIT)));
 135               		.loc 2 32 0 discriminator 1
 136 005e 9091 C000 		lds r25,192
 137 0062 95FF      		sbrs r25,5
 138 0064 00C0      		rjmp .L10
  33:serial.h      **** 	UDR_REG = data;
 139               		.loc 2 33 0
 140 0066 8093 C600 		sts 198,r24
 141               	/* epilogue start */
  34:serial.h      **** }...
 142               		.loc 2 34 0
 143 006a 0895      		ret
 144               		.cfi_endproc
 145               	.LFE10:
 147               	.global	initIR
 149               	initIR:
 150               	.LFB11:
 151               		.file 3 "ir_array.h"
   1:ir_array.h    **** #define IR_LEFT_DDR DDRD
   2:ir_array.h    **** #define IR_LEFT_PIN PIND
   3:ir_array.h    **** 
   4:ir_array.h    **** #define IR_L_01 PD4
   5:ir_array.h    **** #define IR_L_02 PD5
   6:ir_array.h    **** #define IR_L_03 PD6
   7:ir_array.h    **** #define IR_L_04 PD7
   8:ir_array.h    **** 
   9:ir_array.h    **** #define IR_RIGHT_DDR DDRB
  10:ir_array.h    **** #define IR_RIGHT_PIN PINB
  11:ir_array.h    **** 
  12:ir_array.h    **** #define IR_R_05 PB5
  13:ir_array.h    **** #define IR_R_06 PB3
  14:ir_array.h    **** #define IR_R_07 PB4
  15:ir_array.h    **** #define IR_R_08 PB0
  16:ir_array.h    **** 
  17:ir_array.h    **** #define IR01_VAL() ({ uint8_t retVal = (IR_LEFT_PIN & (1 << IR_L_01)) ? (1 << 0) : 0; retVal;})
  18:ir_array.h    **** #define IR02_VAL() ({uint8_t retVal = (IR_LEFT_PIN & (1 << IR_L_02)) ? (1 << 1) : 0; retVal;})
  19:ir_array.h    **** #define IR03_VAL() ({uint8_t retVal = (IR_LEFT_PIN & (1 << IR_L_03)) ? (1 << 2) : 0; retVal;})
  20:ir_array.h    **** #define IR04_VAL() ({uint8_t retVal = (IR_LEFT_PIN & (1 << IR_L_04)) ? (1 << 3) : 0; retVal;})
  21:ir_array.h    **** #define IR05_VAL() ({uint8_t retVal = (IR_RIGHT_PIN & (1 << IR_R_05)) ? (1 << 4) : 0; retVal;})
  22:ir_array.h    **** #define IR06_VAL() ({uint8_t retVal = (IR_RIGHT_PIN & (1 << IR_R_06)) ? (1 << 5) : 0; retVal;})
  23:ir_array.h    **** #define IR07_VAL() ({uint8_t retVal = (IR_RIGHT_PIN & (1 << IR_R_07)) ? (1 << 6) : 0; retVal;})
  24:ir_array.h    **** #define IR08_VAL() ({uint8_t retVal = (IR_RIGHT_PIN & (1 << IR_R_08)) ? (1 << 7) : 0; retVal;})
  25:ir_array.h    **** 
  26:ir_array.h    **** #define IR_ARR_VAL IR01_VAL() | IR02_VAL() | IR03_VAL() | IR04_VAL() | IR05_VAL() | IR06_VAL() | IR
  27:ir_array.h    **** 
  28:ir_array.h    **** #define IR_POSITION IR01_VAL() * 0 | IR02_VAL() * 1000 | IR03_VAL() * 2000 | IR04_VAL() * 3000 | IR
  29:ir_array.h    **** 
  30:ir_array.h    **** #define SETUP_IR() {IR_LEFT_DDR &= ~((1 << IR_L_01) | (1 << IR_L_02) | (1 << IR_L_03) | (1 << IR_L_
  31:ir_array.h    **** 
  32:ir_array.h    **** #include "serial.h"
  33:ir_array.h    **** 
  34:ir_array.h    **** uint8_t width = 0;
  35:ir_array.h    **** 
  36:ir_array.h    **** void initIR(void);
  37:ir_array.h    **** void stableCar(void);
  38:ir_array.h    **** uint8_t lineSize(void);
  39:ir_array.h    **** int getPosition(void);
  40:ir_array.h    ****  
  41:ir_array.h    **** void initIR(void){
 152               		.loc 3 41 0
 153               		.cfi_startproc
 154               	/* prologue: function */
 155               	/* frame size = 0 */
 156               	/* stack size = 0 */
 157               	.L__stack_usage = 0
  42:ir_array.h    **** 	SETUP_IR();
 158               		.loc 3 42 0
 159 006c 8AB1      		in r24,0xa
 160 006e 8F70      		andi r24,lo8(15)
 161 0070 8AB9      		out 0xa,r24
 162 0072 84B1      		in r24,0x4
 163 0074 867C      		andi r24,lo8(-58)
 164 0076 84B9      		out 0x4,r24
  43:ir_array.h    **** 	initUSART();
 165               		.loc 3 43 0
 166 0078 0C94 0000 		jmp initUSART
 167               	.LVL3:
 168               		.cfi_endproc
 169               	.LFE11:
 171               	.global	getPosition
 173               	getPosition:
 174               	.LFB12:
  44:ir_array.h    **** }
  45:ir_array.h    **** 
  46:ir_array.h    **** int getPosition(void){
 175               		.loc 3 46 0
 176               		.cfi_startproc
 177               	/* prologue: function */
 178               	/* frame size = 0 */
 179               	/* stack size = 0 */
 180               	.L__stack_usage = 0
 181               	.LBB64:
  47:ir_array.h    **** 	int position = IR_POSITION / 2;
 182               		.loc 3 47 0
 183 007c 89B1      		in r24,0x9
 184               	.LVL4:
 185               	.LBE64:
 186               	.LBB65:
 187 007e 4D99      		sbic 0x9,5
 188 0080 00C0      		rjmp .L24
 189 0082 90E0      		ldi r25,0
 190               	.L15:
 191               	.LVL5:
 192               	.LBE65:
 193               		.loc 3 47 0 is_stmt 0 discriminator 4
 194 0084 28EE      		ldi r18,lo8(-24)
 195 0086 33E0      		ldi r19,lo8(3)
 196 0088 929F      		mul r25,r18
 197 008a A001      		movw r20,r0
 198 008c 939F      		mul r25,r19
 199 008e 500D      		add r21,r0
 200 0090 1124      		clr __zero_reg__
 201               	.LBB66:
 202 0092 4E99      		sbic 0x9,6
 203 0094 00C0      		rjmp .L25
 204               		.loc 3 47 0
 205 0096 30E0      		ldi r19,0
 206               	.L16:
 207               	.LVL6:
 208               	.LBE66:
 209               		.loc 3 47 0 discriminator 8
 210 0098 60ED      		ldi r22,lo8(-48)
 211 009a 77E0      		ldi r23,lo8(7)
 212 009c 369F      		mul r19,r22
 213 009e C001      		movw r24,r0
 214 00a0 379F      		mul r19,r23
 215 00a2 900D      		add r25,r0
 216 00a4 1124      		clr __zero_reg__
 217 00a6 9C01      		movw r18,r24
 218 00a8 242B      		or r18,r20
 219 00aa 352B      		or r19,r21
 220               	.LVL7:
 221               	.LBB67:
 222 00ac 4F99      		sbic 0x9,7
 223 00ae 00C0      		rjmp .L26
 224               		.loc 3 47 0
 225 00b0 40E0      		ldi r20,0
 226               	.L17:
 227               	.LVL8:
 228               	.LBE67:
 229               		.loc 3 47 0 discriminator 12
 230 00b2 68EB      		ldi r22,lo8(-72)
 231 00b4 7BE0      		ldi r23,lo8(11)
 232 00b6 469F      		mul r20,r22
 233 00b8 C001      		movw r24,r0
 234 00ba 479F      		mul r20,r23
 235 00bc 900D      		add r25,r0
 236 00be 1124      		clr __zero_reg__
 237 00c0 822B      		or r24,r18
 238 00c2 932B      		or r25,r19
 239               	.LVL9:
 240               	.LBB68:
 241 00c4 1D99      		sbic 0x3,5
 242 00c6 00C0      		rjmp .L27
 243               		.loc 3 47 0
 244 00c8 40E0      		ldi r20,0
 245               	.LVL10:
 246               	.L18:
 247               	.LBE68:
 248               		.loc 3 47 0 discriminator 16
 249 00ca 60EA      		ldi r22,lo8(-96)
 250 00cc 7FE0      		ldi r23,lo8(15)
 251 00ce 469F      		mul r20,r22
 252 00d0 9001      		movw r18,r0
 253 00d2 479F      		mul r20,r23
 254 00d4 300D      		add r19,r0
 255 00d6 1124      		clr __zero_reg__
 256 00d8 822B      		or r24,r18
 257 00da 932B      		or r25,r19
 258               	.LBB69:
 259 00dc 1B99      		sbic 0x3,3
 260 00de 00C0      		rjmp .L28
 261               		.loc 3 47 0
 262 00e0 40E0      		ldi r20,0
 263               	.LVL11:
 264               	.L19:
 265               	.LBE69:
 266               		.loc 3 47 0 discriminator 20
 267 00e2 68E8      		ldi r22,lo8(-120)
 268 00e4 73E1      		ldi r23,lo8(19)
 269 00e6 469F      		mul r20,r22
 270 00e8 9001      		movw r18,r0
 271 00ea 479F      		mul r20,r23
 272 00ec 300D      		add r19,r0
 273 00ee 1124      		clr __zero_reg__
 274 00f0 282B      		or r18,r24
 275 00f2 392B      		or r19,r25
 276               	.LBB70:
 277 00f4 1C99      		sbic 0x3,4
 278 00f6 00C0      		rjmp .L29
 279               		.loc 3 47 0
 280 00f8 40E0      		ldi r20,0
 281               	.LVL12:
 282               	.L20:
 283               	.LBE70:
 284               		.loc 3 47 0 discriminator 24
 285 00fa 60E7      		ldi r22,lo8(112)
 286 00fc 77E1      		ldi r23,lo8(23)
 287 00fe 469F      		mul r20,r22
 288 0100 C001      		movw r24,r0
 289 0102 479F      		mul r20,r23
 290 0104 900D      		add r25,r0
 291 0106 1124      		clr __zero_reg__
 292 0108 282B      		or r18,r24
 293 010a 392B      		or r19,r25
 294               	.LBB71:
 295 010c 1899      		sbic 0x3,0
 296 010e 00C0      		rjmp .L30
 297               		.loc 3 47 0
 298 0110 40E0      		ldi r20,0
 299               	.LVL13:
 300               	.L21:
 301               	.LBE71:
 302               		.loc 3 47 0 discriminator 28
 303 0112 6CEA      		ldi r22,lo8(-84)
 304 0114 7DE0      		ldi r23,lo8(13)
 305 0116 469F      		mul r20,r22
 306 0118 C001      		movw r24,r0
 307 011a 479F      		mul r20,r23
 308 011c 900D      		add r25,r0
 309 011e 1124      		clr __zero_reg__
 310 0120 822B      		or r24,r18
 311 0122 932B      		or r25,r19
 312               	.LVL14:
  48:ir_array.h    **** 
  49:ir_array.h    **** 	if(position > 7000){
 313               		.loc 3 49 0 is_stmt 1 discriminator 28
 314 0124 8935      		cpi r24,89
 315 0126 2BE1      		ldi r18,27
 316 0128 9207      		cpc r25,r18
 317 012a 04F0      		brlt .L14
 318               	.L23:
  50:ir_array.h    **** 		while(position >= 7000){
  51:ir_array.h    **** 			position /= 2;
 319               		.loc 3 51 0
 320 012c 9595      		asr r25
 321 012e 8795      		ror r24
 322               	.LVL15:
  50:ir_array.h    **** 		while(position >= 7000){
 323               		.loc 3 50 0
 324 0130 8835      		cpi r24,88
 325 0132 2BE1      		ldi r18,27
 326 0134 9207      		cpc r25,r18
 327 0136 04F4      		brge .L23
 328               	.L14:
 329               	/* epilogue start */
  52:ir_array.h    **** 		}
  53:ir_array.h    **** 	}
  54:ir_array.h    **** 
  55:ir_array.h    **** 	return position;
  56:ir_array.h    **** 
  57:ir_array.h    **** }
 330               		.loc 3 57 0
 331 0138 0895      		ret
 332               	.LVL16:
 333               	.L24:
 334               	.LBB72:
  47:ir_array.h    **** 
 335               		.loc 3 47 0
 336 013a 92E0      		ldi r25,lo8(2)
 337 013c 00C0      		rjmp .L15
 338               	.LVL17:
 339               	.L25:
 340               	.LBE72:
 341               	.LBB73:
 342 013e 34E0      		ldi r19,lo8(4)
 343 0140 00C0      		rjmp .L16
 344               	.L26:
 345               	.LBE73:
 346               	.LBB74:
 347 0142 48E0      		ldi r20,lo8(8)
 348 0144 00C0      		rjmp .L17
 349               	.LVL18:
 350               	.L27:
 351               	.LBE74:
 352               	.LBB75:
 353 0146 40E1      		ldi r20,lo8(16)
 354               	.LVL19:
 355 0148 00C0      		rjmp .L18
 356               	.LVL20:
 357               	.L28:
 358               	.LBE75:
 359               	.LBB76:
 360 014a 40E2      		ldi r20,lo8(32)
 361               	.LVL21:
 362 014c 00C0      		rjmp .L19
 363               	.LVL22:
 364               	.L29:
 365               	.LBE76:
 366               	.LBB77:
 367 014e 40E4      		ldi r20,lo8(64)
 368               	.LVL23:
 369 0150 00C0      		rjmp .L20
 370               	.LVL24:
 371               	.L30:
 372               	.LBE77:
 373               	.LBB78:
 374 0152 40E8      		ldi r20,lo8(-128)
 375               	.LVL25:
 376 0154 00C0      		rjmp .L21
 377               	.LBE78:
 378               		.cfi_endproc
 379               	.LFE12:
 381               	.global	getError
 383               	getError:
 384               	.LFB13:
  58:ir_array.h    **** 
  59:ir_array.h    **** int getError(){
 385               		.loc 3 59 0
 386               		.cfi_startproc
 387               	/* prologue: function */
 388               	/* frame size = 0 */
 389               	/* stack size = 0 */
 390               	.L__stack_usage = 0
  60:ir_array.h    **** 
  61:ir_array.h    **** 	return 3500 - getPosition();
 391               		.loc 3 61 0
 392 0156 0E94 0000 		call getPosition
 393               	.LVL26:
  62:ir_array.h    **** 	/*if(~IR01_VAL() && ~IR02_VAL() && ~IR03_VAL() && ~IR04_VAL() && ~IR05_VAL() && ~IR06_VAL() && ~IR
  63:ir_array.h    **** 
  64:ir_array.h    **** 	if(~IR01_VAL() && ~IR02_VAL() && ~IR03_VAL() && ~IR04_VAL() && ~IR05_VAL() && ~IR06_VAL() && IR07_
  65:ir_array.h    **** 
  66:ir_array.h    **** 	if(~IR01_VAL() && ~IR02_VAL() && ~IR03_VAL() && ~IR04_VAL() && ~IR05_VAL() && ~IR06_VAL() && IR07_
  67:ir_array.h    **** 
  68:ir_array.h    **** 	if(~IR01_VAL() && ~IR02_VAL() && ~IR03_VAL() && ~IR04_VAL() && ~IR05_VAL() && IR06_VAL() && IR07_V
  69:ir_array.h    **** 
  70:ir_array.h    **** 	if(~IR01_VAL() && ~IR02_VAL() && ~IR03_VAL() && ~IR04_VAL() && ~IR05_VAL() && IR06_VAL() && ~IR07_
  71:ir_array.h    **** 
  72:ir_array.h    **** 	if(~IR01_VAL() && ~IR02_VAL() && ~IR03_VAL() && ~IR04_VAL() && IR05_VAL() && IR06_VAL() && ~IR07_V
  73:ir_array.h    **** 
  74:ir_array.h    **** 	if(~IR01_VAL() && ~IR02_VAL() && ~IR03_VAL() && ~IR04_VAL() && IR05_VAL() && ~IR06_VAL() && ~IR07_
  75:ir_array.h    **** 
  76:ir_array.h    **** 	if(~IR01_VAL() && ~IR02_VAL() && ~IR03_VAL() && IR04_VAL() && IR05_VAL() && ~IR06_VAL() && ~IR07_V
  77:ir_array.h    **** 
  78:ir_array.h    **** 	if(~IR01_VAL() && ~IR02_VAL() && ~IR03_VAL() && IR04_VAL() && ~IR05_VAL() && ~IR06_VAL() && ~IR07_
  79:ir_array.h    **** 
  80:ir_array.h    **** 	if(~IR01_VAL() && ~IR02_VAL() && IR03_VAL() && IR04_VAL() && ~IR05_VAL() && ~IR06_VAL() && ~IR07_V
  81:ir_array.h    **** 
  82:ir_array.h    **** 	if(~IR01_VAL() && ~IR02_VAL() && IR03_VAL() && ~IR04_VAL() && ~IR05_VAL() && ~IR06_VAL() && ~IR07_
  83:ir_array.h    **** 
  84:ir_array.h    **** 	if(~IR01_VAL() && IR02_VAL() && IR03_VAL() && ~IR04_VAL() && ~IR05_VAL() && ~IR06_VAL() && ~IR07_V
  85:ir_array.h    **** 
  86:ir_array.h    **** 	if(~IR01_VAL() && IR02_VAL() && ~IR03_VAL() && ~IR04_VAL() && ~IR05_VAL() && ~IR06_VAL() && ~IR07_
  87:ir_array.h    **** 
  88:ir_array.h    **** 	if(IR01_VAL() && IR02_VAL() && ~IR03_VAL() && ~IR04_VAL() && ~IR05_VAL() && ~IR06_VAL() && ~IR07_V
  89:ir_array.h    **** 
  90:ir_array.h    **** 	if(IR01_VAL() && ~IR02_VAL() && ~IR03_VAL() && ~IR04_VAL() && ~IR05_VAL() && ~IR06_VAL() && ~IR07_
  91:ir_array.h    **** 	*/
  92:ir_array.h    **** }
 394               		.loc 3 92 0
 395 015a 2CEA      		ldi r18,lo8(-84)
 396 015c 3DE0      		ldi r19,lo8(13)
 397 015e A901      		movw r20,r18
 398 0160 481B      		sub r20,r24
 399 0162 590B      		sbc r21,r25
 400 0164 CA01      		movw r24,r20
 401               	/* epilogue start */
 402 0166 0895      		ret
 403               		.cfi_endproc
 404               	.LFE13:
 406               	.global	lineSize
 408               	lineSize:
 409               	.LFB14:
  93:ir_array.h    **** 
  94:ir_array.h    **** /*void stableCar(void){
  95:ir_array.h    **** 
  96:ir_array.h    **** 	count++;
  97:ir_array.h    **** 	uint8_t ir_val = IR_ARR_VAL;
  98:ir_array.h    **** 
  99:ir_array.h    **** 	if(count == 200000){
 100:ir_array.h    **** 		putCh(ir_val);
 101:ir_array.h    **** 		count = 0;
 102:ir_array.h    **** 	}
 103:ir_array.h    **** 
 104:ir_array.h    **** 	controlMotor(NEUTRAL);
 105:ir_array.h    **** 	controlMotor(FORWARD);
 106:ir_array.h    **** 
 107:ir_array.h    **** 	if(ir_val == 0x00){
 108:ir_array.h    **** 		controlMotor(STOP);
 109:ir_array.h    **** 	}
 110:ir_array.h    **** 
 111:ir_array.h    **** 	//LEFT
 112:ir_array.h    **** 	if(ir_val == 0x01){
 113:ir_array.h    **** 		controlMotor(LEFT);
 114:ir_array.h    **** 		_delay_ms(100);
 115:ir_array.h    **** 	}
 116:ir_array.h    **** 	
 117:ir_array.h    **** 	if(ir_val == 0x02){
 118:ir_array.h    **** 		controlMotor(LEFT);
 119:ir_array.h    **** 		_delay_ms(10);
 120:ir_array.h    **** 	}
 121:ir_array.h    **** 
 122:ir_array.h    **** 	if(ir_val == 0x04){
 123:ir_array.h    **** 		controlMotor(LEFT);
 124:ir_array.h    **** 		_delay_ms(1);
 125:ir_array.h    **** 	}
 126:ir_array.h    **** 
 127:ir_array.h    **** 	if(ir_val == 0x0F){
 128:ir_array.h    **** 		controlMotor(LEFT);
 129:ir_array.h    **** 		_delay_ms(200);
 130:ir_array.h    **** 	}
 131:ir_array.h    **** 
 132:ir_array.h    **** 	//RIGHT
 133:ir_array.h    **** 	if(ir_val == 0x80){
 134:ir_array.h    **** 		controlMotor(RIGHT);
 135:ir_array.h    **** 		_delay_ms(100);
 136:ir_array.h    **** 	}
 137:ir_array.h    **** 
 138:ir_array.h    **** 	if(ir_val == 0x40){
 139:ir_array.h    **** 		controlMotor(RIGHT);
 140:ir_array.h    **** 		_delay_ms(10);
 141:ir_array.h    **** 	}
 142:ir_array.h    **** 
 143:ir_array.h    **** 	if(ir_val == 0x20){
 144:ir_array.h    **** 		controlMotor(RIGHT);
 145:ir_array.h    **** 		_delay_ms(1);
 146:ir_array.h    **** 	}
 147:ir_array.h    **** 
 148:ir_array.h    **** 	if(ir_val == 0xF0){
 149:ir_array.h    **** 		controlMotor(RIGHT);
 150:ir_array.h    **** 		_delay_ms(200);
 151:ir_array.h    **** 	}
 152:ir_array.h    **** }*/
 153:ir_array.h    **** 
 154:ir_array.h    **** uint8_t lineSize(void){
 410               		.loc 3 154 0
 411               		.cfi_startproc
 412               	/* prologue: function */
 413               	/* frame size = 0 */
 414               	/* stack size = 0 */
 415               	.L__stack_usage = 0
 416               	.LVL27:
 417               	.LBB79:
 155:ir_array.h    **** 	uint8_t size = 0;
 156:ir_array.h    **** 
 157:ir_array.h    **** 	if(~IR01_VAL()) size++;
 418               		.loc 3 157 0
 419 0168 89B1      		in r24,0x9
 420               	.LVL28:
 421               	.LBE79:
 422               	.LBB80:
 158:ir_array.h    **** 	if(~IR02_VAL()) size++;
 423               		.loc 3 158 0
 424 016a 89B1      		in r24,0x9
 425               	.LVL29:
 426               	.LBE80:
 427               	.LBB81:
 159:ir_array.h    **** 	if(~IR03_VAL()) size++;
 428               		.loc 3 159 0
 429 016c 89B1      		in r24,0x9
 430               	.LVL30:
 431               	.LBE81:
 432               	.LBB82:
 160:ir_array.h    **** 	if(~IR04_VAL()) size++;
 433               		.loc 3 160 0
 434 016e 89B1      		in r24,0x9
 435               	.LVL31:
 436               	.LBE82:
 437               	.LBB83:
 161:ir_array.h    **** 	if(~IR05_VAL()) size++;
 438               		.loc 3 161 0
 439 0170 83B1      		in r24,0x3
 440               	.LVL32:
 441               	.LBE83:
 442               	.LBB84:
 162:ir_array.h    **** 	if(~IR06_VAL()) size++;
 443               		.loc 3 162 0
 444 0172 83B1      		in r24,0x3
 445               	.LVL33:
 446               	.LBE84:
 447               	.LBB85:
 163:ir_array.h    **** 	if(~IR07_VAL()) size++;
 448               		.loc 3 163 0
 449 0174 83B1      		in r24,0x3
 450               	.LVL34:
 451               	.LBE85:
 452               	.LBB86:
 164:ir_array.h    **** 	if(~IR08_VAL()) size++;
 453               		.loc 3 164 0
 454 0176 83B1      		in r24,0x3
 455               	.LVL35:
 456               	.LBE86:
 165:ir_array.h    **** 
 166:ir_array.h    **** 	return size;
 167:ir_array.h    **** }...
 457               		.loc 3 167 0
 458 0178 88E0      		ldi r24,lo8(8)
 459               	/* epilogue start */
 460 017a 0895      		ret
 461               		.cfi_endproc
 462               	.LFE14:
 464               	.global	init_SRF05
 466               	init_SRF05:
 467               	.LFB15:
 468               		.file 4 "srf05.h"
   1:srf05.h       **** #ifndef F_CPU
   2:srf05.h       **** #define F_CPU 16000000UL
   3:srf05.h       **** #endif
   4:srf05.h       **** 
   5:srf05.h       **** #include <avr/io.h>
   6:srf05.h       **** #include <avr/interrupt.h>
   7:srf05.h       **** #include <util/delay.h>
   8:srf05.h       **** 
   9:srf05.h       **** #define TRIG 		PD3
  10:srf05.h       **** #define ECHO 		PD2
  11:srf05.h       **** #define SRF05_DDR 	DDRD
  12:srf05.h       **** #define SRF05_PORT 	PORTD
  13:srf05.h       **** #define SRF05_PIN 	PIND
  14:srf05.h       **** 
  15:srf05.h       **** uint16_t distance;
  16:srf05.h       **** 
  17:srf05.h       **** volatile unsigned int mseconds = 0;
  18:srf05.h       **** volatile uint8_t interrupt = 0;
  19:srf05.h       **** 
  20:srf05.h       **** void init_SRF05(void);
  21:srf05.h       **** void SRF05_CalcDistance(void);
  22:srf05.h       **** 
  23:srf05.h       **** void init_SRF05(void){
 469               		.loc 4 23 0
 470               		.cfi_startproc
 471               	/* prologue: function */
 472               	/* frame size = 0 */
 473               	/* stack size = 0 */
 474               	.L__stack_usage = 0
  24:srf05.h       **** 	//CTC mode
  25:srf05.h       **** 	TCCR0A |= (1 << WGM01);
 475               		.loc 4 25 0
 476 017c 84B5      		in r24,0x24
 477 017e 8260      		ori r24,lo8(2)
 478 0180 84BD      		out 0x24,r24
  26:srf05.h       **** 	OCR0A = 19;
 479               		.loc 4 26 0
 480 0182 83E1      		ldi r24,lo8(19)
 481 0184 87BD      		out 0x27,r24
  27:srf05.h       **** 
  28:srf05.h       **** 	//COmpare match interrupt enable
  29:srf05.h       **** 	TIMSK0 |= (1 << OCIE0A);
 482               		.loc 4 29 0
 483 0186 EEE6      		ldi r30,lo8(110)
 484 0188 F0E0      		ldi r31,0
 485 018a 8081      		ld r24,Z
 486 018c 8260      		ori r24,lo8(2)
 487 018e 8083      		st Z,r24
  30:srf05.h       **** 
  31:srf05.h       **** 	//External interrupt enable
  32:srf05.h       **** 	EIMSK |= (1 << INT0);
 488               		.loc 4 32 0
 489 0190 E89A      		sbi 0x1d,0
  33:srf05.h       **** 
  34:srf05.h       **** 	SRF05_DDR |= (1 << TRIG);
 490               		.loc 4 34 0
 491 0192 539A      		sbi 0xa,3
  35:srf05.h       **** 	SRF05_DDR &= ~(1 << ECHO);
 492               		.loc 4 35 0
 493 0194 5298      		cbi 0xa,2
 494               	/* epilogue start */
  36:srf05.h       **** }
 495               		.loc 4 36 0
 496 0196 0895      		ret
 497               		.cfi_endproc
 498               	.LFE15:
 500               	.global	SRF05_Start
 502               	SRF05_Start:
 503               	.LFB16:
  37:srf05.h       **** 
  38:srf05.h       **** void SRF05_Start(void){
 504               		.loc 4 38 0
 505               		.cfi_startproc
 506               	/* prologue: function */
 507               	/* frame size = 0 */
 508               	/* stack size = 0 */
 509               	.L__stack_usage = 0
  39:srf05.h       **** 	
  40:srf05.h       **** 	mseconds = 0;
 510               		.loc 4 40 0
 511 0198 1092 0000 		sts mseconds+1,__zero_reg__
 512 019c 1092 0000 		sts mseconds,__zero_reg__
  41:srf05.h       **** 	TCNT0 = 0; //Reset timer0
 513               		.loc 4 41 0
 514 01a0 16BC      		out 0x26,__zero_reg__
  42:srf05.h       **** 
  43:srf05.h       **** 	//Trigger for 12us
  44:srf05.h       **** 	SRF05_PORT |= (1 << TRIG);
 515               		.loc 4 44 0
 516 01a2 5B9A      		sbi 0xb,3
 517               	.LVL36:
 518               	.LBB87:
 519               	.LBB88:
 520               		.file 5 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/avr/include/util/delay.h **** #  endif
  42:/usr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/avr/include/util/delay.h **** 
  44:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/avr/include/util/delay.h **** #include <math.h>
  47:/usr/avr/include/util/delay.h **** 
  48:/usr/avr/include/util/delay.h **** /** \file */
  49:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/avr/include/util/delay.h ****     \code
  51:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/avr/include/util/delay.h ****     \endcode
  55:/usr/avr/include/util/delay.h **** 
  56:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/avr/include/util/delay.h ****     used.
  60:/usr/avr/include/util/delay.h **** 
  61:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/avr/include/util/delay.h **** 
  70:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/avr/include/util/delay.h **** 
  79:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** */
  84:/usr/avr/include/util/delay.h **** 
  85:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/avr/include/util/delay.h **** #endif
  89:/usr/avr/include/util/delay.h **** 
  90:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/avr/include/util/delay.h **** 
  97:/usr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/avr/include/util/delay.h **** 
 103:/usr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/avr/include/util/delay.h ****     integer value.
 107:/usr/avr/include/util/delay.h ****  */
 108:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/avr/include/util/delay.h **** #endif
 110:/usr/avr/include/util/delay.h **** 
 111:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/avr/include/util/delay.h **** #endif
 114:/usr/avr/include/util/delay.h **** 
 115:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/avr/include/util/delay.h **** #endif
 120:/usr/avr/include/util/delay.h **** 
 121:/usr/avr/include/util/delay.h **** /**
 122:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/avr/include/util/delay.h **** 
 124:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/avr/include/util/delay.h **** 
 126:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/avr/include/util/delay.h **** 
 131:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/avr/include/util/delay.h **** 
 137:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/avr/include/util/delay.h **** 
 142:/usr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/avr/include/util/delay.h **** 
 147:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/avr/include/util/delay.h ****    respectively.
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h ****    \note
 153:/usr/avr/include/util/delay.h **** 
 154:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h ****  */
 165:/usr/avr/include/util/delay.h **** void
 166:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/avr/include/util/delay.h **** {
 168:/usr/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/avr/include/util/delay.h **** 
 176:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/avr/include/util/delay.h **** 
 179:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/avr/include/util/delay.h **** 
 182:/usr/avr/include/util/delay.h **** 	#else
 183:/usr/avr/include/util/delay.h **** 		//round up by default
 184:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/avr/include/util/delay.h **** 	#endif
 186:/usr/avr/include/util/delay.h **** 
 187:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/avr/include/util/delay.h **** 
 189:/usr/avr/include/util/delay.h **** #else
 190:/usr/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/avr/include/util/delay.h **** 	{
 196:/usr/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/avr/include/util/delay.h **** 		{
 200:/usr/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/avr/include/util/delay.h **** 		}
 204:/usr/avr/include/util/delay.h **** 		return;
 205:/usr/avr/include/util/delay.h **** 	}
 206:/usr/avr/include/util/delay.h **** 	else
 207:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/avr/include/util/delay.h **** #endif
 210:/usr/avr/include/util/delay.h **** }
 211:/usr/avr/include/util/delay.h **** 
 212:/usr/avr/include/util/delay.h **** /**
 213:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/avr/include/util/delay.h **** 
 215:/usr/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/avr/include/util/delay.h **** 
 217:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/avr/include/util/delay.h **** 
 220:/usr/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/avr/include/util/delay.h **** 
 222:/usr/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/avr/include/util/delay.h **** 
 226:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/avr/include/util/delay.h **** 
 231:/usr/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/avr/include/util/delay.h **** 
 236:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/avr/include/util/delay.h ****    respectively.
 240:/usr/avr/include/util/delay.h **** 
 241:/usr/avr/include/util/delay.h ****    \note
 242:/usr/avr/include/util/delay.h **** 
 243:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/avr/include/util/delay.h **** 
 253:/usr/avr/include/util/delay.h ****  */
 254:/usr/avr/include/util/delay.h **** void
 255:/usr/avr/include/util/delay.h **** _delay_us(double __us)
 256:/usr/avr/include/util/delay.h **** {
 257:/usr/avr/include/util/delay.h **** 	double __tmp ;
 258:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 262:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:/usr/avr/include/util/delay.h **** 
 265:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/avr/include/util/delay.h **** 
 268:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/avr/include/util/delay.h **** 
 271:/usr/avr/include/util/delay.h **** 	#else
 272:/usr/avr/include/util/delay.h **** 		//round up by default
 273:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:/usr/avr/include/util/delay.h **** 	#endif
 275:/usr/avr/include/util/delay.h **** 
 276:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 521               		.loc 5 276 0
 522 01a4 80E4      		ldi r24,lo8(64)
 523 01a6 8A95      	1:	dec r24
 524 01a8 01F4      		brne 1b
 525               	.LVL37:
 526               	.LBE88:
 527               	.LBE87:
  45:srf05.h       **** 	_delay_us(12);
  46:srf05.h       **** 	SRF05_PORT &= ~(1 << TRIG);
 528               		.loc 4 46 0
 529 01aa 5B98      		cbi 0xb,3
  47:srf05.h       **** 
  48:srf05.h       **** 	//Interrupt on rising edge
  49:srf05.h       **** 	EICRA = (1 << ISC01) | (1 << ISC00);
 530               		.loc 4 49 0
 531 01ac 83E0      		ldi r24,lo8(3)
 532 01ae 8093 6900 		sts 105,r24
  50:srf05.h       **** 
  51:srf05.h       **** 	sei();
 533               		.loc 4 51 0
 534               	/* #APP */
 535               	 ;  51 "srf05.h" 1
 536 01b2 7894      		sei
 537               	 ;  0 "" 2
 538               	/* epilogue start */
  52:srf05.h       **** }
 539               		.loc 4 52 0
 540               	/* #NOAPP */
 541 01b4 0895      		ret
 542               		.cfi_endproc
 543               	.LFE16:
 545               	.global	__vector_1
 547               	__vector_1:
 548               	.LFB17:
  53:srf05.h       **** 
  54:srf05.h       **** ISR(INT0_vect){
 549               		.loc 4 54 0
 550               		.cfi_startproc
 551 01b6 1F92      		push r1
 552               	.LCFI0:
 553               		.cfi_def_cfa_offset 3
 554               		.cfi_offset 1, -2
 555 01b8 0F92      		push r0
 556               	.LCFI1:
 557               		.cfi_def_cfa_offset 4
 558               		.cfi_offset 0, -3
 559 01ba 0FB6      		in r0,__SREG__
 560 01bc 0F92      		push r0
 561 01be 1124      		clr __zero_reg__
 562 01c0 2F93      		push r18
 563               	.LCFI2:
 564               		.cfi_def_cfa_offset 5
 565               		.cfi_offset 18, -4
 566 01c2 3F93      		push r19
 567               	.LCFI3:
 568               		.cfi_def_cfa_offset 6
 569               		.cfi_offset 19, -5
 570 01c4 4F93      		push r20
 571               	.LCFI4:
 572               		.cfi_def_cfa_offset 7
 573               		.cfi_offset 20, -6
 574 01c6 5F93      		push r21
 575               	.LCFI5:
 576               		.cfi_def_cfa_offset 8
 577               		.cfi_offset 21, -7
 578 01c8 6F93      		push r22
 579               	.LCFI6:
 580               		.cfi_def_cfa_offset 9
 581               		.cfi_offset 22, -8
 582 01ca 7F93      		push r23
 583               	.LCFI7:
 584               		.cfi_def_cfa_offset 10
 585               		.cfi_offset 23, -9
 586 01cc 8F93      		push r24
 587               	.LCFI8:
 588               		.cfi_def_cfa_offset 11
 589               		.cfi_offset 24, -10
 590 01ce 9F93      		push r25
 591               	.LCFI9:
 592               		.cfi_def_cfa_offset 12
 593               		.cfi_offset 25, -11
 594 01d0 AF93      		push r26
 595               	.LCFI10:
 596               		.cfi_def_cfa_offset 13
 597               		.cfi_offset 26, -12
 598 01d2 BF93      		push r27
 599               	.LCFI11:
 600               		.cfi_def_cfa_offset 14
 601               		.cfi_offset 27, -13
 602 01d4 EF93      		push r30
 603               	.LCFI12:
 604               		.cfi_def_cfa_offset 15
 605               		.cfi_offset 30, -14
 606 01d6 FF93      		push r31
 607               	.LCFI13:
 608               		.cfi_def_cfa_offset 16
 609               		.cfi_offset 31, -15
 610               	/* prologue: Signal */
 611               	/* frame size = 0 */
 612               	/* stack size = 15 */
 613               	.L__stack_usage = 15
  55:srf05.h       **** 
  56:srf05.h       **** 	if(interrupt == 0){
 614               		.loc 4 56 0
 615 01d8 8091 0000 		lds r24,interrupt
 616 01dc 8111      		cpse r24,__zero_reg__
 617 01de 00C0      		rjmp .L37
  57:srf05.h       **** 		//Start Timer
  58:srf05.h       **** 		TCCR0B |= (1 << CS01);
 618               		.loc 4 58 0
 619 01e0 85B5      		in r24,0x25
 620 01e2 8260      		ori r24,lo8(2)
 621 01e4 85BD      		out 0x25,r24
  59:srf05.h       **** 
  60:srf05.h       **** 		//Interrupt on falling edge
  61:srf05.h       **** 		EICRA = (1 << ISC01);
 622               		.loc 4 61 0
 623 01e6 82E0      		ldi r24,lo8(2)
 624 01e8 8093 6900 		sts 105,r24
  62:srf05.h       **** 
  63:srf05.h       **** 		interrupt = 1;
 625               		.loc 4 63 0
 626 01ec 81E0      		ldi r24,lo8(1)
 627 01ee 8093 0000 		sts interrupt,r24
 628               	.L36:
 629               	/* epilogue start */
  64:srf05.h       **** 	}else{
  65:srf05.h       **** 		//Stop Timer
  66:srf05.h       **** 		TCCR0B &= ~(1 << CS01);
  67:srf05.h       **** 
  68:srf05.h       **** 		interrupt = 0;
  69:srf05.h       **** 		distance = mseconds / 58;
  70:srf05.h       **** 		SRF05_Start();
  71:srf05.h       **** 	}
  72:srf05.h       **** }
 630               		.loc 4 72 0
 631 01f2 FF91      		pop r31
 632 01f4 EF91      		pop r30
 633 01f6 BF91      		pop r27
 634 01f8 AF91      		pop r26
 635 01fa 9F91      		pop r25
 636 01fc 8F91      		pop r24
 637 01fe 7F91      		pop r23
 638 0200 6F91      		pop r22
 639 0202 5F91      		pop r21
 640 0204 4F91      		pop r20
 641 0206 3F91      		pop r19
 642 0208 2F91      		pop r18
 643 020a 0F90      		pop r0
 644 020c 0FBE      		out __SREG__,r0
 645 020e 0F90      		pop r0
 646 0210 1F90      		pop r1
 647 0212 1895      		reti
 648               	.L37:
  66:srf05.h       **** 
 649               		.loc 4 66 0
 650 0214 85B5      		in r24,0x25
 651 0216 8D7F      		andi r24,lo8(-3)
 652 0218 85BD      		out 0x25,r24
  68:srf05.h       **** 		distance = mseconds / 58;
 653               		.loc 4 68 0
 654 021a 1092 0000 		sts interrupt,__zero_reg__
  69:srf05.h       **** 		SRF05_Start();
 655               		.loc 4 69 0
 656 021e 8091 0000 		lds r24,mseconds
 657 0222 9091 0000 		lds r25,mseconds+1
 658 0226 6AE3      		ldi r22,lo8(58)
 659 0228 70E0      		ldi r23,0
 660 022a 0E94 0000 		call __udivmodhi4
 661 022e 7093 0000 		sts distance+1,r23
 662 0232 6093 0000 		sts distance,r22
  70:srf05.h       **** 	}
 663               		.loc 4 70 0
 664 0236 0E94 0000 		call SRF05_Start
 665               	.LVL38:
 666               		.loc 4 72 0
 667 023a 00C0      		rjmp .L36
 668               		.cfi_endproc
 669               	.LFE17:
 671               	.global	__vector_14
 673               	__vector_14:
 674               	.LFB18:
  73:srf05.h       **** 
  74:srf05.h       **** ISR(TIMER0_COMPA_vect){
 675               		.loc 4 74 0
 676               		.cfi_startproc
 677 023c 1F92      		push r1
 678               	.LCFI14:
 679               		.cfi_def_cfa_offset 3
 680               		.cfi_offset 1, -2
 681 023e 0F92      		push r0
 682               	.LCFI15:
 683               		.cfi_def_cfa_offset 4
 684               		.cfi_offset 0, -3
 685 0240 0FB6      		in r0,__SREG__
 686 0242 0F92      		push r0
 687 0244 1124      		clr __zero_reg__
 688 0246 8F93      		push r24
 689               	.LCFI16:
 690               		.cfi_def_cfa_offset 5
 691               		.cfi_offset 24, -4
 692 0248 9F93      		push r25
 693               	.LCFI17:
 694               		.cfi_def_cfa_offset 6
 695               		.cfi_offset 25, -5
 696               	/* prologue: Signal */
 697               	/* frame size = 0 */
 698               	/* stack size = 5 */
 699               	.L__stack_usage = 5
  75:srf05.h       **** 	mseconds += 10;
 700               		.loc 4 75 0
 701 024a 8091 0000 		lds r24,mseconds
 702 024e 9091 0000 		lds r25,mseconds+1
 703 0252 0A96      		adiw r24,10
 704 0254 9093 0000 		sts mseconds+1,r25
 705 0258 8093 0000 		sts mseconds,r24
 706               	/* epilogue start */
  76:srf05.h       **** }...
 707               		.loc 4 76 0
 708 025c 9F91      		pop r25
 709 025e 8F91      		pop r24
 710 0260 0F90      		pop r0
 711 0262 0FBE      		out __SREG__,r0
 712 0264 0F90      		pop r0
 713 0266 1F90      		pop r1
 714 0268 1895      		reti
 715               		.cfi_endproc
 716               	.LFE18:
 718               	.global	setupMotor
 720               	setupMotor:
 721               	.LFB19:
 722               		.file 6 "motor_control.h"
   1:motor_control.h **** #define MOTOR_DDR	DDRC
   2:motor_control.h **** #define MOTOR_PORT	PORTC
   3:motor_control.h **** 
   4:motor_control.h **** #define MOTOR_RIGHT_FWD_PIN		PC0
   5:motor_control.h **** #define MOTOR_RIGHT_REV_PIN		PC1
   6:motor_control.h **** #define MOTOR_LEFT_FWD_PIN		PC2
   7:motor_control.h **** #define MOTOR_LEFT_REV_PIN		PC3
   8:motor_control.h **** 
   9:motor_control.h **** #define FORWARD_MODE() { MOTOR_PORT |= (1 << MOTOR_RIGHT_FWD_PIN) | (1 << MOTOR_LEFT_FWD_PIN); MOTO
  10:motor_control.h **** #define REVERSE_MODE() { MOTOR_PORT |= (1 << MOTOR_RIGHT_REV_PIN) | (1 << MOTOR_LEFT_REV_PIN); MOTO
  11:motor_control.h **** #define RIGHT_MODE()   { MOTOR_PORT |= (1 << MOTOR_RIGHT_REV_PIN) | (1 << MOTOR_LEFT_FWD_PIN); MOTO
  12:motor_control.h **** #define LEFT_MODE()    { MOTOR_PORT |= (1 << MOTOR_RIGHT_FWD_PIN) | (1 << MOTOR_LEFT_REV_PIN); MOTO
  13:motor_control.h **** 
  14:motor_control.h **** #define Kp 27
  15:motor_control.h **** #define Ki 0
  16:motor_control.h **** #define Kd 20
  17:motor_control.h **** 
  18:motor_control.h **** #define MAX_SPEED 2000
  19:motor_control.h **** #define RIGHT_MAX 1500 //Maximum Speed
  20:motor_control.h **** #define LEFT_MAX 1500 //Maximum Speed
  21:motor_control.h **** #define RIGHT_NORMAL_SPEED 1300 //Normal Speed
  22:motor_control.h **** #define LEFT_NORMAL_SPEED 1300 //Normal Speed
  23:motor_control.h **** 
  24:motor_control.h **** #include "pwm.h"
  25:motor_control.h **** #include "ir_array.h"
  26:motor_control.h **** #include "srf05.h"
  27:motor_control.h **** 
  28:motor_control.h **** uint32_t count = 0;
  29:motor_control.h **** uint8_t count2 = 0;
  30:motor_control.h **** int P = 0, I = 0, D = 0, PID = 0;
  31:motor_control.h **** int right_motor_pwm = 0, left_motor_pwm = 0;
  32:motor_control.h **** //uint8_t channelA_status = FORWARD, channelB_status = FORWARD, left_status = FALSE, right_status=F
  33:motor_control.h **** int previous_error = 0;
  34:motor_control.h **** 
  35:motor_control.h **** void controlMotor(void);
  36:motor_control.h **** void setupMotor(void);
  37:motor_control.h **** 
  38:motor_control.h **** void setupMotor(void){
 723               		.loc 6 38 0
 724               		.cfi_startproc
 725               	/* prologue: function */
 726               	/* frame size = 0 */
 727               	/* stack size = 0 */
 728               	.L__stack_usage = 0
  39:motor_control.h **** 	MOTOR_DDR = 0x0F;
 729               		.loc 6 39 0
 730 026a 8FE0      		ldi r24,lo8(15)
 731 026c 87B9      		out 0x7,r24
 732               	.LVL39:
 733               	.LBB89:
 734               	.LBB90:
  20:pwm.h         **** 	ICR1 = period;
 735               		.loc 1 20 0
 736 026e E6E8      		ldi r30,lo8(-122)
 737 0270 F0E0      		ldi r31,0
 738 0272 80ED      		ldi r24,lo8(-48)
 739 0274 97E0      		ldi r25,lo8(7)
 740 0276 9183      		std Z+1,r25
 741 0278 8083      		st Z,r24
  21:pwm.h         **** 	(channel == CH_B) ? (OCR1B = onTime) : (OCR1A = onTime);
 742               		.loc 1 21 0
 743 027a 1092 8900 		sts 136+1,__zero_reg__
 744 027e 1092 8800 		sts 136,__zero_reg__
 745               	.LVL40:
 746               	.LBE90:
 747               	.LBE89:
 748               	.LBB91:
 749               	.LBB92:
  20:pwm.h         **** 	ICR1 = period;
 750               		.loc 1 20 0
 751 0282 9183      		std Z+1,r25
 752 0284 8083      		st Z,r24
  21:pwm.h         **** 	(channel == CH_B) ? (OCR1B = onTime) : (OCR1A = onTime);
 753               		.loc 1 21 0
 754 0286 1092 8B00 		sts 138+1,__zero_reg__
 755 028a 1092 8A00 		sts 138,__zero_reg__
 756               	.LVL41:
 757               	/* epilogue start */
 758               	.LBE92:
 759               	.LBE91:
  40:motor_control.h **** 
  41:motor_control.h **** 	pwm(CH_A, 0, MAX_SPEED);
  42:motor_control.h **** 	pwm(CH_B, 0, MAX_SPEED);
  43:motor_control.h **** 
  44:motor_control.h **** 	//controlMotor(NEUTRAL);
  45:motor_control.h **** }
 760               		.loc 6 45 0
 761 028e 0895      		ret
 762               		.cfi_endproc
 763               	.LFE19:
 765               	.global	controlMotor
 767               	controlMotor:
 768               	.LFB20:
  46:motor_control.h **** 
  47:motor_control.h **** void controlMotor(){
 769               		.loc 6 47 0
 770               		.cfi_startproc
 771 0290 CF93      		push r28
 772               	.LCFI18:
 773               		.cfi_def_cfa_offset 3
 774               		.cfi_offset 28, -2
 775               	/* prologue: function */
 776               	/* frame size = 0 */
 777               	/* stack size = 1 */
 778               	.L__stack_usage = 1
  48:motor_control.h **** 
  49:motor_control.h **** 	count++;
 779               		.loc 6 49 0
 780 0292 4091 0000 		lds r20,count
 781 0296 5091 0000 		lds r21,count+1
 782 029a 6091 0000 		lds r22,count+2
 783 029e 7091 0000 		lds r23,count+3
 784 02a2 4F5F      		subi r20,-1
 785 02a4 5F4F      		sbci r21,-1
 786 02a6 6F4F      		sbci r22,-1
 787 02a8 7F4F      		sbci r23,-1
 788 02aa 4093 0000 		sts count,r20
 789 02ae 5093 0000 		sts count+1,r21
 790 02b2 6093 0000 		sts count+2,r22
 791 02b6 7093 0000 		sts count+3,r23
 792               	.LBB93:
  50:motor_control.h **** 	uint8_t ir_val = IR_ARR_VAL;
 793               		.loc 6 50 0
 794 02ba C9B1      		in r28,0x9
 795 02bc C295      		swap r28
 796 02be C170      		andi r28,1
 797               	.LVL42:
 798               	.LBE93:
 799               	.LBB94:
 800 02c0 4D99      		sbic 0x9,5
 801 02c2 00C0      		rjmp .L58
 802 02c4 80E0      		ldi r24,0
 803               	.L42:
 804               	.LVL43:
 805               	.LBE94:
 806               		.loc 6 50 0 is_stmt 0 discriminator 4
 807 02c6 C82B      		or r28,r24
 808               	.LVL44:
 809               	.LBB95:
 810 02c8 4E99      		sbic 0x9,6
 811 02ca 00C0      		rjmp .L59
 812               		.loc 6 50 0
 813 02cc 80E0      		ldi r24,0
 814               	.LVL45:
 815               	.L43:
 816               	.LBE95:
 817               		.loc 6 50 0 discriminator 8
 818 02ce C82B      		or r28,r24
 819               	.LBB96:
 820 02d0 4F99      		sbic 0x9,7
 821 02d2 00C0      		rjmp .L60
 822               		.loc 6 50 0
 823 02d4 80E0      		ldi r24,0
 824               	.LVL46:
 825               	.L44:
 826               	.LBE96:
 827               		.loc 6 50 0 discriminator 12
 828 02d6 C82B      		or r28,r24
 829               	.LBB97:
 830 02d8 1D99      		sbic 0x3,5
 831 02da 00C0      		rjmp .L61
 832               		.loc 6 50 0
 833 02dc 80E0      		ldi r24,0
 834               	.LVL47:
 835               	.L45:
 836               	.LBE97:
 837               		.loc 6 50 0 discriminator 16
 838 02de C82B      		or r28,r24
 839               	.LBB98:
 840 02e0 1B99      		sbic 0x3,3
 841 02e2 00C0      		rjmp .L62
 842               		.loc 6 50 0
 843 02e4 80E0      		ldi r24,0
 844               	.LVL48:
 845               	.L46:
 846               	.LBE98:
 847               		.loc 6 50 0 discriminator 20
 848 02e6 C82B      		or r28,r24
 849               	.LBB99:
 850 02e8 1C99      		sbic 0x3,4
 851 02ea 00C0      		rjmp .L63
 852               		.loc 6 50 0
 853 02ec 80E0      		ldi r24,0
 854               	.LVL49:
 855               	.L47:
 856               	.LBE99:
 857               		.loc 6 50 0 discriminator 24
 858 02ee C82B      		or r28,r24
 859               	.LBB100:
 860 02f0 1899      		sbic 0x3,0
 861 02f2 00C0      		rjmp .L64
 862               		.loc 6 50 0
 863 02f4 80E0      		ldi r24,0
 864               	.LVL50:
 865               	.L48:
 866               	.LBE100:
 867               		.loc 6 50 0 discriminator 28
 868 02f6 C82B      		or r28,r24
 869               	.LVL51:
  51:motor_control.h **** 
  52:motor_control.h **** 	if(count == 200000){
 870               		.loc 6 52 0 is_stmt 1 discriminator 28
 871 02f8 4034      		cpi r20,64
 872 02fa 5D40      		sbci r21,13
 873 02fc 6340      		sbci r22,3
 874 02fe 7105      		cpc r23,__zero_reg__
 875 0300 01F4      		brne .L49
  53:motor_control.h **** 		putCh(distance);
 876               		.loc 6 53 0
 877 0302 8091 0000 		lds r24,distance
 878               	.LVL52:
 879 0306 0E94 0000 		call putCh
 880               	.LVL53:
  54:motor_control.h **** 		count = 0;
 881               		.loc 6 54 0
 882 030a 1092 0000 		sts count,__zero_reg__
 883 030e 1092 0000 		sts count+1,__zero_reg__
 884 0312 1092 0000 		sts count+2,__zero_reg__
 885 0316 1092 0000 		sts count+3,__zero_reg__
 886               	.L49:
  55:motor_control.h **** 	}
  56:motor_control.h **** 
  57:motor_control.h **** 	int error = getError();
 887               		.loc 6 57 0
 888 031a 0E94 0000 		call getError
 889               	.LVL54:
  58:motor_control.h **** 	P = error;
 890               		.loc 6 58 0
 891 031e 9093 0000 		sts P+1,r25
 892 0322 8093 0000 		sts P,r24
  59:motor_control.h **** 	I +=  error;
 893               		.loc 6 59 0
 894 0326 2091 0000 		lds r18,I
 895 032a 3091 0000 		lds r19,I+1
 896 032e 280F      		add r18,r24
 897 0330 391F      		adc r19,r25
 898 0332 3093 0000 		sts I+1,r19
 899 0336 2093 0000 		sts I,r18
  60:motor_control.h **** 	D = error - previous_error;
 900               		.loc 6 60 0
 901 033a 2091 0000 		lds r18,previous_error
 902 033e 3091 0000 		lds r19,previous_error+1
 903 0342 AC01      		movw r20,r24
 904 0344 421B      		sub r20,r18
 905 0346 530B      		sbc r21,r19
 906 0348 9A01      		movw r18,r20
 907 034a 5093 0000 		sts D+1,r21
 908 034e 4093 0000 		sts D,r20
  61:motor_control.h **** 	previous_error = error;
 909               		.loc 6 61 0
 910 0352 9093 0000 		sts previous_error+1,r25
 911 0356 8093 0000 		sts previous_error,r24
  62:motor_control.h **** 
  63:motor_control.h **** 	PID = Kp * P + Ki * I + Kd * D;
 912               		.loc 6 63 0
 913 035a 6BE1      		ldi r22,lo8(27)
 914 035c 689F      		mul r22,r24
 915 035e A001      		movw r20,r0
 916 0360 699F      		mul r22,r25
 917 0362 500D      		add r21,r0
 918 0364 1124      		clr __zero_reg__
 919 0366 E4E1      		ldi r30,lo8(20)
 920 0368 E29F      		mul r30,r18
 921 036a B001      		movw r22,r0
 922 036c E39F      		mul r30,r19
 923 036e 700D      		add r23,r0
 924 0370 1124      		clr __zero_reg__
 925 0372 460F      		add r20,r22
 926 0374 571F      		adc r21,r23
 927 0376 5093 0000 		sts PID+1,r21
 928 037a 4093 0000 		sts PID,r20
  64:motor_control.h **** 
  65:motor_control.h **** 	right_motor_pwm = RIGHT_NORMAL_SPEED + PID;
 929               		.loc 6 65 0
 930 037e 9A01      		movw r18,r20
 931 0380 2C5E      		subi r18,-20
 932 0382 3A4F      		sbci r19,-6
 933 0384 3093 0000 		sts right_motor_pwm+1,r19
 934 0388 2093 0000 		sts right_motor_pwm,r18
  66:motor_control.h **** 	left_motor_pwm = LEFT_NORMAL_SPEED - PID;
 935               		.loc 6 66 0
 936 038c 24E1      		ldi r18,lo8(20)
 937 038e 35E0      		ldi r19,lo8(5)
 938 0390 B901      		movw r22,r18
 939 0392 641B      		sub r22,r20
 940 0394 750B      		sbc r23,r21
 941 0396 7093 0000 		sts left_motor_pwm+1,r23
 942 039a 6093 0000 		sts left_motor_pwm,r22
  67:motor_control.h **** 
  68:motor_control.h **** 	FORWARD_MODE();
 943               		.loc 6 68 0
 944 039e 48B1      		in r20,0x8
 945 03a0 4560      		ori r20,lo8(5)
 946 03a2 48B9      		out 0x8,r20
 947 03a4 48B1      		in r20,0x8
 948 03a6 457F      		andi r20,lo8(-11)
 949 03a8 48B9      		out 0x8,r20
  69:motor_control.h **** 
  70:motor_control.h **** 	if(ir_val == 0x00){
 950               		.loc 6 70 0
 951 03aa C111      		cpse r28,__zero_reg__
 952 03ac 00C0      		rjmp .L50
  71:motor_control.h **** 		if(error > 1000 && count2 <= 5){
 953               		.loc 6 71 0
 954 03ae 893E      		cpi r24,-23
 955 03b0 73E0      		ldi r23,3
 956 03b2 9707      		cpc r25,r23
 957 03b4 04F4      		brge .+2
 958 03b6 00C0      		rjmp .L51
 959               		.loc 6 71 0 is_stmt 0 discriminator 1
 960 03b8 8091 0000 		lds r24,count2
 961               	.LVL55:
 962 03bc 8630      		cpi r24,lo8(6)
 963 03be 00F0      		brlo .+2
 964 03c0 00C0      		rjmp .L52
  72:motor_control.h **** 			REVERSE_MODE();
 965               		.loc 6 72 0 is_stmt 1
 966 03c2 88B1      		in r24,0x8
 967 03c4 8A60      		ori r24,lo8(10)
 968 03c6 88B9      		out 0x8,r24
 969 03c8 88B1      		in r24,0x8
 970 03ca 8A7F      		andi r24,lo8(-6)
 971 03cc 88B9      		out 0x8,r24
 972               	.LVL56:
 973               	.LBB101:
 974               	.LBB102:
  20:pwm.h         **** 	ICR1 = period;
 975               		.loc 1 20 0
 976 03ce 80ED      		ldi r24,lo8(-48)
 977 03d0 97E0      		ldi r25,lo8(7)
 978 03d2 9093 8700 		sts 134+1,r25
 979 03d6 8093 8600 		sts 134,r24
  21:pwm.h         **** 	(channel == CH_B) ? (OCR1B = onTime) : (OCR1A = onTime);
 980               		.loc 1 21 0
 981 03da 3093 8900 		sts 136+1,r19
 982 03de 2093 8800 		sts 136,r18
 983               	.LVL57:
 984               	.LBE102:
 985               	.LBE101:
 986               	.LBB103:
 987               	.LBB104:
  20:pwm.h         **** 	ICR1 = period;
 988               		.loc 1 20 0
 989 03e2 9093 8700 		sts 134+1,r25
 990 03e6 8093 8600 		sts 134,r24
  21:pwm.h         **** 	(channel == CH_B) ? (OCR1B = onTime) : (OCR1A = onTime);
 991               		.loc 1 21 0
 992 03ea 3093 8B00 		sts 138+1,r19
 993 03ee 2093 8A00 		sts 138,r18
 994               	.LVL58:
 995               	.LBE104:
 996               	.LBE103:
 997               	.LBB105:
 998               	.LBB106:
 187:/usr/avr/include/util/delay.h **** 
 999               		.loc 5 187 0
 1000 03f2 4FEF      		ldi r20,lo8(319999)
 1001 03f4 51EE      		ldi r21,hi8(319999)
 1002 03f6 64E0      		ldi r22,hlo8(319999)
 1003 03f8 4150      	1:	subi r20,1
 1004 03fa 5040      		sbci r21,0
 1005 03fc 6040      		sbci r22,0
 1006 03fe 01F4      		brne 1b
 1007 0400 00C0      		rjmp .
 1008 0402 0000      		nop
 1009               	.LVL59:
 1010               	.LBE106:
 1011               	.LBE105:
  73:motor_control.h **** 			pwm(CH_A, RIGHT_NORMAL_SPEED, MAX_SPEED);
  74:motor_control.h **** 			pwm(CH_B, LEFT_NORMAL_SPEED, MAX_SPEED);
  75:motor_control.h **** 			_delay_ms(100);
  76:motor_control.h **** 			FORWARD_MODE();
 1012               		.loc 6 76 0
 1013 0404 48B1      		in r20,0x8
 1014 0406 4560      		ori r20,lo8(5)
 1015 0408 48B9      		out 0x8,r20
 1016 040a 48B1      		in r20,0x8
 1017 040c 457F      		andi r20,lo8(-11)
 1018 040e 48B9      		out 0x8,r20
 1019               	.LVL60:
 1020               	.LBB107:
 1021               	.LBB108:
  20:pwm.h         **** 	ICR1 = period;
 1022               		.loc 1 20 0
 1023 0410 9093 8700 		sts 134+1,r25
 1024 0414 8093 8600 		sts 134,r24
  21:pwm.h         **** 	(channel == CH_B) ? (OCR1B = onTime) : (OCR1A = onTime);
 1025               		.loc 1 21 0
 1026 0418 4AE8      		ldi r20,lo8(-118)
 1027 041a 52E0      		ldi r21,lo8(2)
 1028 041c 5093 8900 		sts 136+1,r21
 1029 0420 4093 8800 		sts 136,r20
 1030               	.LVL61:
 1031               	.LBE108:
 1032               	.LBE107:
 1033               	.LBB109:
 1034               	.LBB110:
  20:pwm.h         **** 	ICR1 = period;
 1035               		.loc 1 20 0
 1036 0424 9093 8700 		sts 134+1,r25
 1037 0428 8093 8600 		sts 134,r24
  21:pwm.h         **** 	(channel == CH_B) ? (OCR1B = onTime) : (OCR1A = onTime);
 1038               		.loc 1 21 0
 1039 042c 3093 8B00 		sts 138+1,r19
 1040 0430 2093 8A00 		sts 138,r18
 1041               	.LVL62:
 1042               	.LBE110:
 1043               	.LBE109:
 1044               	.LBB111:
 1045               	.LBB112:
 187:/usr/avr/include/util/delay.h **** 
 1046               		.loc 5 187 0
 1047 0434 8FE3      		ldi r24,lo8(-25537)
 1048 0436 9CE9      		ldi r25,hi8(-25537)
 1049 0438 0197      	1:	sbiw r24,1
 1050 043a 01F4      		brne 1b
 1051               	.LVL63:
 1052               	.L65:
 1053               	.LBE112:
 1054               	.LBE111:
 1055               	.LBB113:
 1056               	.LBB114:
 1057 043c 00C0      		rjmp .
 1058 043e 0000      		nop
 1059               	.LBE114:
 1060               	.LBE113:
  77:motor_control.h **** 			pwm(CH_A, RIGHT_NORMAL_SPEED/2, MAX_SPEED);
  78:motor_control.h **** 			pwm(CH_B, LEFT_NORMAL_SPEED, MAX_SPEED);
  79:motor_control.h **** 			_delay_ms(10);
  80:motor_control.h **** 			count2++;
  81:motor_control.h **** 		}else if(error < -1000 && count2 <= 5){
  82:motor_control.h **** 			REVERSE_MODE();
  83:motor_control.h **** 			pwm(CH_A, RIGHT_NORMAL_SPEED, MAX_SPEED);
  84:motor_control.h **** 			pwm(CH_B, LEFT_NORMAL_SPEED, MAX_SPEED);
  85:motor_control.h **** 			_delay_ms(1000);
  86:motor_control.h **** 			FORWARD_MODE();
  87:motor_control.h **** 			pwm(CH_A, RIGHT_NORMAL_SPEED, MAX_SPEED);
  88:motor_control.h **** 			pwm(CH_B, LEFT_NORMAL_SPEED/2, MAX_SPEED);
  89:motor_control.h **** 			_delay_ms(100);
  90:motor_control.h **** 			count2++;
 1061               		.loc 6 90 0
 1062 0440 8091 0000 		lds r24,count2
 1063 0444 8F5F      		subi r24,lo8(-(1))
 1064 0446 8093 0000 		sts count2,r24
 1065               	.L41:
 1066               	/* epilogue start */
  91:motor_control.h **** 		}else{
  92:motor_control.h **** 			pwm(CH_A, 0, MAX_SPEED);
  93:motor_control.h **** 			pwm(CH_B, 0, MAX_SPEED);
  94:motor_control.h **** 		}
  95:motor_control.h **** 
  96:motor_control.h **** 		return;
  97:motor_control.h **** 	}
  98:motor_control.h **** 
  99:motor_control.h **** 	if(right_motor_pwm > RIGHT_MAX)
 100:motor_control.h **** 		right_motor_pwm = RIGHT_MAX;
 101:motor_control.h **** 
 102:motor_control.h **** 	if(left_motor_pwm > LEFT_MAX)
 103:motor_control.h **** 		left_motor_pwm = LEFT_MAX;
 104:motor_control.h **** 
 105:motor_control.h **** 	if(right_motor_pwm < 0)
 106:motor_control.h **** 		right_motor_pwm = 0;
 107:motor_control.h **** 
 108:motor_control.h **** 	if(left_motor_pwm < 0)
 109:motor_control.h **** 		left_motor_pwm = 0;
 110:motor_control.h **** 
 111:motor_control.h **** 	count2 = 0;
 112:motor_control.h **** 
 113:motor_control.h **** 	pwm(CH_A, right_motor_pwm, MAX_SPEED);
 114:motor_control.h **** 	pwm(CH_B, left_motor_pwm, MAX_SPEED);
 115:motor_control.h **** 	/*switch(status){
 116:motor_control.h **** 		case FORWARD:
 117:motor_control.h **** 			if(channelA_status == FORWARD && channelB_status == FORWARD){
 118:motor_control.h **** 				(channelA == MAX_SPEED) ? (channelA = MAX_SPEED) : (channelA += SPEED_INCREASE_RATE);
 119:motor_control.h **** 				channelB = channelA;
 120:motor_control.h **** 			}else if(channelA_status == REVERSE && channelB_status == REVERSE){
 121:motor_control.h **** 				if(channelA > MIN_PWM_SPEED){
 122:motor_control.h **** 					channelA -= BREAK_RATE;
 123:motor_control.h **** 					channelB = channelA;
 124:motor_control.h **** 				}else{
 125:motor_control.h **** 					FORWARD_MODE();
 126:motor_control.h **** 					channelA_status = FORWARD;
 127:motor_control.h **** 					channelB_status = FORWARD;
 128:motor_control.h **** 				}
 129:motor_control.h **** 			}
 130:motor_control.h **** 			break;
 131:motor_control.h **** 		
 132:motor_control.h **** 		case REVERSE:
 133:motor_control.h **** 			if(channelA_status == REVERSE && channelB_status == REVERSE){
 134:motor_control.h **** 				(channelA == MAX_SPEED) ? (channelA = MAX_SPEED) : (channelA += SPEED_INCREASE_RATE);
 135:motor_control.h **** 				channelB = channelA;
 136:motor_control.h **** 			}else if(channelA_status == FORWARD && channelB_status == FORWARD){
 137:motor_control.h **** 				if(channelA > MIN_PWM_SPEED){
 138:motor_control.h **** 					channelA -= BREAK_RATE;
 139:motor_control.h **** 					channelB = channelA;
 140:motor_control.h **** 				}else{
 141:motor_control.h **** 					REVERSE_MODE();
 142:motor_control.h **** 					channelA_status = REVERSE;
 143:motor_control.h **** 					channelB_status = REVERSE;
 144:motor_control.h **** 				}
 145:motor_control.h **** 			}
 146:motor_control.h **** 			break;
 147:motor_control.h **** 		
 148:motor_control.h **** 		case STOP:
 149:motor_control.h **** 			MOTOR_PORT = 0x00;
 150:motor_control.h **** 			channelA = 0x00;
 151:motor_control.h **** 			channelB = 0x00;
 152:motor_control.h **** 			break;
 153:motor_control.h **** 
 154:motor_control.h **** 		case NEUTRAL:
 155:motor_control.h **** 			if(channelA > MIN_PWM_SPEED){
 156:motor_control.h **** 				channelA -= SPEED_DECREASE_RATE;
 157:motor_control.h **** 				channelB = channelA;
 158:motor_control.h **** 			}
 159:motor_control.h **** 
 160:motor_control.h **** 			if(channelB_status == FORWARD && channelB_status == FORWARD){
 161:motor_control.h **** 				FORWARD_MODE();
 162:motor_control.h **** 			}
 163:motor_control.h **** 			else{
 164:motor_control.h **** 				REVERSE_MODE();
 165:motor_control.h **** 			}
 166:motor_control.h **** 
 167:motor_control.h **** 			if(left_status || right_status){
 168:motor_control.h **** 				channelA = 0x00;
 169:motor_control.h **** 				channelB = 0x00;
 170:motor_control.h **** 				left_status = FALSE;
 171:motor_control.h **** 				right_status = FALSE;
 172:motor_control.h **** 			}
 173:motor_control.h **** 			break;
 174:motor_control.h **** 
 175:motor_control.h **** 		case RIGHT:
 176:motor_control.h **** 			//RIGHT_MODE();
 177:motor_control.h **** 			if(channelA < MIN_PWM_SPEED){
 178:motor_control.h **** 				left_status = FALSE;
 179:motor_control.h **** 				right_status = TRUE;
 180:motor_control.h **** 				channelA = 15000;
 181:motor_control.h **** 				channelB -= 30;
 182:motor_control.h **** 			}
 183:motor_control.h **** 			break;
 184:motor_control.h **** 
 185:motor_control.h **** 		case LEFT:
 186:motor_control.h **** 			//LEFT_MODE();
 187:motor_control.h **** 			if(channelA < MIN_PWM_SPEED){
 188:motor_control.h **** 				left_status = TRUE;
 189:motor_control.h **** 				right_status = FALSE;
 190:motor_control.h **** 				channelA -= 30;
 191:motor_control.h **** 				channelB = MAX_PWM_SPEED / 2;
 192:motor_control.h **** 			}
 193:motor_control.h **** 			break;
 194:motor_control.h **** 	}
 195:motor_control.h **** 
 196:motor_control.h **** 	pwm(CH_A, channelA, MAX_PWM_SPEED);
 197:motor_control.h **** 	pwm(CH_B, channelB, MAX_PWM_SPEED);
 198:motor_control.h **** 	*/
 199:motor_control.h **** }...
 1067               		.loc 6 199 0
 1068 044a CF91      		pop r28
 1069               	.LVL64:
 1070 044c 0895      		ret
 1071               	.LVL65:
 1072               	.L58:
 1073               	.LBB116:
  50:motor_control.h **** 	uint8_t ir_val = IR_ARR_VAL;
 1074               		.loc 6 50 0
 1075 044e 82E0      		ldi r24,lo8(2)
 1076 0450 00C0      		rjmp .L42
 1077               	.LVL66:
 1078               	.L59:
 1079               	.LBE116:
 1080               	.LBB117:
 1081 0452 84E0      		ldi r24,lo8(4)
 1082               	.LVL67:
 1083 0454 00C0      		rjmp .L43
 1084               	.LVL68:
 1085               	.L60:
 1086               	.LBE117:
 1087               	.LBB118:
 1088 0456 88E0      		ldi r24,lo8(8)
 1089               	.LVL69:
 1090 0458 00C0      		rjmp .L44
 1091               	.LVL70:
 1092               	.L61:
 1093               	.LBE118:
 1094               	.LBB119:
 1095 045a 80E1      		ldi r24,lo8(16)
 1096               	.LVL71:
 1097 045c 00C0      		rjmp .L45
 1098               	.LVL72:
 1099               	.L62:
 1100               	.LBE119:
 1101               	.LBB120:
 1102 045e 80E2      		ldi r24,lo8(32)
 1103               	.LVL73:
 1104 0460 00C0      		rjmp .L46
 1105               	.LVL74:
 1106               	.L63:
 1107               	.LBE120:
 1108               	.LBB121:
 1109 0462 80E4      		ldi r24,lo8(64)
 1110               	.LVL75:
 1111 0464 00C0      		rjmp .L47
 1112               	.LVL76:
 1113               	.L64:
 1114               	.LBE121:
 1115               	.LBB122:
 1116 0466 80E8      		ldi r24,lo8(-128)
 1117               	.LVL77:
 1118 0468 00C0      		rjmp .L48
 1119               	.LVL78:
 1120               	.L51:
 1121               	.LBE122:
  81:motor_control.h **** 		}else if(error < -1000 && count2 <= 5){
 1122               		.loc 6 81 0
 1123 046a 8831      		cpi r24,24
 1124 046c 9C4F      		sbci r25,-4
 1125 046e 04F0      		brlt .+2
 1126 0470 00C0      		rjmp .L52
  81:motor_control.h **** 		}else if(error < -1000 && count2 <= 5){
 1127               		.loc 6 81 0 is_stmt 0 discriminator 1
 1128 0472 8091 0000 		lds r24,count2
 1129               	.LVL79:
 1130 0476 8630      		cpi r24,lo8(6)
 1131 0478 00F0      		brlo .+2
 1132 047a 00C0      		rjmp .L52
  82:motor_control.h **** 			REVERSE_MODE();
 1133               		.loc 6 82 0 is_stmt 1
 1134 047c 88B1      		in r24,0x8
 1135 047e 8A60      		ori r24,lo8(10)
 1136 0480 88B9      		out 0x8,r24
 1137 0482 88B1      		in r24,0x8
 1138 0484 8A7F      		andi r24,lo8(-6)
 1139 0486 88B9      		out 0x8,r24
 1140               	.LVL80:
 1141               	.LBB123:
 1142               	.LBB124:
  20:pwm.h         **** 	ICR1 = period;
 1143               		.loc 1 20 0
 1144 0488 80ED      		ldi r24,lo8(-48)
 1145 048a 97E0      		ldi r25,lo8(7)
 1146 048c 9093 8700 		sts 134+1,r25
 1147 0490 8093 8600 		sts 134,r24
  21:pwm.h         **** 	(channel == CH_B) ? (OCR1B = onTime) : (OCR1A = onTime);
 1148               		.loc 1 21 0
 1149 0494 3093 8900 		sts 136+1,r19
 1150 0498 2093 8800 		sts 136,r18
 1151               	.LVL81:
 1152               	.LBE124:
 1153               	.LBE123:
 1154               	.LBB125:
 1155               	.LBB126:
  20:pwm.h         **** 	ICR1 = period;
 1156               		.loc 1 20 0
 1157 049c 9093 8700 		sts 134+1,r25
 1158 04a0 8093 8600 		sts 134,r24
  21:pwm.h         **** 	(channel == CH_B) ? (OCR1B = onTime) : (OCR1A = onTime);
 1159               		.loc 1 21 0
 1160 04a4 3093 8B00 		sts 138+1,r19
 1161 04a8 2093 8A00 		sts 138,r18
 1162               	.LVL82:
 1163               	.LBE126:
 1164               	.LBE125:
 1165               	.LBB127:
 1166               	.LBB128:
 187:/usr/avr/include/util/delay.h **** 
 1167               		.loc 5 187 0
 1168 04ac 5FEF      		ldi r21,lo8(3199999)
 1169 04ae 63ED      		ldi r22,hi8(3199999)
 1170 04b0 70E3      		ldi r23,hlo8(3199999)
 1171 04b2 5150      	1:	subi r21,1
 1172 04b4 6040      		sbci r22,0
 1173 04b6 7040      		sbci r23,0
 1174 04b8 01F4      		brne 1b
 1175 04ba 00C0      		rjmp .
 1176 04bc 0000      		nop
 1177               	.LVL83:
 1178               	.LBE128:
 1179               	.LBE127:
  86:motor_control.h **** 			FORWARD_MODE();
 1180               		.loc 6 86 0
 1181 04be 48B1      		in r20,0x8
 1182 04c0 4560      		ori r20,lo8(5)
 1183 04c2 48B9      		out 0x8,r20
 1184 04c4 48B1      		in r20,0x8
 1185 04c6 457F      		andi r20,lo8(-11)
 1186 04c8 48B9      		out 0x8,r20
 1187               	.LVL84:
 1188               	.LBB129:
 1189               	.LBB130:
  20:pwm.h         **** 	ICR1 = period;
 1190               		.loc 1 20 0
 1191 04ca 9093 8700 		sts 134+1,r25
 1192 04ce 8093 8600 		sts 134,r24
  21:pwm.h         **** 	(channel == CH_B) ? (OCR1B = onTime) : (OCR1A = onTime);
 1193               		.loc 1 21 0
 1194 04d2 3093 8900 		sts 136+1,r19
 1195 04d6 2093 8800 		sts 136,r18
 1196               	.LVL85:
 1197               	.LBE130:
 1198               	.LBE129:
 1199               	.LBB131:
 1200               	.LBB132:
  20:pwm.h         **** 	ICR1 = period;
 1201               		.loc 1 20 0
 1202 04da 9093 8700 		sts 134+1,r25
 1203 04de 8093 8600 		sts 134,r24
  21:pwm.h         **** 	(channel == CH_B) ? (OCR1B = onTime) : (OCR1A = onTime);
 1204               		.loc 1 21 0
 1205 04e2 8AE8      		ldi r24,lo8(-118)
 1206 04e4 92E0      		ldi r25,lo8(2)
 1207 04e6 9093 8B00 		sts 138+1,r25
 1208 04ea 8093 8A00 		sts 138,r24
 1209               	.LVL86:
 1210               	.LBE132:
 1211               	.LBE131:
 1212               	.LBB133:
 1213               	.LBB115:
 187:/usr/avr/include/util/delay.h **** 
 1214               		.loc 5 187 0
 1215 04ee 8FEF      		ldi r24,lo8(319999)
 1216 04f0 91EE      		ldi r25,hi8(319999)
 1217 04f2 24E0      		ldi r18,hlo8(319999)
 1218 04f4 8150      	1:	subi r24,1
 1219 04f6 9040      		sbci r25,0
 1220 04f8 2040      		sbci r18,0
 1221 04fa 01F4      		brne 1b
 1222 04fc 00C0      		rjmp .L65
 1223               	.LVL87:
 1224               	.L52:
 1225               	.LBE115:
 1226               	.LBE133:
 1227               	.LBB134:
 1228               	.LBB135:
  20:pwm.h         **** 	ICR1 = period;
 1229               		.loc 1 20 0
 1230 04fe 80ED      		ldi r24,lo8(-48)
 1231 0500 97E0      		ldi r25,lo8(7)
 1232 0502 9093 8700 		sts 134+1,r25
 1233 0506 8093 8600 		sts 134,r24
  21:pwm.h         **** 	(channel == CH_B) ? (OCR1B = onTime) : (OCR1A = onTime);
 1234               		.loc 1 21 0
 1235 050a 1092 8900 		sts 136+1,__zero_reg__
 1236 050e 1092 8800 		sts 136,__zero_reg__
 1237               	.LVL88:
 1238               	.LBE135:
 1239               	.LBE134:
 1240               	.LBB136:
 1241               	.LBB137:
  20:pwm.h         **** 	ICR1 = period;
 1242               		.loc 1 20 0
 1243 0512 9093 8700 		sts 134+1,r25
 1244 0516 8093 8600 		sts 134,r24
  21:pwm.h         **** 	(channel == CH_B) ? (OCR1B = onTime) : (OCR1A = onTime);
 1245               		.loc 1 21 0
 1246 051a 1092 8B00 		sts 138+1,__zero_reg__
 1247 051e 1092 8A00 		sts 138,__zero_reg__
 1248 0522 00C0      		rjmp .L41
 1249               	.LVL89:
 1250               	.L50:
 1251               	.LBE137:
 1252               	.LBE136:
  99:motor_control.h **** 	if(right_motor_pwm > RIGHT_MAX)
 1253               		.loc 6 99 0
 1254 0524 8091 0000 		lds r24,right_motor_pwm
 1255 0528 9091 0000 		lds r25,right_motor_pwm+1
 1256               	.LVL90:
 1257 052c 8D3D      		cpi r24,-35
 1258 052e 9540      		sbci r25,5
 1259 0530 04F0      		brlt .L54
 100:motor_control.h **** 		right_motor_pwm = RIGHT_MAX;
 1260               		.loc 6 100 0
 1261 0532 8CED      		ldi r24,lo8(-36)
 1262 0534 95E0      		ldi r25,lo8(5)
 1263 0536 9093 0000 		sts right_motor_pwm+1,r25
 1264 053a 8093 0000 		sts right_motor_pwm,r24
 1265               	.L54:
 102:motor_control.h **** 	if(left_motor_pwm > LEFT_MAX)
 1266               		.loc 6 102 0
 1267 053e 8091 0000 		lds r24,left_motor_pwm
 1268 0542 9091 0000 		lds r25,left_motor_pwm+1
 1269 0546 8D3D      		cpi r24,-35
 1270 0548 9540      		sbci r25,5
 1271 054a 04F0      		brlt .L55
 103:motor_control.h **** 		left_motor_pwm = LEFT_MAX;
 1272               		.loc 6 103 0
 1273 054c 8CED      		ldi r24,lo8(-36)
 1274 054e 95E0      		ldi r25,lo8(5)
 1275 0550 9093 0000 		sts left_motor_pwm+1,r25
 1276 0554 8093 0000 		sts left_motor_pwm,r24
 1277               	.L55:
 105:motor_control.h **** 	if(right_motor_pwm < 0)
 1278               		.loc 6 105 0
 1279 0558 8091 0000 		lds r24,right_motor_pwm
 1280 055c 9091 0000 		lds r25,right_motor_pwm+1
 1281 0560 97FF      		sbrs r25,7
 1282 0562 00C0      		rjmp .L56
 106:motor_control.h **** 		right_motor_pwm = 0;
 1283               		.loc 6 106 0
 1284 0564 1092 0000 		sts right_motor_pwm+1,__zero_reg__
 1285 0568 1092 0000 		sts right_motor_pwm,__zero_reg__
 1286               	.L56:
 108:motor_control.h **** 	if(left_motor_pwm < 0)
 1287               		.loc 6 108 0
 1288 056c 8091 0000 		lds r24,left_motor_pwm
 1289 0570 9091 0000 		lds r25,left_motor_pwm+1
 1290 0574 97FF      		sbrs r25,7
 1291 0576 00C0      		rjmp .L57
 109:motor_control.h **** 		left_motor_pwm = 0;
 1292               		.loc 6 109 0
 1293 0578 1092 0000 		sts left_motor_pwm+1,__zero_reg__
 1294 057c 1092 0000 		sts left_motor_pwm,__zero_reg__
 1295               	.L57:
 111:motor_control.h **** 	count2 = 0;
 1296               		.loc 6 111 0
 1297 0580 1092 0000 		sts count2,__zero_reg__
 113:motor_control.h **** 	pwm(CH_A, right_motor_pwm, MAX_SPEED);
 1298               		.loc 6 113 0
 1299 0584 2091 0000 		lds r18,right_motor_pwm
 1300 0588 3091 0000 		lds r19,right_motor_pwm+1
 1301               	.LVL91:
 1302               	.LBB138:
 1303               	.LBB139:
  20:pwm.h         **** 	ICR1 = period;
 1304               		.loc 1 20 0
 1305 058c 80ED      		ldi r24,lo8(-48)
 1306 058e 97E0      		ldi r25,lo8(7)
 1307 0590 9093 8700 		sts 134+1,r25
 1308 0594 8093 8600 		sts 134,r24
  21:pwm.h         **** 	(channel == CH_B) ? (OCR1B = onTime) : (OCR1A = onTime);
 1309               		.loc 1 21 0
 1310 0598 3093 8900 		sts 136+1,r19
 1311 059c 2093 8800 		sts 136,r18
 1312               	.LVL92:
 1313               	.LBE139:
 1314               	.LBE138:
 114:motor_control.h **** 	pwm(CH_B, left_motor_pwm, MAX_SPEED);
 1315               		.loc 6 114 0
 1316 05a0 2091 0000 		lds r18,left_motor_pwm
 1317 05a4 3091 0000 		lds r19,left_motor_pwm+1
 1318               	.LVL93:
 1319               	.LBB140:
 1320               	.LBB141:
  20:pwm.h         **** 	ICR1 = period;
 1321               		.loc 1 20 0
 1322 05a8 9093 8700 		sts 134+1,r25
 1323 05ac 8093 8600 		sts 134,r24
  21:pwm.h         **** 	(channel == CH_B) ? (OCR1B = onTime) : (OCR1A = onTime);
 1324               		.loc 1 21 0
 1325 05b0 3093 8B00 		sts 138+1,r19
 1326 05b4 2093 8A00 		sts 138,r18
 1327 05b8 00C0      		rjmp .L41
 1328               	.LBE141:
 1329               	.LBE140:
 1330               		.cfi_endproc
 1331               	.LFE20:
 1333               		.section	.text.startup,"ax",@progbits
 1334               	.global	main
 1336               	main:
 1337               	.LFB21:
 1338               		.file 7 "main.c"
   1:main.c        **** #define F_CPU 16000000UL
   2:main.c        **** 
   3:main.c        **** //Comment the MCU which you're not using.
   4:main.c        **** #define ATMEGA_328P
   5:main.c        **** //#define ATMEGA_32A
   6:main.c        **** 
   7:main.c        **** #include <avr/io.h>
   8:main.c        **** #include <util/delay.h>
   9:main.c        **** #include "motor_control.h"
  10:main.c        **** 
  11:main.c        **** int main(void){
 1339               		.loc 7 11 0
 1340               		.cfi_startproc
 1341               	/* prologue: function */
 1342               	/* frame size = 0 */
 1343               	/* stack size = 0 */
 1344               	.L__stack_usage = 0
  12:main.c        **** 
  13:main.c        **** 	setupPWM();
 1345               		.loc 7 13 0
 1346 0000 0E94 0000 		call setupPWM
 1347               	.LVL94:
  14:main.c        **** 	setupMotor();
 1348               		.loc 7 14 0
 1349 0004 0E94 0000 		call setupMotor
 1350               	.LVL95:
  15:main.c        **** 	initIR();
 1351               		.loc 7 15 0
 1352 0008 0E94 0000 		call initIR
 1353               	.LVL96:
  16:main.c        **** 	init_SRF05();
 1354               		.loc 7 16 0
 1355 000c 0E94 0000 		call init_SRF05
 1356               	.LVL97:
  17:main.c        **** 	SRF05_Start();
 1357               		.loc 7 17 0
 1358 0010 0E94 0000 		call SRF05_Start
 1359               	.LVL98:
 1360               	.L67:
  18:main.c        **** 
  19:main.c        **** 	while(1){
  20:main.c        **** 		controlMotor();
 1361               		.loc 7 20 0 discriminator 1
 1362 0014 0E94 0000 		call controlMotor
 1363               	.LVL99:
 1364 0018 00C0      		rjmp .L67
 1365               		.cfi_endproc
 1366               	.LFE21:
 1368               	.global	previous_error
 1369               		.section .bss
 1372               	previous_error:
 1373 0000 0000      		.zero	2
 1374               	.global	left_motor_pwm
 1377               	left_motor_pwm:
 1378 0002 0000      		.zero	2
 1379               	.global	right_motor_pwm
 1382               	right_motor_pwm:
 1383 0004 0000      		.zero	2
 1384               	.global	PID
 1387               	PID:
 1388 0006 0000      		.zero	2
 1389               	.global	D
 1392               	D:
 1393 0008 0000      		.zero	2
 1394               	.global	I
 1397               	I:
 1398 000a 0000      		.zero	2
 1399               	.global	P
 1402               	P:
 1403 000c 0000      		.zero	2
 1404               	.global	count2
 1407               	count2:
 1408 000e 00        		.zero	1
 1409               	.global	count
 1412               	count:
 1413 000f 0000 0000 		.zero	4
 1414               	.global	interrupt
 1417               	interrupt:
 1418 0013 00        		.zero	1
 1419               	.global	mseconds
 1422               	mseconds:
 1423 0014 0000      		.zero	2
 1424               		.comm	distance,2,1
 1425               	.global	width
 1428               	width:
 1429 0016 00        		.zero	1
 1430               		.text
 1431               	.Letext0:
 1432               		.file 8 "/usr/avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/cc7PaewB.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc7PaewB.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc7PaewB.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc7PaewB.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc7PaewB.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc7PaewB.s:12     .text:0000000000000000 setupPWM
     /tmp/cc7PaewB.s:39     .text:0000000000000014 pwm
     /tmp/cc7PaewB.s:70     .text:0000000000000034 initUSART
     /tmp/cc7PaewB.s:102    .text:0000000000000050 getCh
     /tmp/cc7PaewB.s:125    .text:000000000000005e putCh
     /tmp/cc7PaewB.s:149    .text:000000000000006c initIR
     /tmp/cc7PaewB.s:173    .text:000000000000007c getPosition
     /tmp/cc7PaewB.s:383    .text:0000000000000156 getError
     /tmp/cc7PaewB.s:408    .text:0000000000000168 lineSize
     /tmp/cc7PaewB.s:466    .text:000000000000017c init_SRF05
     /tmp/cc7PaewB.s:502    .text:0000000000000198 SRF05_Start
     /tmp/cc7PaewB.s:1422   .bss:0000000000000014 mseconds
     /tmp/cc7PaewB.s:547    .text:00000000000001b6 __vector_1
     /tmp/cc7PaewB.s:1417   .bss:0000000000000013 interrupt
                            *COM*:0000000000000002 distance
     /tmp/cc7PaewB.s:673    .text:000000000000023c __vector_14
     /tmp/cc7PaewB.s:720    .text:000000000000026a setupMotor
     /tmp/cc7PaewB.s:767    .text:0000000000000290 controlMotor
     /tmp/cc7PaewB.s:1412   .bss:000000000000000f count
     /tmp/cc7PaewB.s:1402   .bss:000000000000000c P
     /tmp/cc7PaewB.s:1397   .bss:000000000000000a I
     /tmp/cc7PaewB.s:1372   .bss:0000000000000000 previous_error
     /tmp/cc7PaewB.s:1392   .bss:0000000000000008 D
     /tmp/cc7PaewB.s:1387   .bss:0000000000000006 PID
     /tmp/cc7PaewB.s:1382   .bss:0000000000000004 right_motor_pwm
     /tmp/cc7PaewB.s:1377   .bss:0000000000000002 left_motor_pwm
     /tmp/cc7PaewB.s:1407   .bss:000000000000000e count2
     /tmp/cc7PaewB.s:1336   .text.startup:0000000000000000 main
     /tmp/cc7PaewB.s:1428   .bss:0000000000000016 width

UNDEFINED SYMBOLS
__udivmodhi4
__do_clear_bss

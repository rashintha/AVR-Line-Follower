   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	init_ADC
  12               	init_ADC:
  13               	.LFB6:
  14               		.file 1 "color_sensor.h"
   1:color_sensor.h **** #ifndef F_CPU
   2:color_sensor.h **** #define F_CPU 16000000UL
   3:color_sensor.h **** #endif
   4:color_sensor.h **** 
   5:color_sensor.h **** #include <avr/io.h>
   6:color_sensor.h **** #include <util/delay.h>
   7:color_sensor.h **** 
   8:color_sensor.h **** void init_ADC(void);
   9:color_sensor.h **** uint16_t read_ADC(void);
  10:color_sensor.h **** 
  11:color_sensor.h **** void init_ADC(void){
  15               		.loc 1 11 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  12:color_sensor.h **** 	//Set Reference to AVcc and select ADC channel 4
  13:color_sensor.h **** 	ADMUX |= (1 << REFS0) | (1 << MUX2);
  21               		.loc 1 13 0
  22 0000 ECE7      		ldi r30,lo8(124)
  23 0002 F0E0      		ldi r31,0
  24 0004 8081      		ld r24,Z
  25 0006 8464      		ori r24,lo8(68)
  26 0008 8083      		st Z,r24
  14:color_sensor.h **** 
  15:color_sensor.h **** 	/*
  16:color_sensor.h **** 	 * Enable ADC 
  17:color_sensor.h **** 	 * Set prescaler to 128 so input frequency will be 125kHz
  18:color_sensor.h **** 	 * Enable ADC Interrupt
  19:color_sensor.h **** 	 */
  20:color_sensor.h **** 	ADCSRA |= (1 << ADEN) | (1 << ADPS0) | (1 << ADPS1) | (1 << ADPS2) | (1 << ADIE);
  27               		.loc 1 20 0
  28 000a EAE7      		ldi r30,lo8(122)
  29 000c F0E0      		ldi r31,0
  30 000e 8081      		ld r24,Z
  31 0010 8F68      		ori r24,lo8(-113)
  32 0012 8083      		st Z,r24
  21:color_sensor.h **** 
  22:color_sensor.h **** 	//Enable ADC Noise Reduction Mode
  23:color_sensor.h **** 	SMCR |= (1 << SM0);
  33               		.loc 1 23 0
  34 0014 83B7      		in r24,0x33
  35 0016 8260      		ori r24,lo8(2)
  36 0018 83BF      		out 0x33,r24
  37               	/* epilogue start */
  24:color_sensor.h **** }
  38               		.loc 1 24 0
  39 001a 0895      		ret
  40               		.cfi_endproc
  41               	.LFE6:
  43               	.global	read_ADC
  45               	read_ADC:
  46               	.LFB7:
  25:color_sensor.h **** 
  26:color_sensor.h **** uint16_t read_ADC(void){
  47               		.loc 1 26 0
  48               		.cfi_startproc
  49               	/* prologue: function */
  50               	/* frame size = 0 */
  51               	/* stack size = 0 */
  52               	.L__stack_usage = 0
  27:color_sensor.h **** 	//Start Conversion
  28:color_sensor.h **** 	ADCSRA |= (1 << ADSC);
  53               		.loc 1 28 0
  54 001c EAE7      		ldi r30,lo8(122)
  55 001e F0E0      		ldi r31,0
  56 0020 8081      		ld r24,Z
  57 0022 8064      		ori r24,lo8(64)
  58 0024 8083      		st Z,r24
  29:color_sensor.h **** 
  30:color_sensor.h **** 	//Start Sleeping
  31:color_sensor.h **** 	SMCR |= (1 << SE);
  59               		.loc 1 31 0
  60 0026 83B7      		in r24,0x33
  61 0028 8160      		ori r24,lo8(1)
  62 002a 83BF      		out 0x33,r24
  32:color_sensor.h **** 
  33:color_sensor.h **** 	return ADC;
  63               		.loc 1 33 0
  64 002c 8091 7800 		lds r24,120
  65 0030 9091 7900 		lds r25,120+1
  66               	/* epilogue start */
  34:color_sensor.h **** }...
  67               		.loc 1 34 0
  68 0034 0895      		ret
  69               		.cfi_endproc
  70               	.LFE7:
  72               	.global	setupPWM
  74               	setupPWM:
  75               	.LFB8:
  76               		.file 2 "pwm.h"
   1:pwm.h         **** #include <avr/io.h>
   2:pwm.h         **** #include "cpu_def.h"
   3:pwm.h         **** 
   4:pwm.h         **** //Define PWM Channels
   5:pwm.h         **** #define CH_A 0
   6:pwm.h         **** #define CH_B 1
   7:pwm.h         **** 
   8:pwm.h         **** void setupPWM(void);
   9:pwm.h         **** void pwm(uint8_t channel, uint16_t onTime, uint16_t period);
  10:pwm.h         **** 
  11:pwm.h         **** //Initializing PWM
  12:pwm.h         **** void setupPWM(void){
  77               		.loc 2 12 0
  78               		.cfi_startproc
  79               	/* prologue: function */
  80               	/* frame size = 0 */
  81               	/* stack size = 0 */
  82               	.L__stack_usage = 0
  13:pwm.h         **** 	OC1x_DDR |= (1 << OC1A_PIN) | (1 << OC1B_PIN);
  83               		.loc 2 13 0
  84 0036 84B1      		in r24,0x4
  85 0038 8660      		ori r24,lo8(6)
  86 003a 84B9      		out 0x4,r24
  14:pwm.h         **** 	TCCR1A = (1 << COM1A1) | (1 << COM1B1) | (1 << WGM11);	
  87               		.loc 2 14 0
  88 003c 82EA      		ldi r24,lo8(-94)
  89 003e 8093 8000 		sts 128,r24
  15:pwm.h         **** 	TCCR1B = (1 << WGM13) | (1 << WGM12) | (1 << CS11);
  90               		.loc 2 15 0
  91 0042 8AE1      		ldi r24,lo8(26)
  92 0044 8093 8100 		sts 129,r24
  93               	/* epilogue start */
  16:pwm.h         **** }
  94               		.loc 2 16 0
  95 0048 0895      		ret
  96               		.cfi_endproc
  97               	.LFE8:
  99               	.global	pwm
 101               	pwm:
 102               	.LFB9:
  17:pwm.h         **** 
  18:pwm.h         **** //Set PWM of the selected channel
  19:pwm.h         **** void pwm(uint8_t channel, uint16_t onTime, uint16_t period){
 103               		.loc 2 19 0
 104               		.cfi_startproc
 105               	.LVL0:
 106               	/* prologue: function */
 107               	/* frame size = 0 */
 108               	/* stack size = 0 */
 109               	.L__stack_usage = 0
  20:pwm.h         **** 	ICR1 = period;
 110               		.loc 2 20 0
 111 004a 5093 8700 		sts 134+1,r21
 112 004e 4093 8600 		sts 134,r20
  21:pwm.h         **** 	(channel == CH_B) ? (OCR1B = onTime) : (OCR1A = onTime);
 113               		.loc 2 21 0
 114 0052 8130      		cpi r24,lo8(1)
 115 0054 01F4      		brne .L5
 116               		.loc 2 21 0 is_stmt 0 discriminator 1
 117 0056 7093 8B00 		sts 138+1,r23
 118 005a 6093 8A00 		sts 138,r22
 119 005e 0895      		ret
 120               	.L5:
 121               		.loc 2 21 0 discriminator 2
 122 0060 7093 8900 		sts 136+1,r23
 123 0064 6093 8800 		sts 136,r22
 124               	/* epilogue start */
  22:pwm.h         **** }...
 125               		.loc 2 22 0 is_stmt 1 discriminator 2
 126 0068 0895      		ret
 127               		.cfi_endproc
 128               	.LFE9:
 130               	.global	initUSART
 132               	initUSART:
 133               	.LFB10:
 134               		.file 3 "serial.h"
   1:serial.h      **** #define BAUD_RATE 9600
   2:serial.h      **** 
   3:serial.h      **** #include <avr/io.h>
   4:serial.h      **** #include "cpu_def.h"
   5:serial.h      **** 
   6:serial.h      **** void initUSART(void);
   7:serial.h      **** uint8_t getCh(void);
   8:serial.h      **** void putCh(uint8_t data);
   9:serial.h      **** 
  10:serial.h      **** void initUSART(void){
 135               		.loc 3 10 0
 136               		.cfi_startproc
 137               	/* prologue: function */
 138               	/* frame size = 0 */
 139               	/* stack size = 0 */
 140               	.L__stack_usage = 0
 141               	.LVL1:
  11:serial.h      ****    //Set Baud rate; ubrr_value = F_OSC/(16 x Baud_rate) - 1; e.g. 16e6/(9600*16) -1 = 103
  12:serial.h      **** 	uint32_t ubrr_value;
  13:serial.h      **** 	ubrr_value = F_CPU/16/BAUD_RATE -1; 
  14:serial.h      **** 	UBRRL_REG = ubrr_value;
 142               		.loc 3 14 0
 143 006a 87E6      		ldi r24,lo8(103)
 144 006c 8093 C400 		sts 196,r24
  15:serial.h      **** 	UBRRH_REG = (ubrr_value >> 8);
 145               		.loc 3 15 0
 146 0070 1092 C500 		sts 197,__zero_reg__
  16:serial.h      **** 	UCSRC_REG |= (1 << UCSZ1_BIT) | (1 << UCSZ0_BIT);
 147               		.loc 3 16 0
 148 0074 E2EC      		ldi r30,lo8(-62)
 149 0076 F0E0      		ldi r31,0
 150 0078 8081      		ld r24,Z
 151 007a 8660      		ori r24,lo8(6)
 152 007c 8083      		st Z,r24
  17:serial.h      **** 
  18:serial.h      **** 	#ifdef ATMEGA_32A
  19:serial.h      **** 	UCSRC_REG |= (1 << URSEL_BIT);
  20:serial.h      **** 	#endif
  21:serial.h      **** 
  22:serial.h      **** 	//Enable The receiver and transmitter
  23:serial.h      **** 	UCSRB_REG = (1 << RXEN_BIT) | (1 << TXEN_BIT);
 153               		.loc 3 23 0
 154 007e 88E1      		ldi r24,lo8(24)
 155 0080 8093 C100 		sts 193,r24
 156               	/* epilogue start */
  24:serial.h      **** }
 157               		.loc 3 24 0
 158 0084 0895      		ret
 159               		.cfi_endproc
 160               	.LFE10:
 162               	.global	getCh
 164               	getCh:
 165               	.LFB11:
  25:serial.h      **** 
  26:serial.h      **** uint8_t getCh(void){
 166               		.loc 3 26 0
 167               		.cfi_startproc
 168               	/* prologue: function */
 169               	/* frame size = 0 */
 170               	/* stack size = 0 */
 171               	.L__stack_usage = 0
 172               	.L9:
  27:serial.h      **** 	while(!(UCSRA_REG & (1 << RXC_BIT)));
 173               		.loc 3 27 0 discriminator 1
 174 0086 8091 C000 		lds r24,192
 175 008a 87FF      		sbrs r24,7
 176 008c 00C0      		rjmp .L9
  28:serial.h      **** 	return UDR_REG;
 177               		.loc 3 28 0
 178 008e 8091 C600 		lds r24,198
 179               	/* epilogue start */
  29:serial.h      **** }
 180               		.loc 3 29 0
 181 0092 0895      		ret
 182               		.cfi_endproc
 183               	.LFE11:
 185               	.global	putCh
 187               	putCh:
 188               	.LFB12:
  30:serial.h      **** 
  31:serial.h      **** void putCh(uint8_t data){
 189               		.loc 3 31 0
 190               		.cfi_startproc
 191               	/* prologue: function */
 192               	/* frame size = 0 */
 193               	/* stack size = 0 */
 194               	.L__stack_usage = 0
 195               	.LVL2:
 196               	.L12:
  32:serial.h      **** 	while(!(UCSRA_REG & (1 << UDRE_BIT)));
 197               		.loc 3 32 0 discriminator 1
 198 0094 9091 C000 		lds r25,192
 199 0098 95FF      		sbrs r25,5
 200 009a 00C0      		rjmp .L12
  33:serial.h      **** 	UDR_REG = data;
 201               		.loc 3 33 0
 202 009c 8093 C600 		sts 198,r24
 203               	/* epilogue start */
  34:serial.h      **** }...
 204               		.loc 3 34 0
 205 00a0 0895      		ret
 206               		.cfi_endproc
 207               	.LFE12:
 209               	.global	initIR
 211               	initIR:
 212               	.LFB13:
 213               		.file 4 "ir_array.h"
   1:ir_array.h    **** #define IR_LEFT_DDR DDRD
   2:ir_array.h    **** #define IR_LEFT_PIN PIND
   3:ir_array.h    **** 
   4:ir_array.h    **** #define IR_L_01 PD4
   5:ir_array.h    **** #define IR_L_02 PD5
   6:ir_array.h    **** #define IR_L_03 PD6
   7:ir_array.h    **** #define IR_L_04 PD7
   8:ir_array.h    **** 
   9:ir_array.h    **** #define IR_RIGHT_DDR DDRB
  10:ir_array.h    **** #define IR_RIGHT_PIN PINB
  11:ir_array.h    **** 
  12:ir_array.h    **** #define IR_R_05 PB5
  13:ir_array.h    **** #define IR_R_06 PB3
  14:ir_array.h    **** #define IR_R_07 PB4
  15:ir_array.h    **** #define IR_R_08 PB0
  16:ir_array.h    **** 
  17:ir_array.h    **** #define IR01_VAL() ({ uint8_t retVal = (IR_LEFT_PIN & (1 << IR_L_01)) ? (1 << 0) : 0; retVal;})
  18:ir_array.h    **** #define IR02_VAL() ({uint8_t retVal = (IR_LEFT_PIN & (1 << IR_L_02)) ? (1 << 1) : 0; retVal;})
  19:ir_array.h    **** #define IR03_VAL() ({uint8_t retVal = (IR_LEFT_PIN & (1 << IR_L_03)) ? (1 << 2) : 0; retVal;})
  20:ir_array.h    **** #define IR04_VAL() ({uint8_t retVal = (IR_LEFT_PIN & (1 << IR_L_04)) ? (1 << 3) : 0; retVal;})
  21:ir_array.h    **** #define IR05_VAL() ({uint8_t retVal = (IR_RIGHT_PIN & (1 << IR_R_05)) ? (1 << 4) : 0; retVal;})
  22:ir_array.h    **** #define IR06_VAL() ({uint8_t retVal = (IR_RIGHT_PIN & (1 << IR_R_06)) ? (1 << 5) : 0; retVal;})
  23:ir_array.h    **** #define IR07_VAL() ({uint8_t retVal = (IR_RIGHT_PIN & (1 << IR_R_07)) ? (1 << 6) : 0; retVal;})
  24:ir_array.h    **** #define IR08_VAL() ({uint8_t retVal = (IR_RIGHT_PIN & (1 << IR_R_08)) ? (1 << 7) : 0; retVal;})
  25:ir_array.h    **** 
  26:ir_array.h    **** #define IR_ARR_VAL IR01_VAL() | IR02_VAL() | IR03_VAL() | IR04_VAL() | IR05_VAL() | IR06_VAL() | IR
  27:ir_array.h    **** 
  28:ir_array.h    **** #define IR_POSITION IR01_VAL() * 0 | IR02_VAL() * 1000 | IR03_VAL() * 2000 | IR04_VAL() * 3000 | IR
  29:ir_array.h    **** 
  30:ir_array.h    **** #define SETUP_IR() {IR_LEFT_DDR &= ~((1 << IR_L_01) | (1 << IR_L_02) | (1 << IR_L_03) | (1 << IR_L_
  31:ir_array.h    **** 
  32:ir_array.h    **** #include "serial.h"
  33:ir_array.h    **** 
  34:ir_array.h    **** uint8_t width = 0;
  35:ir_array.h    **** 
  36:ir_array.h    **** void initIR(void);
  37:ir_array.h    **** void stableCar(void);
  38:ir_array.h    **** uint8_t lineSize(void);
  39:ir_array.h    **** int getPosition(void);
  40:ir_array.h    ****  
  41:ir_array.h    **** void initIR(void){
 214               		.loc 4 41 0
 215               		.cfi_startproc
 216               	/* prologue: function */
 217               	/* frame size = 0 */
 218               	/* stack size = 0 */
 219               	.L__stack_usage = 0
  42:ir_array.h    **** 	SETUP_IR();
 220               		.loc 4 42 0
 221 00a2 8AB1      		in r24,0xa
 222 00a4 8F70      		andi r24,lo8(15)
 223 00a6 8AB9      		out 0xa,r24
 224 00a8 84B1      		in r24,0x4
 225 00aa 867C      		andi r24,lo8(-58)
 226 00ac 84B9      		out 0x4,r24
  43:ir_array.h    **** 	initUSART();
 227               		.loc 4 43 0
 228 00ae 0C94 0000 		jmp initUSART
 229               	.LVL3:
 230               		.cfi_endproc
 231               	.LFE13:
 233               	.global	getPosition
 235               	getPosition:
 236               	.LFB14:
  44:ir_array.h    **** }
  45:ir_array.h    **** 
  46:ir_array.h    **** int getPosition(void){
 237               		.loc 4 46 0
 238               		.cfi_startproc
 239               	/* prologue: function */
 240               	/* frame size = 0 */
 241               	/* stack size = 0 */
 242               	.L__stack_usage = 0
 243               	.LBB64:
  47:ir_array.h    **** 	int position = IR_POSITION / 2;
 244               		.loc 4 47 0
 245 00b2 89B1      		in r24,0x9
 246               	.LVL4:
 247               	.LBE64:
 248               	.LBB65:
 249 00b4 4D99      		sbic 0x9,5
 250 00b6 00C0      		rjmp .L26
 251 00b8 90E0      		ldi r25,0
 252               	.L17:
 253               	.LVL5:
 254               	.LBE65:
 255               		.loc 4 47 0 is_stmt 0 discriminator 4
 256 00ba 28EE      		ldi r18,lo8(-24)
 257 00bc 33E0      		ldi r19,lo8(3)
 258 00be 929F      		mul r25,r18
 259 00c0 A001      		movw r20,r0
 260 00c2 939F      		mul r25,r19
 261 00c4 500D      		add r21,r0
 262 00c6 1124      		clr __zero_reg__
 263               	.LBB66:
 264 00c8 4E99      		sbic 0x9,6
 265 00ca 00C0      		rjmp .L27
 266               		.loc 4 47 0
 267 00cc 30E0      		ldi r19,0
 268               	.L18:
 269               	.LVL6:
 270               	.LBE66:
 271               		.loc 4 47 0 discriminator 8
 272 00ce 60ED      		ldi r22,lo8(-48)
 273 00d0 77E0      		ldi r23,lo8(7)
 274 00d2 369F      		mul r19,r22
 275 00d4 C001      		movw r24,r0
 276 00d6 379F      		mul r19,r23
 277 00d8 900D      		add r25,r0
 278 00da 1124      		clr __zero_reg__
 279 00dc 9C01      		movw r18,r24
 280 00de 242B      		or r18,r20
 281 00e0 352B      		or r19,r21
 282               	.LVL7:
 283               	.LBB67:
 284 00e2 4F99      		sbic 0x9,7
 285 00e4 00C0      		rjmp .L28
 286               		.loc 4 47 0
 287 00e6 40E0      		ldi r20,0
 288               	.L19:
 289               	.LVL8:
 290               	.LBE67:
 291               		.loc 4 47 0 discriminator 12
 292 00e8 68EB      		ldi r22,lo8(-72)
 293 00ea 7BE0      		ldi r23,lo8(11)
 294 00ec 469F      		mul r20,r22
 295 00ee C001      		movw r24,r0
 296 00f0 479F      		mul r20,r23
 297 00f2 900D      		add r25,r0
 298 00f4 1124      		clr __zero_reg__
 299 00f6 822B      		or r24,r18
 300 00f8 932B      		or r25,r19
 301               	.LVL9:
 302               	.LBB68:
 303 00fa 1D99      		sbic 0x3,5
 304 00fc 00C0      		rjmp .L29
 305               		.loc 4 47 0
 306 00fe 40E0      		ldi r20,0
 307               	.LVL10:
 308               	.L20:
 309               	.LBE68:
 310               		.loc 4 47 0 discriminator 16
 311 0100 60EA      		ldi r22,lo8(-96)
 312 0102 7FE0      		ldi r23,lo8(15)
 313 0104 469F      		mul r20,r22
 314 0106 9001      		movw r18,r0
 315 0108 479F      		mul r20,r23
 316 010a 300D      		add r19,r0
 317 010c 1124      		clr __zero_reg__
 318 010e 822B      		or r24,r18
 319 0110 932B      		or r25,r19
 320               	.LBB69:
 321 0112 1B99      		sbic 0x3,3
 322 0114 00C0      		rjmp .L30
 323               		.loc 4 47 0
 324 0116 40E0      		ldi r20,0
 325               	.LVL11:
 326               	.L21:
 327               	.LBE69:
 328               		.loc 4 47 0 discriminator 20
 329 0118 68E8      		ldi r22,lo8(-120)
 330 011a 73E1      		ldi r23,lo8(19)
 331 011c 469F      		mul r20,r22
 332 011e 9001      		movw r18,r0
 333 0120 479F      		mul r20,r23
 334 0122 300D      		add r19,r0
 335 0124 1124      		clr __zero_reg__
 336 0126 282B      		or r18,r24
 337 0128 392B      		or r19,r25
 338               	.LBB70:
 339 012a 1C99      		sbic 0x3,4
 340 012c 00C0      		rjmp .L31
 341               		.loc 4 47 0
 342 012e 40E0      		ldi r20,0
 343               	.LVL12:
 344               	.L22:
 345               	.LBE70:
 346               		.loc 4 47 0 discriminator 24
 347 0130 60E7      		ldi r22,lo8(112)
 348 0132 77E1      		ldi r23,lo8(23)
 349 0134 469F      		mul r20,r22
 350 0136 C001      		movw r24,r0
 351 0138 479F      		mul r20,r23
 352 013a 900D      		add r25,r0
 353 013c 1124      		clr __zero_reg__
 354 013e 282B      		or r18,r24
 355 0140 392B      		or r19,r25
 356               	.LBB71:
 357 0142 1899      		sbic 0x3,0
 358 0144 00C0      		rjmp .L32
 359               		.loc 4 47 0
 360 0146 40E0      		ldi r20,0
 361               	.LVL13:
 362               	.L23:
 363               	.LBE71:
 364               		.loc 4 47 0 discriminator 28
 365 0148 6CEA      		ldi r22,lo8(-84)
 366 014a 7DE0      		ldi r23,lo8(13)
 367 014c 469F      		mul r20,r22
 368 014e C001      		movw r24,r0
 369 0150 479F      		mul r20,r23
 370 0152 900D      		add r25,r0
 371 0154 1124      		clr __zero_reg__
 372 0156 822B      		or r24,r18
 373 0158 932B      		or r25,r19
 374               	.LVL14:
  48:ir_array.h    **** 
  49:ir_array.h    **** 	if(position > 7000){
 375               		.loc 4 49 0 is_stmt 1 discriminator 28
 376 015a 8935      		cpi r24,89
 377 015c 2BE1      		ldi r18,27
 378 015e 9207      		cpc r25,r18
 379 0160 04F0      		brlt .L16
 380               	.L25:
  50:ir_array.h    **** 		while(position >= 7000){
  51:ir_array.h    **** 			position /= 2;
 381               		.loc 4 51 0
 382 0162 9595      		asr r25
 383 0164 8795      		ror r24
 384               	.LVL15:
  50:ir_array.h    **** 		while(position >= 7000){
 385               		.loc 4 50 0
 386 0166 8835      		cpi r24,88
 387 0168 2BE1      		ldi r18,27
 388 016a 9207      		cpc r25,r18
 389 016c 04F4      		brge .L25
 390               	.L16:
 391               	/* epilogue start */
  52:ir_array.h    **** 		}
  53:ir_array.h    **** 	}
  54:ir_array.h    **** 
  55:ir_array.h    **** 	return position;
  56:ir_array.h    **** 
  57:ir_array.h    **** }
 392               		.loc 4 57 0
 393 016e 0895      		ret
 394               	.LVL16:
 395               	.L26:
 396               	.LBB72:
  47:ir_array.h    **** 
 397               		.loc 4 47 0
 398 0170 92E0      		ldi r25,lo8(2)
 399 0172 00C0      		rjmp .L17
 400               	.LVL17:
 401               	.L27:
 402               	.LBE72:
 403               	.LBB73:
 404 0174 34E0      		ldi r19,lo8(4)
 405 0176 00C0      		rjmp .L18
 406               	.L28:
 407               	.LBE73:
 408               	.LBB74:
 409 0178 48E0      		ldi r20,lo8(8)
 410 017a 00C0      		rjmp .L19
 411               	.LVL18:
 412               	.L29:
 413               	.LBE74:
 414               	.LBB75:
 415 017c 40E1      		ldi r20,lo8(16)
 416               	.LVL19:
 417 017e 00C0      		rjmp .L20
 418               	.LVL20:
 419               	.L30:
 420               	.LBE75:
 421               	.LBB76:
 422 0180 40E2      		ldi r20,lo8(32)
 423               	.LVL21:
 424 0182 00C0      		rjmp .L21
 425               	.LVL22:
 426               	.L31:
 427               	.LBE76:
 428               	.LBB77:
 429 0184 40E4      		ldi r20,lo8(64)
 430               	.LVL23:
 431 0186 00C0      		rjmp .L22
 432               	.LVL24:
 433               	.L32:
 434               	.LBE77:
 435               	.LBB78:
 436 0188 40E8      		ldi r20,lo8(-128)
 437               	.LVL25:
 438 018a 00C0      		rjmp .L23
 439               	.LBE78:
 440               		.cfi_endproc
 441               	.LFE14:
 443               	.global	getError
 445               	getError:
 446               	.LFB15:
  58:ir_array.h    **** 
  59:ir_array.h    **** int getError(){
 447               		.loc 4 59 0
 448               		.cfi_startproc
 449               	/* prologue: function */
 450               	/* frame size = 0 */
 451               	/* stack size = 0 */
 452               	.L__stack_usage = 0
  60:ir_array.h    **** 
  61:ir_array.h    **** 	return 3500 - getPosition();
 453               		.loc 4 61 0
 454 018c 0E94 0000 		call getPosition
 455               	.LVL26:
  62:ir_array.h    **** 	/*if(~IR01_VAL() && ~IR02_VAL() && ~IR03_VAL() && ~IR04_VAL() && ~IR05_VAL() && ~IR06_VAL() && ~IR
  63:ir_array.h    **** 
  64:ir_array.h    **** 	if(~IR01_VAL() && ~IR02_VAL() && ~IR03_VAL() && ~IR04_VAL() && ~IR05_VAL() && ~IR06_VAL() && IR07_
  65:ir_array.h    **** 
  66:ir_array.h    **** 	if(~IR01_VAL() && ~IR02_VAL() && ~IR03_VAL() && ~IR04_VAL() && ~IR05_VAL() && ~IR06_VAL() && IR07_
  67:ir_array.h    **** 
  68:ir_array.h    **** 	if(~IR01_VAL() && ~IR02_VAL() && ~IR03_VAL() && ~IR04_VAL() && ~IR05_VAL() && IR06_VAL() && IR07_V
  69:ir_array.h    **** 
  70:ir_array.h    **** 	if(~IR01_VAL() && ~IR02_VAL() && ~IR03_VAL() && ~IR04_VAL() && ~IR05_VAL() && IR06_VAL() && ~IR07_
  71:ir_array.h    **** 
  72:ir_array.h    **** 	if(~IR01_VAL() && ~IR02_VAL() && ~IR03_VAL() && ~IR04_VAL() && IR05_VAL() && IR06_VAL() && ~IR07_V
  73:ir_array.h    **** 
  74:ir_array.h    **** 	if(~IR01_VAL() && ~IR02_VAL() && ~IR03_VAL() && ~IR04_VAL() && IR05_VAL() && ~IR06_VAL() && ~IR07_
  75:ir_array.h    **** 
  76:ir_array.h    **** 	if(~IR01_VAL() && ~IR02_VAL() && ~IR03_VAL() && IR04_VAL() && IR05_VAL() && ~IR06_VAL() && ~IR07_V
  77:ir_array.h    **** 
  78:ir_array.h    **** 	if(~IR01_VAL() && ~IR02_VAL() && ~IR03_VAL() && IR04_VAL() && ~IR05_VAL() && ~IR06_VAL() && ~IR07_
  79:ir_array.h    **** 
  80:ir_array.h    **** 	if(~IR01_VAL() && ~IR02_VAL() && IR03_VAL() && IR04_VAL() && ~IR05_VAL() && ~IR06_VAL() && ~IR07_V
  81:ir_array.h    **** 
  82:ir_array.h    **** 	if(~IR01_VAL() && ~IR02_VAL() && IR03_VAL() && ~IR04_VAL() && ~IR05_VAL() && ~IR06_VAL() && ~IR07_
  83:ir_array.h    **** 
  84:ir_array.h    **** 	if(~IR01_VAL() && IR02_VAL() && IR03_VAL() && ~IR04_VAL() && ~IR05_VAL() && ~IR06_VAL() && ~IR07_V
  85:ir_array.h    **** 
  86:ir_array.h    **** 	if(~IR01_VAL() && IR02_VAL() && ~IR03_VAL() && ~IR04_VAL() && ~IR05_VAL() && ~IR06_VAL() && ~IR07_
  87:ir_array.h    **** 
  88:ir_array.h    **** 	if(IR01_VAL() && IR02_VAL() && ~IR03_VAL() && ~IR04_VAL() && ~IR05_VAL() && ~IR06_VAL() && ~IR07_V
  89:ir_array.h    **** 
  90:ir_array.h    **** 	if(IR01_VAL() && ~IR02_VAL() && ~IR03_VAL() && ~IR04_VAL() && ~IR05_VAL() && ~IR06_VAL() && ~IR07_
  91:ir_array.h    **** 	*/
  92:ir_array.h    **** }
 456               		.loc 4 92 0
 457 0190 2CEA      		ldi r18,lo8(-84)
 458 0192 3DE0      		ldi r19,lo8(13)
 459 0194 A901      		movw r20,r18
 460 0196 481B      		sub r20,r24
 461 0198 590B      		sbc r21,r25
 462 019a CA01      		movw r24,r20
 463               	/* epilogue start */
 464 019c 0895      		ret
 465               		.cfi_endproc
 466               	.LFE15:
 468               	.global	lineSize
 470               	lineSize:
 471               	.LFB16:
  93:ir_array.h    **** 
  94:ir_array.h    **** /*void stableCar(void){
  95:ir_array.h    **** 
  96:ir_array.h    **** 	count++;
  97:ir_array.h    **** 	uint8_t ir_val = IR_ARR_VAL;
  98:ir_array.h    **** 
  99:ir_array.h    **** 	if(count == 200000){
 100:ir_array.h    **** 		putCh(ir_val);
 101:ir_array.h    **** 		count = 0;
 102:ir_array.h    **** 	}
 103:ir_array.h    **** 
 104:ir_array.h    **** 	controlMotor(NEUTRAL);
 105:ir_array.h    **** 	controlMotor(FORWARD);
 106:ir_array.h    **** 
 107:ir_array.h    **** 	if(ir_val == 0x00){
 108:ir_array.h    **** 		controlMotor(STOP);
 109:ir_array.h    **** 	}
 110:ir_array.h    **** 
 111:ir_array.h    **** 	//LEFT
 112:ir_array.h    **** 	if(ir_val == 0x01){
 113:ir_array.h    **** 		controlMotor(LEFT);
 114:ir_array.h    **** 		_delay_ms(100);
 115:ir_array.h    **** 	}
 116:ir_array.h    **** 	
 117:ir_array.h    **** 	if(ir_val == 0x02){
 118:ir_array.h    **** 		controlMotor(LEFT);
 119:ir_array.h    **** 		_delay_ms(10);
 120:ir_array.h    **** 	}
 121:ir_array.h    **** 
 122:ir_array.h    **** 	if(ir_val == 0x04){
 123:ir_array.h    **** 		controlMotor(LEFT);
 124:ir_array.h    **** 		_delay_ms(1);
 125:ir_array.h    **** 	}
 126:ir_array.h    **** 
 127:ir_array.h    **** 	if(ir_val == 0x0F){
 128:ir_array.h    **** 		controlMotor(LEFT);
 129:ir_array.h    **** 		_delay_ms(200);
 130:ir_array.h    **** 	}
 131:ir_array.h    **** 
 132:ir_array.h    **** 	//RIGHT
 133:ir_array.h    **** 	if(ir_val == 0x80){
 134:ir_array.h    **** 		controlMotor(RIGHT);
 135:ir_array.h    **** 		_delay_ms(100);
 136:ir_array.h    **** 	}
 137:ir_array.h    **** 
 138:ir_array.h    **** 	if(ir_val == 0x40){
 139:ir_array.h    **** 		controlMotor(RIGHT);
 140:ir_array.h    **** 		_delay_ms(10);
 141:ir_array.h    **** 	}
 142:ir_array.h    **** 
 143:ir_array.h    **** 	if(ir_val == 0x20){
 144:ir_array.h    **** 		controlMotor(RIGHT);
 145:ir_array.h    **** 		_delay_ms(1);
 146:ir_array.h    **** 	}
 147:ir_array.h    **** 
 148:ir_array.h    **** 	if(ir_val == 0xF0){
 149:ir_array.h    **** 		controlMotor(RIGHT);
 150:ir_array.h    **** 		_delay_ms(200);
 151:ir_array.h    **** 	}
 152:ir_array.h    **** }*/
 153:ir_array.h    **** 
 154:ir_array.h    **** uint8_t lineSize(void){
 472               		.loc 4 154 0
 473               		.cfi_startproc
 474               	/* prologue: function */
 475               	/* frame size = 0 */
 476               	/* stack size = 0 */
 477               	.L__stack_usage = 0
 478               	.LVL27:
 479               	.LBB79:
 155:ir_array.h    **** 	uint8_t size = 0;
 156:ir_array.h    **** 
 157:ir_array.h    **** 	if(~IR01_VAL()) size++;
 480               		.loc 4 157 0
 481 019e 89B1      		in r24,0x9
 482               	.LVL28:
 483               	.LBE79:
 484               	.LBB80:
 158:ir_array.h    **** 	if(~IR02_VAL()) size++;
 485               		.loc 4 158 0
 486 01a0 89B1      		in r24,0x9
 487               	.LVL29:
 488               	.LBE80:
 489               	.LBB81:
 159:ir_array.h    **** 	if(~IR03_VAL()) size++;
 490               		.loc 4 159 0
 491 01a2 89B1      		in r24,0x9
 492               	.LVL30:
 493               	.LBE81:
 494               	.LBB82:
 160:ir_array.h    **** 	if(~IR04_VAL()) size++;
 495               		.loc 4 160 0
 496 01a4 89B1      		in r24,0x9
 497               	.LVL31:
 498               	.LBE82:
 499               	.LBB83:
 161:ir_array.h    **** 	if(~IR05_VAL()) size++;
 500               		.loc 4 161 0
 501 01a6 83B1      		in r24,0x3
 502               	.LVL32:
 503               	.LBE83:
 504               	.LBB84:
 162:ir_array.h    **** 	if(~IR06_VAL()) size++;
 505               		.loc 4 162 0
 506 01a8 83B1      		in r24,0x3
 507               	.LVL33:
 508               	.LBE84:
 509               	.LBB85:
 163:ir_array.h    **** 	if(~IR07_VAL()) size++;
 510               		.loc 4 163 0
 511 01aa 83B1      		in r24,0x3
 512               	.LVL34:
 513               	.LBE85:
 514               	.LBB86:
 164:ir_array.h    **** 	if(~IR08_VAL()) size++;
 515               		.loc 4 164 0
 516 01ac 83B1      		in r24,0x3
 517               	.LVL35:
 518               	.LBE86:
 165:ir_array.h    **** 
 166:ir_array.h    **** 	return size;
 167:ir_array.h    **** }...
 519               		.loc 4 167 0
 520 01ae 88E0      		ldi r24,lo8(8)
 521               	/* epilogue start */
 522 01b0 0895      		ret
 523               		.cfi_endproc
 524               	.LFE16:
 526               	.global	init_SRF05
 528               	init_SRF05:
 529               	.LFB17:
 530               		.file 5 "srf05.h"
   1:srf05.h       **** #ifndef F_CPU
   2:srf05.h       **** #define F_CPU 16000000UL
   3:srf05.h       **** #endif
   4:srf05.h       **** 
   5:srf05.h       **** #include <avr/io.h>
   6:srf05.h       **** #include <avr/interrupt.h>
   7:srf05.h       **** #include <util/delay.h>
   8:srf05.h       **** 
   9:srf05.h       **** #define TRIG 		PD3
  10:srf05.h       **** #define ECHO 		PD2
  11:srf05.h       **** #define SRF05_DDR 	DDRD
  12:srf05.h       **** #define SRF05_PORT 	PORTD
  13:srf05.h       **** #define SRF05_PIN 	PIND
  14:srf05.h       **** 
  15:srf05.h       **** uint16_t distance;
  16:srf05.h       **** 
  17:srf05.h       **** volatile unsigned int mseconds = 0;
  18:srf05.h       **** volatile uint8_t interrupt = 0;
  19:srf05.h       **** 
  20:srf05.h       **** void init_SRF05(void);
  21:srf05.h       **** void SRF05_CalcDistance(void);
  22:srf05.h       **** 
  23:srf05.h       **** void init_SRF05(void){
 531               		.loc 5 23 0
 532               		.cfi_startproc
 533               	/* prologue: function */
 534               	/* frame size = 0 */
 535               	/* stack size = 0 */
 536               	.L__stack_usage = 0
  24:srf05.h       **** 	//CTC mode
  25:srf05.h       **** 	TCCR0A |= (1 << WGM01);
 537               		.loc 5 25 0
 538 01b2 84B5      		in r24,0x24
 539 01b4 8260      		ori r24,lo8(2)
 540 01b6 84BD      		out 0x24,r24
  26:srf05.h       **** 	OCR0A = 19;
 541               		.loc 5 26 0
 542 01b8 83E1      		ldi r24,lo8(19)
 543 01ba 87BD      		out 0x27,r24
  27:srf05.h       **** 
  28:srf05.h       **** 	//COmpare match interrupt enable
  29:srf05.h       **** 	TIMSK0 |= (1 << OCIE0A);
 544               		.loc 5 29 0
 545 01bc EEE6      		ldi r30,lo8(110)
 546 01be F0E0      		ldi r31,0
 547 01c0 8081      		ld r24,Z
 548 01c2 8260      		ori r24,lo8(2)
 549 01c4 8083      		st Z,r24
  30:srf05.h       **** 
  31:srf05.h       **** 	//External interrupt enable
  32:srf05.h       **** 	EIMSK |= (1 << INT0);
 550               		.loc 5 32 0
 551 01c6 E89A      		sbi 0x1d,0
  33:srf05.h       **** 
  34:srf05.h       **** 	SRF05_DDR |= (1 << TRIG);
 552               		.loc 5 34 0
 553 01c8 539A      		sbi 0xa,3
  35:srf05.h       **** 	SRF05_DDR &= ~(1 << ECHO);
 554               		.loc 5 35 0
 555 01ca 5298      		cbi 0xa,2
 556               	/* epilogue start */
  36:srf05.h       **** }
 557               		.loc 5 36 0
 558 01cc 0895      		ret
 559               		.cfi_endproc
 560               	.LFE17:
 562               	.global	SRF05_Start
 564               	SRF05_Start:
 565               	.LFB18:
  37:srf05.h       **** 
  38:srf05.h       **** void SRF05_Start(void){
 566               		.loc 5 38 0
 567               		.cfi_startproc
 568               	/* prologue: function */
 569               	/* frame size = 0 */
 570               	/* stack size = 0 */
 571               	.L__stack_usage = 0
  39:srf05.h       **** 	
  40:srf05.h       **** 	mseconds = 0;
 572               		.loc 5 40 0
 573 01ce 1092 0000 		sts mseconds+1,__zero_reg__
 574 01d2 1092 0000 		sts mseconds,__zero_reg__
  41:srf05.h       **** 	TCNT0 = 0; //Reset timer0
 575               		.loc 5 41 0
 576 01d6 16BC      		out 0x26,__zero_reg__
  42:srf05.h       **** 
  43:srf05.h       **** 	//Trigger for 12us
  44:srf05.h       **** 	SRF05_PORT |= (1 << TRIG);
 577               		.loc 5 44 0
 578 01d8 5B9A      		sbi 0xb,3
 579               	.LVL36:
 580               	.LBB87:
 581               	.LBB88:
 582               		.file 6 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/avr/include/util/delay.h **** #  endif
  42:/usr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/avr/include/util/delay.h **** 
  44:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/avr/include/util/delay.h **** #include <math.h>
  47:/usr/avr/include/util/delay.h **** 
  48:/usr/avr/include/util/delay.h **** /** \file */
  49:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/avr/include/util/delay.h ****     \code
  51:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/avr/include/util/delay.h ****     \endcode
  55:/usr/avr/include/util/delay.h **** 
  56:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/avr/include/util/delay.h ****     used.
  60:/usr/avr/include/util/delay.h **** 
  61:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/avr/include/util/delay.h **** 
  70:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/avr/include/util/delay.h **** 
  79:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** */
  84:/usr/avr/include/util/delay.h **** 
  85:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/avr/include/util/delay.h **** #endif
  89:/usr/avr/include/util/delay.h **** 
  90:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/avr/include/util/delay.h **** 
  97:/usr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/avr/include/util/delay.h **** 
 103:/usr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/avr/include/util/delay.h ****     integer value.
 107:/usr/avr/include/util/delay.h ****  */
 108:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/avr/include/util/delay.h **** #endif
 110:/usr/avr/include/util/delay.h **** 
 111:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/avr/include/util/delay.h **** #endif
 114:/usr/avr/include/util/delay.h **** 
 115:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/avr/include/util/delay.h **** #endif
 120:/usr/avr/include/util/delay.h **** 
 121:/usr/avr/include/util/delay.h **** /**
 122:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/avr/include/util/delay.h **** 
 124:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/avr/include/util/delay.h **** 
 126:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/avr/include/util/delay.h **** 
 131:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/avr/include/util/delay.h **** 
 137:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/avr/include/util/delay.h **** 
 142:/usr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/avr/include/util/delay.h **** 
 147:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/avr/include/util/delay.h ****    respectively.
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h ****    \note
 153:/usr/avr/include/util/delay.h **** 
 154:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h ****  */
 165:/usr/avr/include/util/delay.h **** void
 166:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/avr/include/util/delay.h **** {
 168:/usr/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/avr/include/util/delay.h **** 
 176:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/avr/include/util/delay.h **** 
 179:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/avr/include/util/delay.h **** 
 182:/usr/avr/include/util/delay.h **** 	#else
 183:/usr/avr/include/util/delay.h **** 		//round up by default
 184:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/avr/include/util/delay.h **** 	#endif
 186:/usr/avr/include/util/delay.h **** 
 187:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/avr/include/util/delay.h **** 
 189:/usr/avr/include/util/delay.h **** #else
 190:/usr/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/avr/include/util/delay.h **** 	{
 196:/usr/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/avr/include/util/delay.h **** 		{
 200:/usr/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/avr/include/util/delay.h **** 		}
 204:/usr/avr/include/util/delay.h **** 		return;
 205:/usr/avr/include/util/delay.h **** 	}
 206:/usr/avr/include/util/delay.h **** 	else
 207:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/avr/include/util/delay.h **** #endif
 210:/usr/avr/include/util/delay.h **** }
 211:/usr/avr/include/util/delay.h **** 
 212:/usr/avr/include/util/delay.h **** /**
 213:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/avr/include/util/delay.h **** 
 215:/usr/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/avr/include/util/delay.h **** 
 217:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/avr/include/util/delay.h **** 
 220:/usr/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/avr/include/util/delay.h **** 
 222:/usr/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/avr/include/util/delay.h **** 
 226:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/avr/include/util/delay.h **** 
 231:/usr/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/avr/include/util/delay.h **** 
 236:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/avr/include/util/delay.h ****    respectively.
 240:/usr/avr/include/util/delay.h **** 
 241:/usr/avr/include/util/delay.h ****    \note
 242:/usr/avr/include/util/delay.h **** 
 243:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/avr/include/util/delay.h **** 
 253:/usr/avr/include/util/delay.h ****  */
 254:/usr/avr/include/util/delay.h **** void
 255:/usr/avr/include/util/delay.h **** _delay_us(double __us)
 256:/usr/avr/include/util/delay.h **** {
 257:/usr/avr/include/util/delay.h **** 	double __tmp ;
 258:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 262:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:/usr/avr/include/util/delay.h **** 
 265:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/avr/include/util/delay.h **** 
 268:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/avr/include/util/delay.h **** 
 271:/usr/avr/include/util/delay.h **** 	#else
 272:/usr/avr/include/util/delay.h **** 		//round up by default
 273:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:/usr/avr/include/util/delay.h **** 	#endif
 275:/usr/avr/include/util/delay.h **** 
 276:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 583               		.loc 6 276 0
 584 01da 80E4      		ldi r24,lo8(64)
 585 01dc 8A95      	1:	dec r24
 586 01de 01F4      		brne 1b
 587               	.LVL37:
 588               	.LBE88:
 589               	.LBE87:
  45:srf05.h       **** 	_delay_us(12);
  46:srf05.h       **** 	SRF05_PORT &= ~(1 << TRIG);
 590               		.loc 5 46 0
 591 01e0 5B98      		cbi 0xb,3
  47:srf05.h       **** 
  48:srf05.h       **** 	//Interrupt on rising edge
  49:srf05.h       **** 	EICRA = (1 << ISC01) | (1 << ISC00);
 592               		.loc 5 49 0
 593 01e2 83E0      		ldi r24,lo8(3)
 594 01e4 8093 6900 		sts 105,r24
  50:srf05.h       **** 
  51:srf05.h       **** 	sei();
 595               		.loc 5 51 0
 596               	/* #APP */
 597               	 ;  51 "srf05.h" 1
 598 01e8 7894      		sei
 599               	 ;  0 "" 2
 600               	/* epilogue start */
  52:srf05.h       **** }
 601               		.loc 5 52 0
 602               	/* #NOAPP */
 603 01ea 0895      		ret
 604               		.cfi_endproc
 605               	.LFE18:
 607               	.global	__vector_1
 609               	__vector_1:
 610               	.LFB19:
  53:srf05.h       **** 
  54:srf05.h       **** ISR(INT0_vect){
 611               		.loc 5 54 0
 612               		.cfi_startproc
 613 01ec 1F92      		push r1
 614               	.LCFI0:
 615               		.cfi_def_cfa_offset 3
 616               		.cfi_offset 1, -2
 617 01ee 0F92      		push r0
 618               	.LCFI1:
 619               		.cfi_def_cfa_offset 4
 620               		.cfi_offset 0, -3
 621 01f0 0FB6      		in r0,__SREG__
 622 01f2 0F92      		push r0
 623 01f4 1124      		clr __zero_reg__
 624 01f6 2F93      		push r18
 625               	.LCFI2:
 626               		.cfi_def_cfa_offset 5
 627               		.cfi_offset 18, -4
 628 01f8 3F93      		push r19
 629               	.LCFI3:
 630               		.cfi_def_cfa_offset 6
 631               		.cfi_offset 19, -5
 632 01fa 4F93      		push r20
 633               	.LCFI4:
 634               		.cfi_def_cfa_offset 7
 635               		.cfi_offset 20, -6
 636 01fc 5F93      		push r21
 637               	.LCFI5:
 638               		.cfi_def_cfa_offset 8
 639               		.cfi_offset 21, -7
 640 01fe 6F93      		push r22
 641               	.LCFI6:
 642               		.cfi_def_cfa_offset 9
 643               		.cfi_offset 22, -8
 644 0200 7F93      		push r23
 645               	.LCFI7:
 646               		.cfi_def_cfa_offset 10
 647               		.cfi_offset 23, -9
 648 0202 8F93      		push r24
 649               	.LCFI8:
 650               		.cfi_def_cfa_offset 11
 651               		.cfi_offset 24, -10
 652 0204 9F93      		push r25
 653               	.LCFI9:
 654               		.cfi_def_cfa_offset 12
 655               		.cfi_offset 25, -11
 656 0206 AF93      		push r26
 657               	.LCFI10:
 658               		.cfi_def_cfa_offset 13
 659               		.cfi_offset 26, -12
 660 0208 BF93      		push r27
 661               	.LCFI11:
 662               		.cfi_def_cfa_offset 14
 663               		.cfi_offset 27, -13
 664 020a EF93      		push r30
 665               	.LCFI12:
 666               		.cfi_def_cfa_offset 15
 667               		.cfi_offset 30, -14
 668 020c FF93      		push r31
 669               	.LCFI13:
 670               		.cfi_def_cfa_offset 16
 671               		.cfi_offset 31, -15
 672               	/* prologue: Signal */
 673               	/* frame size = 0 */
 674               	/* stack size = 15 */
 675               	.L__stack_usage = 15
  55:srf05.h       **** 
  56:srf05.h       **** 	if(interrupt == 0){
 676               		.loc 5 56 0
 677 020e 8091 0000 		lds r24,interrupt
 678 0212 8111      		cpse r24,__zero_reg__
 679 0214 00C0      		rjmp .L39
  57:srf05.h       **** 		//Start Timer
  58:srf05.h       **** 		TCCR0B |= (1 << CS01);
 680               		.loc 5 58 0
 681 0216 85B5      		in r24,0x25
 682 0218 8260      		ori r24,lo8(2)
 683 021a 85BD      		out 0x25,r24
  59:srf05.h       **** 
  60:srf05.h       **** 		//Interrupt on falling edge
  61:srf05.h       **** 		EICRA = (1 << ISC01);
 684               		.loc 5 61 0
 685 021c 82E0      		ldi r24,lo8(2)
 686 021e 8093 6900 		sts 105,r24
  62:srf05.h       **** 
  63:srf05.h       **** 		interrupt = 1;
 687               		.loc 5 63 0
 688 0222 81E0      		ldi r24,lo8(1)
 689 0224 8093 0000 		sts interrupt,r24
 690               	.L38:
 691               	/* epilogue start */
  64:srf05.h       **** 	}else{
  65:srf05.h       **** 		//Stop Timer
  66:srf05.h       **** 		TCCR0B &= ~(1 << CS01);
  67:srf05.h       **** 
  68:srf05.h       **** 		interrupt = 0;
  69:srf05.h       **** 		distance = mseconds / 58;
  70:srf05.h       **** 		SRF05_Start();
  71:srf05.h       **** 	}
  72:srf05.h       **** }
 692               		.loc 5 72 0
 693 0228 FF91      		pop r31
 694 022a EF91      		pop r30
 695 022c BF91      		pop r27
 696 022e AF91      		pop r26
 697 0230 9F91      		pop r25
 698 0232 8F91      		pop r24
 699 0234 7F91      		pop r23
 700 0236 6F91      		pop r22
 701 0238 5F91      		pop r21
 702 023a 4F91      		pop r20
 703 023c 3F91      		pop r19
 704 023e 2F91      		pop r18
 705 0240 0F90      		pop r0
 706 0242 0FBE      		out __SREG__,r0
 707 0244 0F90      		pop r0
 708 0246 1F90      		pop r1
 709 0248 1895      		reti
 710               	.L39:
  66:srf05.h       **** 
 711               		.loc 5 66 0
 712 024a 85B5      		in r24,0x25
 713 024c 8D7F      		andi r24,lo8(-3)
 714 024e 85BD      		out 0x25,r24
  68:srf05.h       **** 		distance = mseconds / 58;
 715               		.loc 5 68 0
 716 0250 1092 0000 		sts interrupt,__zero_reg__
  69:srf05.h       **** 		SRF05_Start();
 717               		.loc 5 69 0
 718 0254 8091 0000 		lds r24,mseconds
 719 0258 9091 0000 		lds r25,mseconds+1
 720 025c 6AE3      		ldi r22,lo8(58)
 721 025e 70E0      		ldi r23,0
 722 0260 0E94 0000 		call __udivmodhi4
 723 0264 7093 0000 		sts distance+1,r23
 724 0268 6093 0000 		sts distance,r22
  70:srf05.h       **** 	}
 725               		.loc 5 70 0
 726 026c 0E94 0000 		call SRF05_Start
 727               	.LVL38:
 728               		.loc 5 72 0
 729 0270 00C0      		rjmp .L38
 730               		.cfi_endproc
 731               	.LFE19:
 733               	.global	__vector_14
 735               	__vector_14:
 736               	.LFB20:
  73:srf05.h       **** 
  74:srf05.h       **** ISR(TIMER0_COMPA_vect){
 737               		.loc 5 74 0
 738               		.cfi_startproc
 739 0272 1F92      		push r1
 740               	.LCFI14:
 741               		.cfi_def_cfa_offset 3
 742               		.cfi_offset 1, -2
 743 0274 0F92      		push r0
 744               	.LCFI15:
 745               		.cfi_def_cfa_offset 4
 746               		.cfi_offset 0, -3
 747 0276 0FB6      		in r0,__SREG__
 748 0278 0F92      		push r0
 749 027a 1124      		clr __zero_reg__
 750 027c 8F93      		push r24
 751               	.LCFI16:
 752               		.cfi_def_cfa_offset 5
 753               		.cfi_offset 24, -4
 754 027e 9F93      		push r25
 755               	.LCFI17:
 756               		.cfi_def_cfa_offset 6
 757               		.cfi_offset 25, -5
 758               	/* prologue: Signal */
 759               	/* frame size = 0 */
 760               	/* stack size = 5 */
 761               	.L__stack_usage = 5
  75:srf05.h       **** 	mseconds += 10;
 762               		.loc 5 75 0
 763 0280 8091 0000 		lds r24,mseconds
 764 0284 9091 0000 		lds r25,mseconds+1
 765 0288 0A96      		adiw r24,10
 766 028a 9093 0000 		sts mseconds+1,r25
 767 028e 8093 0000 		sts mseconds,r24
 768               	/* epilogue start */
  76:srf05.h       **** }...
 769               		.loc 5 76 0
 770 0292 9F91      		pop r25
 771 0294 8F91      		pop r24
 772 0296 0F90      		pop r0
 773 0298 0FBE      		out __SREG__,r0
 774 029a 0F90      		pop r0
 775 029c 1F90      		pop r1
 776 029e 1895      		reti
 777               		.cfi_endproc
 778               	.LFE20:
 780               	.global	setupMotor
 782               	setupMotor:
 783               	.LFB21:
 784               		.file 7 "motor_control.h"
   1:motor_control.h **** #define MOTOR_DDR	DDRC
   2:motor_control.h **** #define MOTOR_PORT	PORTC
   3:motor_control.h **** 
   4:motor_control.h **** #define MOTOR_RIGHT_FWD_PIN		PC0
   5:motor_control.h **** #define MOTOR_RIGHT_REV_PIN		PC1
   6:motor_control.h **** #define MOTOR_LEFT_FWD_PIN		PC2
   7:motor_control.h **** #define MOTOR_LEFT_REV_PIN		PC3
   8:motor_control.h **** 
   9:motor_control.h **** #define FORWARD_MODE() { MOTOR_PORT |= (1 << MOTOR_RIGHT_FWD_PIN) | (1 << MOTOR_LEFT_FWD_PIN); MOTO
  10:motor_control.h **** #define REVERSE_MODE() { MOTOR_PORT |= (1 << MOTOR_RIGHT_REV_PIN) | (1 << MOTOR_LEFT_REV_PIN); MOTO
  11:motor_control.h **** #define RIGHT_MODE()   { MOTOR_PORT |= (1 << MOTOR_RIGHT_REV_PIN) | (1 << MOTOR_LEFT_FWD_PIN); MOTO
  12:motor_control.h **** #define LEFT_MODE()    { MOTOR_PORT |= (1 << MOTOR_RIGHT_FWD_PIN) | (1 << MOTOR_LEFT_REV_PIN); MOTO
  13:motor_control.h **** 
  14:motor_control.h **** #define Kp 27
  15:motor_control.h **** #define Ki 0
  16:motor_control.h **** #define Kd 20
  17:motor_control.h **** 
  18:motor_control.h **** #define MAX_SPEED 2000
  19:motor_control.h **** #define RIGHT_MAX 1500 //Maximum Speed
  20:motor_control.h **** #define LEFT_MAX 1500 //Maximum Speed
  21:motor_control.h **** #define RIGHT_NORMAL_SPEED 1300 //Normal Speed
  22:motor_control.h **** #define LEFT_NORMAL_SPEED 1300 //Normal Speed
  23:motor_control.h **** 
  24:motor_control.h **** #include "pwm.h"
  25:motor_control.h **** #include "ir_array.h"
  26:motor_control.h **** #include "srf05.h"
  27:motor_control.h **** 
  28:motor_control.h **** uint32_t count = 0;
  29:motor_control.h **** uint8_t count2 = 0;
  30:motor_control.h **** int P = 0, I = 0, D = 0, PID = 0;
  31:motor_control.h **** int right_motor_pwm = 0, left_motor_pwm = 0;
  32:motor_control.h **** //uint8_t channelA_status = FORWARD, channelB_status = FORWARD, left_status = FALSE, right_status=F
  33:motor_control.h **** int previous_error = 0;
  34:motor_control.h **** 
  35:motor_control.h **** void controlMotor(void);
  36:motor_control.h **** void setupMotor(void);
  37:motor_control.h **** 
  38:motor_control.h **** void setupMotor(void){
 785               		.loc 7 38 0
 786               		.cfi_startproc
 787               	/* prologue: function */
 788               	/* frame size = 0 */
 789               	/* stack size = 0 */
 790               	.L__stack_usage = 0
  39:motor_control.h **** 	MOTOR_DDR = 0x0F;
 791               		.loc 7 39 0
 792 02a0 8FE0      		ldi r24,lo8(15)
 793 02a2 87B9      		out 0x7,r24
 794               	.LVL39:
 795               	.LBB89:
 796               	.LBB90:
  20:pwm.h         **** 	ICR1 = period;
 797               		.loc 2 20 0
 798 02a4 E6E8      		ldi r30,lo8(-122)
 799 02a6 F0E0      		ldi r31,0
 800 02a8 80ED      		ldi r24,lo8(-48)
 801 02aa 97E0      		ldi r25,lo8(7)
 802 02ac 9183      		std Z+1,r25
 803 02ae 8083      		st Z,r24
  21:pwm.h         **** 	(channel == CH_B) ? (OCR1B = onTime) : (OCR1A = onTime);
 804               		.loc 2 21 0
 805 02b0 1092 8900 		sts 136+1,__zero_reg__
 806 02b4 1092 8800 		sts 136,__zero_reg__
 807               	.LVL40:
 808               	.LBE90:
 809               	.LBE89:
 810               	.LBB91:
 811               	.LBB92:
  20:pwm.h         **** 	ICR1 = period;
 812               		.loc 2 20 0
 813 02b8 9183      		std Z+1,r25
 814 02ba 8083      		st Z,r24
  21:pwm.h         **** 	(channel == CH_B) ? (OCR1B = onTime) : (OCR1A = onTime);
 815               		.loc 2 21 0
 816 02bc 1092 8B00 		sts 138+1,__zero_reg__
 817 02c0 1092 8A00 		sts 138,__zero_reg__
 818               	.LVL41:
 819               	/* epilogue start */
 820               	.LBE92:
 821               	.LBE91:
  40:motor_control.h **** 
  41:motor_control.h **** 	pwm(CH_A, 0, MAX_SPEED);
  42:motor_control.h **** 	pwm(CH_B, 0, MAX_SPEED);
  43:motor_control.h **** 
  44:motor_control.h **** 	//controlMotor(NEUTRAL);
  45:motor_control.h **** }
 822               		.loc 7 45 0
 823 02c4 0895      		ret
 824               		.cfi_endproc
 825               	.LFE21:
 827               	.global	controlMotor
 829               	controlMotor:
 830               	.LFB22:
  46:motor_control.h **** 
  47:motor_control.h **** void controlMotor(){
 831               		.loc 7 47 0
 832               		.cfi_startproc
 833 02c6 CF93      		push r28
 834               	.LCFI18:
 835               		.cfi_def_cfa_offset 3
 836               		.cfi_offset 28, -2
 837               	/* prologue: function */
 838               	/* frame size = 0 */
 839               	/* stack size = 1 */
 840               	.L__stack_usage = 1
  48:motor_control.h **** 
  49:motor_control.h **** 	count++;
 841               		.loc 7 49 0
 842 02c8 4091 0000 		lds r20,count
 843 02cc 5091 0000 		lds r21,count+1
 844 02d0 6091 0000 		lds r22,count+2
 845 02d4 7091 0000 		lds r23,count+3
 846 02d8 4F5F      		subi r20,-1
 847 02da 5F4F      		sbci r21,-1
 848 02dc 6F4F      		sbci r22,-1
 849 02de 7F4F      		sbci r23,-1
 850 02e0 4093 0000 		sts count,r20
 851 02e4 5093 0000 		sts count+1,r21
 852 02e8 6093 0000 		sts count+2,r22
 853 02ec 7093 0000 		sts count+3,r23
 854               	.LBB93:
  50:motor_control.h **** 	uint8_t ir_val = IR_ARR_VAL;
 855               		.loc 7 50 0
 856 02f0 C9B1      		in r28,0x9
 857 02f2 C295      		swap r28
 858 02f4 C170      		andi r28,1
 859               	.LVL42:
 860               	.LBE93:
 861               	.LBB94:
 862 02f6 4D99      		sbic 0x9,5
 863 02f8 00C0      		rjmp .L60
 864 02fa 80E0      		ldi r24,0
 865               	.L44:
 866               	.LVL43:
 867               	.LBE94:
 868               		.loc 7 50 0 is_stmt 0 discriminator 4
 869 02fc C82B      		or r28,r24
 870               	.LVL44:
 871               	.LBB95:
 872 02fe 4E99      		sbic 0x9,6
 873 0300 00C0      		rjmp .L61
 874               		.loc 7 50 0
 875 0302 80E0      		ldi r24,0
 876               	.LVL45:
 877               	.L45:
 878               	.LBE95:
 879               		.loc 7 50 0 discriminator 8
 880 0304 C82B      		or r28,r24
 881               	.LBB96:
 882 0306 4F99      		sbic 0x9,7
 883 0308 00C0      		rjmp .L62
 884               		.loc 7 50 0
 885 030a 80E0      		ldi r24,0
 886               	.LVL46:
 887               	.L46:
 888               	.LBE96:
 889               		.loc 7 50 0 discriminator 12
 890 030c C82B      		or r28,r24
 891               	.LBB97:
 892 030e 1D99      		sbic 0x3,5
 893 0310 00C0      		rjmp .L63
 894               		.loc 7 50 0
 895 0312 80E0      		ldi r24,0
 896               	.LVL47:
 897               	.L47:
 898               	.LBE97:
 899               		.loc 7 50 0 discriminator 16
 900 0314 C82B      		or r28,r24
 901               	.LBB98:
 902 0316 1B99      		sbic 0x3,3
 903 0318 00C0      		rjmp .L64
 904               		.loc 7 50 0
 905 031a 80E0      		ldi r24,0
 906               	.LVL48:
 907               	.L48:
 908               	.LBE98:
 909               		.loc 7 50 0 discriminator 20
 910 031c C82B      		or r28,r24
 911               	.LBB99:
 912 031e 1C99      		sbic 0x3,4
 913 0320 00C0      		rjmp .L65
 914               		.loc 7 50 0
 915 0322 80E0      		ldi r24,0
 916               	.LVL49:
 917               	.L49:
 918               	.LBE99:
 919               		.loc 7 50 0 discriminator 24
 920 0324 C82B      		or r28,r24
 921               	.LBB100:
 922 0326 1899      		sbic 0x3,0
 923 0328 00C0      		rjmp .L66
 924               		.loc 7 50 0
 925 032a 80E0      		ldi r24,0
 926               	.LVL50:
 927               	.L50:
 928               	.LBE100:
 929               		.loc 7 50 0 discriminator 28
 930 032c C82B      		or r28,r24
 931               	.LVL51:
  51:motor_control.h **** 
  52:motor_control.h **** 	if(count == 7000){
 932               		.loc 7 52 0 is_stmt 1 discriminator 28
 933 032e 4835      		cpi r20,88
 934 0330 5B41      		sbci r21,27
 935 0332 6105      		cpc r22,__zero_reg__
 936 0334 7105      		cpc r23,__zero_reg__
 937 0336 01F4      		brne .L51
  53:motor_control.h **** 		putCh(read_ADC());
 938               		.loc 7 53 0
 939 0338 0E94 0000 		call read_ADC
 940               	.LVL52:
 941 033c 0E94 0000 		call putCh
 942               	.LVL53:
  54:motor_control.h **** 		count = 0;
 943               		.loc 7 54 0
 944 0340 1092 0000 		sts count,__zero_reg__
 945 0344 1092 0000 		sts count+1,__zero_reg__
 946 0348 1092 0000 		sts count+2,__zero_reg__
 947 034c 1092 0000 		sts count+3,__zero_reg__
 948               	.L51:
  55:motor_control.h **** 	}
  56:motor_control.h **** 
  57:motor_control.h **** 	int error = getError();
 949               		.loc 7 57 0
 950 0350 0E94 0000 		call getError
 951               	.LVL54:
  58:motor_control.h **** 	P = error;
 952               		.loc 7 58 0
 953 0354 9093 0000 		sts P+1,r25
 954 0358 8093 0000 		sts P,r24
  59:motor_control.h **** 	I +=  error;
 955               		.loc 7 59 0
 956 035c 2091 0000 		lds r18,I
 957 0360 3091 0000 		lds r19,I+1
 958 0364 280F      		add r18,r24
 959 0366 391F      		adc r19,r25
 960 0368 3093 0000 		sts I+1,r19
 961 036c 2093 0000 		sts I,r18
  60:motor_control.h **** 	D = error - previous_error;
 962               		.loc 7 60 0
 963 0370 2091 0000 		lds r18,previous_error
 964 0374 3091 0000 		lds r19,previous_error+1
 965 0378 AC01      		movw r20,r24
 966 037a 421B      		sub r20,r18
 967 037c 530B      		sbc r21,r19
 968 037e 9A01      		movw r18,r20
 969 0380 5093 0000 		sts D+1,r21
 970 0384 4093 0000 		sts D,r20
  61:motor_control.h **** 	previous_error = error;
 971               		.loc 7 61 0
 972 0388 9093 0000 		sts previous_error+1,r25
 973 038c 8093 0000 		sts previous_error,r24
  62:motor_control.h **** 
  63:motor_control.h **** 	PID = Kp * P + Ki * I + Kd * D;
 974               		.loc 7 63 0
 975 0390 6BE1      		ldi r22,lo8(27)
 976 0392 689F      		mul r22,r24
 977 0394 A001      		movw r20,r0
 978 0396 699F      		mul r22,r25
 979 0398 500D      		add r21,r0
 980 039a 1124      		clr __zero_reg__
 981 039c E4E1      		ldi r30,lo8(20)
 982 039e E29F      		mul r30,r18
 983 03a0 B001      		movw r22,r0
 984 03a2 E39F      		mul r30,r19
 985 03a4 700D      		add r23,r0
 986 03a6 1124      		clr __zero_reg__
 987 03a8 460F      		add r20,r22
 988 03aa 571F      		adc r21,r23
 989 03ac 5093 0000 		sts PID+1,r21
 990 03b0 4093 0000 		sts PID,r20
  64:motor_control.h **** 
  65:motor_control.h **** 	right_motor_pwm = RIGHT_NORMAL_SPEED + PID;
 991               		.loc 7 65 0
 992 03b4 9A01      		movw r18,r20
 993 03b6 2C5E      		subi r18,-20
 994 03b8 3A4F      		sbci r19,-6
 995 03ba 3093 0000 		sts right_motor_pwm+1,r19
 996 03be 2093 0000 		sts right_motor_pwm,r18
  66:motor_control.h **** 	left_motor_pwm = LEFT_NORMAL_SPEED - PID;
 997               		.loc 7 66 0
 998 03c2 24E1      		ldi r18,lo8(20)
 999 03c4 35E0      		ldi r19,lo8(5)
 1000 03c6 B901      		movw r22,r18
 1001 03c8 641B      		sub r22,r20
 1002 03ca 750B      		sbc r23,r21
 1003 03cc 7093 0000 		sts left_motor_pwm+1,r23
 1004 03d0 6093 0000 		sts left_motor_pwm,r22
  67:motor_control.h **** 
  68:motor_control.h **** 	FORWARD_MODE();
 1005               		.loc 7 68 0
 1006 03d4 48B1      		in r20,0x8
 1007 03d6 4560      		ori r20,lo8(5)
 1008 03d8 48B9      		out 0x8,r20
 1009 03da 48B1      		in r20,0x8
 1010 03dc 457F      		andi r20,lo8(-11)
 1011 03de 48B9      		out 0x8,r20
  69:motor_control.h **** 
  70:motor_control.h **** 	if(ir_val == 0x00){
 1012               		.loc 7 70 0
 1013 03e0 C111      		cpse r28,__zero_reg__
 1014 03e2 00C0      		rjmp .L52
  71:motor_control.h **** 		if(error > 1000 && count2 <= 5){
 1015               		.loc 7 71 0
 1016 03e4 893E      		cpi r24,-23
 1017 03e6 73E0      		ldi r23,3
 1018 03e8 9707      		cpc r25,r23
 1019 03ea 04F4      		brge .+2
 1020 03ec 00C0      		rjmp .L53
 1021               		.loc 7 71 0 is_stmt 0 discriminator 1
 1022 03ee 8091 0000 		lds r24,count2
 1023               	.LVL55:
 1024 03f2 8630      		cpi r24,lo8(6)
 1025 03f4 00F0      		brlo .+2
 1026 03f6 00C0      		rjmp .L54
  72:motor_control.h **** 			REVERSE_MODE();
 1027               		.loc 7 72 0 is_stmt 1
 1028 03f8 88B1      		in r24,0x8
 1029 03fa 8A60      		ori r24,lo8(10)
 1030 03fc 88B9      		out 0x8,r24
 1031 03fe 88B1      		in r24,0x8
 1032 0400 8A7F      		andi r24,lo8(-6)
 1033 0402 88B9      		out 0x8,r24
 1034               	.LVL56:
 1035               	.LBB101:
 1036               	.LBB102:
  20:pwm.h         **** 	ICR1 = period;
 1037               		.loc 2 20 0
 1038 0404 80ED      		ldi r24,lo8(-48)
 1039 0406 97E0      		ldi r25,lo8(7)
 1040 0408 9093 8700 		sts 134+1,r25
 1041 040c 8093 8600 		sts 134,r24
  21:pwm.h         **** 	(channel == CH_B) ? (OCR1B = onTime) : (OCR1A = onTime);
 1042               		.loc 2 21 0
 1043 0410 3093 8900 		sts 136+1,r19
 1044 0414 2093 8800 		sts 136,r18
 1045               	.LVL57:
 1046               	.LBE102:
 1047               	.LBE101:
 1048               	.LBB103:
 1049               	.LBB104:
  20:pwm.h         **** 	ICR1 = period;
 1050               		.loc 2 20 0
 1051 0418 9093 8700 		sts 134+1,r25
 1052 041c 8093 8600 		sts 134,r24
  21:pwm.h         **** 	(channel == CH_B) ? (OCR1B = onTime) : (OCR1A = onTime);
 1053               		.loc 2 21 0
 1054 0420 3093 8B00 		sts 138+1,r19
 1055 0424 2093 8A00 		sts 138,r18
 1056               	.LVL58:
 1057               	.LBE104:
 1058               	.LBE103:
 1059               	.LBB105:
 1060               	.LBB106:
 187:/usr/avr/include/util/delay.h **** 
 1061               		.loc 6 187 0
 1062 0428 4FEF      		ldi r20,lo8(319999)
 1063 042a 51EE      		ldi r21,hi8(319999)
 1064 042c 64E0      		ldi r22,hlo8(319999)
 1065 042e 4150      	1:	subi r20,1
 1066 0430 5040      		sbci r21,0
 1067 0432 6040      		sbci r22,0
 1068 0434 01F4      		brne 1b
 1069 0436 00C0      		rjmp .
 1070 0438 0000      		nop
 1071               	.LVL59:
 1072               	.LBE106:
 1073               	.LBE105:
  73:motor_control.h **** 			pwm(CH_A, RIGHT_NORMAL_SPEED, MAX_SPEED);
  74:motor_control.h **** 			pwm(CH_B, LEFT_NORMAL_SPEED, MAX_SPEED);
  75:motor_control.h **** 			_delay_ms(100);
  76:motor_control.h **** 			FORWARD_MODE();
 1074               		.loc 7 76 0
 1075 043a 48B1      		in r20,0x8
 1076 043c 4560      		ori r20,lo8(5)
 1077 043e 48B9      		out 0x8,r20
 1078 0440 48B1      		in r20,0x8
 1079 0442 457F      		andi r20,lo8(-11)
 1080 0444 48B9      		out 0x8,r20
 1081               	.LVL60:
 1082               	.LBB107:
 1083               	.LBB108:
  20:pwm.h         **** 	ICR1 = period;
 1084               		.loc 2 20 0
 1085 0446 9093 8700 		sts 134+1,r25
 1086 044a 8093 8600 		sts 134,r24
  21:pwm.h         **** 	(channel == CH_B) ? (OCR1B = onTime) : (OCR1A = onTime);
 1087               		.loc 2 21 0
 1088 044e 4AE8      		ldi r20,lo8(-118)
 1089 0450 52E0      		ldi r21,lo8(2)
 1090 0452 5093 8900 		sts 136+1,r21
 1091 0456 4093 8800 		sts 136,r20
 1092               	.LVL61:
 1093               	.LBE108:
 1094               	.LBE107:
 1095               	.LBB109:
 1096               	.LBB110:
  20:pwm.h         **** 	ICR1 = period;
 1097               		.loc 2 20 0
 1098 045a 9093 8700 		sts 134+1,r25
 1099 045e 8093 8600 		sts 134,r24
  21:pwm.h         **** 	(channel == CH_B) ? (OCR1B = onTime) : (OCR1A = onTime);
 1100               		.loc 2 21 0
 1101 0462 3093 8B00 		sts 138+1,r19
 1102 0466 2093 8A00 		sts 138,r18
 1103               	.LVL62:
 1104               	.LBE110:
 1105               	.LBE109:
 1106               	.LBB111:
 1107               	.LBB112:
 187:/usr/avr/include/util/delay.h **** 
 1108               		.loc 6 187 0
 1109 046a 8FE3      		ldi r24,lo8(-25537)
 1110 046c 9CE9      		ldi r25,hi8(-25537)
 1111 046e 0197      	1:	sbiw r24,1
 1112 0470 01F4      		brne 1b
 1113               	.LVL63:
 1114               	.L67:
 1115               	.LBE112:
 1116               	.LBE111:
 1117               	.LBB113:
 1118               	.LBB114:
 1119 0472 00C0      		rjmp .
 1120 0474 0000      		nop
 1121               	.LBE114:
 1122               	.LBE113:
  77:motor_control.h **** 			pwm(CH_A, RIGHT_NORMAL_SPEED/2, MAX_SPEED);
  78:motor_control.h **** 			pwm(CH_B, LEFT_NORMAL_SPEED, MAX_SPEED);
  79:motor_control.h **** 			_delay_ms(10);
  80:motor_control.h **** 			count2++;
  81:motor_control.h **** 		}else if(error < -1000 && count2 <= 5){
  82:motor_control.h **** 			REVERSE_MODE();
  83:motor_control.h **** 			pwm(CH_A, RIGHT_NORMAL_SPEED, MAX_SPEED);
  84:motor_control.h **** 			pwm(CH_B, LEFT_NORMAL_SPEED, MAX_SPEED);
  85:motor_control.h **** 			_delay_ms(1000);
  86:motor_control.h **** 			FORWARD_MODE();
  87:motor_control.h **** 			pwm(CH_A, RIGHT_NORMAL_SPEED, MAX_SPEED);
  88:motor_control.h **** 			pwm(CH_B, LEFT_NORMAL_SPEED/2, MAX_SPEED);
  89:motor_control.h **** 			_delay_ms(100);
  90:motor_control.h **** 			count2++;
 1123               		.loc 7 90 0
 1124 0476 8091 0000 		lds r24,count2
 1125 047a 8F5F      		subi r24,lo8(-(1))
 1126 047c 8093 0000 		sts count2,r24
 1127               	.L43:
 1128               	/* epilogue start */
  91:motor_control.h **** 		}else{
  92:motor_control.h **** 			pwm(CH_A, 0, MAX_SPEED);
  93:motor_control.h **** 			pwm(CH_B, 0, MAX_SPEED);
  94:motor_control.h **** 		}
  95:motor_control.h **** 
  96:motor_control.h **** 		return;
  97:motor_control.h **** 	}
  98:motor_control.h **** 
  99:motor_control.h **** 	if(right_motor_pwm > RIGHT_MAX)
 100:motor_control.h **** 		right_motor_pwm = RIGHT_MAX;
 101:motor_control.h **** 
 102:motor_control.h **** 	if(left_motor_pwm > LEFT_MAX)
 103:motor_control.h **** 		left_motor_pwm = LEFT_MAX;
 104:motor_control.h **** 
 105:motor_control.h **** 	if(right_motor_pwm < 0)
 106:motor_control.h **** 		right_motor_pwm = 0;
 107:motor_control.h **** 
 108:motor_control.h **** 	if(left_motor_pwm < 0)
 109:motor_control.h **** 		left_motor_pwm = 0;
 110:motor_control.h **** 
 111:motor_control.h **** 	count2 = 0;
 112:motor_control.h **** 
 113:motor_control.h **** 	pwm(CH_A, right_motor_pwm, MAX_SPEED);
 114:motor_control.h **** 	pwm(CH_B, left_motor_pwm, MAX_SPEED);
 115:motor_control.h **** 	/*switch(status){
 116:motor_control.h **** 		case FORWARD:
 117:motor_control.h **** 			if(channelA_status == FORWARD && channelB_status == FORWARD){
 118:motor_control.h **** 				(channelA == MAX_SPEED) ? (channelA = MAX_SPEED) : (channelA += SPEED_INCREASE_RATE);
 119:motor_control.h **** 				channelB = channelA;
 120:motor_control.h **** 			}else if(channelA_status == REVERSE && channelB_status == REVERSE){
 121:motor_control.h **** 				if(channelA > MIN_PWM_SPEED){
 122:motor_control.h **** 					channelA -= BREAK_RATE;
 123:motor_control.h **** 					channelB = channelA;
 124:motor_control.h **** 				}else{
 125:motor_control.h **** 					FORWARD_MODE();
 126:motor_control.h **** 					channelA_status = FORWARD;
 127:motor_control.h **** 					channelB_status = FORWARD;
 128:motor_control.h **** 				}
 129:motor_control.h **** 			}
 130:motor_control.h **** 			break;
 131:motor_control.h **** 		
 132:motor_control.h **** 		case REVERSE:
 133:motor_control.h **** 			if(channelA_status == REVERSE && channelB_status == REVERSE){
 134:motor_control.h **** 				(channelA == MAX_SPEED) ? (channelA = MAX_SPEED) : (channelA += SPEED_INCREASE_RATE);
 135:motor_control.h **** 				channelB = channelA;
 136:motor_control.h **** 			}else if(channelA_status == FORWARD && channelB_status == FORWARD){
 137:motor_control.h **** 				if(channelA > MIN_PWM_SPEED){
 138:motor_control.h **** 					channelA -= BREAK_RATE;
 139:motor_control.h **** 					channelB = channelA;
 140:motor_control.h **** 				}else{
 141:motor_control.h **** 					REVERSE_MODE();
 142:motor_control.h **** 					channelA_status = REVERSE;
 143:motor_control.h **** 					channelB_status = REVERSE;
 144:motor_control.h **** 				}
 145:motor_control.h **** 			}
 146:motor_control.h **** 			break;
 147:motor_control.h **** 		
 148:motor_control.h **** 		case STOP:
 149:motor_control.h **** 			MOTOR_PORT = 0x00;
 150:motor_control.h **** 			channelA = 0x00;
 151:motor_control.h **** 			channelB = 0x00;
 152:motor_control.h **** 			break;
 153:motor_control.h **** 
 154:motor_control.h **** 		case NEUTRAL:
 155:motor_control.h **** 			if(channelA > MIN_PWM_SPEED){
 156:motor_control.h **** 				channelA -= SPEED_DECREASE_RATE;
 157:motor_control.h **** 				channelB = channelA;
 158:motor_control.h **** 			}
 159:motor_control.h **** 
 160:motor_control.h **** 			if(channelB_status == FORWARD && channelB_status == FORWARD){
 161:motor_control.h **** 				FORWARD_MODE();
 162:motor_control.h **** 			}
 163:motor_control.h **** 			else{
 164:motor_control.h **** 				REVERSE_MODE();
 165:motor_control.h **** 			}
 166:motor_control.h **** 
 167:motor_control.h **** 			if(left_status || right_status){
 168:motor_control.h **** 				channelA = 0x00;
 169:motor_control.h **** 				channelB = 0x00;
 170:motor_control.h **** 				left_status = FALSE;
 171:motor_control.h **** 				right_status = FALSE;
 172:motor_control.h **** 			}
 173:motor_control.h **** 			break;
 174:motor_control.h **** 
 175:motor_control.h **** 		case RIGHT:
 176:motor_control.h **** 			//RIGHT_MODE();
 177:motor_control.h **** 			if(channelA < MIN_PWM_SPEED){
 178:motor_control.h **** 				left_status = FALSE;
 179:motor_control.h **** 				right_status = TRUE;
 180:motor_control.h **** 				channelA = 15000;
 181:motor_control.h **** 				channelB -= 30;
 182:motor_control.h **** 			}
 183:motor_control.h **** 			break;
 184:motor_control.h **** 
 185:motor_control.h **** 		case LEFT:
 186:motor_control.h **** 			//LEFT_MODE();
 187:motor_control.h **** 			if(channelA < MIN_PWM_SPEED){
 188:motor_control.h **** 				left_status = TRUE;
 189:motor_control.h **** 				right_status = FALSE;
 190:motor_control.h **** 				channelA -= 30;
 191:motor_control.h **** 				channelB = MAX_PWM_SPEED / 2;
 192:motor_control.h **** 			}
 193:motor_control.h **** 			break;
 194:motor_control.h **** 	}
 195:motor_control.h **** 
 196:motor_control.h **** 	pwm(CH_A, channelA, MAX_PWM_SPEED);
 197:motor_control.h **** 	pwm(CH_B, channelB, MAX_PWM_SPEED);
 198:motor_control.h **** 	*/
 199:motor_control.h **** }...
 1129               		.loc 7 199 0
 1130 0480 CF91      		pop r28
 1131               	.LVL64:
 1132 0482 0895      		ret
 1133               	.LVL65:
 1134               	.L60:
 1135               	.LBB116:
  50:motor_control.h **** 	uint8_t ir_val = IR_ARR_VAL;
 1136               		.loc 7 50 0
 1137 0484 82E0      		ldi r24,lo8(2)
 1138 0486 00C0      		rjmp .L44
 1139               	.LVL66:
 1140               	.L61:
 1141               	.LBE116:
 1142               	.LBB117:
 1143 0488 84E0      		ldi r24,lo8(4)
 1144               	.LVL67:
 1145 048a 00C0      		rjmp .L45
 1146               	.LVL68:
 1147               	.L62:
 1148               	.LBE117:
 1149               	.LBB118:
 1150 048c 88E0      		ldi r24,lo8(8)
 1151               	.LVL69:
 1152 048e 00C0      		rjmp .L46
 1153               	.LVL70:
 1154               	.L63:
 1155               	.LBE118:
 1156               	.LBB119:
 1157 0490 80E1      		ldi r24,lo8(16)
 1158               	.LVL71:
 1159 0492 00C0      		rjmp .L47
 1160               	.LVL72:
 1161               	.L64:
 1162               	.LBE119:
 1163               	.LBB120:
 1164 0494 80E2      		ldi r24,lo8(32)
 1165               	.LVL73:
 1166 0496 00C0      		rjmp .L48
 1167               	.LVL74:
 1168               	.L65:
 1169               	.LBE120:
 1170               	.LBB121:
 1171 0498 80E4      		ldi r24,lo8(64)
 1172               	.LVL75:
 1173 049a 00C0      		rjmp .L49
 1174               	.LVL76:
 1175               	.L66:
 1176               	.LBE121:
 1177               	.LBB122:
 1178 049c 80E8      		ldi r24,lo8(-128)
 1179               	.LVL77:
 1180 049e 00C0      		rjmp .L50
 1181               	.LVL78:
 1182               	.L53:
 1183               	.LBE122:
  81:motor_control.h **** 		}else if(error < -1000 && count2 <= 5){
 1184               		.loc 7 81 0
 1185 04a0 8831      		cpi r24,24
 1186 04a2 9C4F      		sbci r25,-4
 1187 04a4 04F0      		brlt .+2
 1188 04a6 00C0      		rjmp .L54
  81:motor_control.h **** 		}else if(error < -1000 && count2 <= 5){
 1189               		.loc 7 81 0 is_stmt 0 discriminator 1
 1190 04a8 8091 0000 		lds r24,count2
 1191               	.LVL79:
 1192 04ac 8630      		cpi r24,lo8(6)
 1193 04ae 00F0      		brlo .+2
 1194 04b0 00C0      		rjmp .L54
  82:motor_control.h **** 			REVERSE_MODE();
 1195               		.loc 7 82 0 is_stmt 1
 1196 04b2 88B1      		in r24,0x8
 1197 04b4 8A60      		ori r24,lo8(10)
 1198 04b6 88B9      		out 0x8,r24
 1199 04b8 88B1      		in r24,0x8
 1200 04ba 8A7F      		andi r24,lo8(-6)
 1201 04bc 88B9      		out 0x8,r24
 1202               	.LVL80:
 1203               	.LBB123:
 1204               	.LBB124:
  20:pwm.h         **** 	ICR1 = period;
 1205               		.loc 2 20 0
 1206 04be 80ED      		ldi r24,lo8(-48)
 1207 04c0 97E0      		ldi r25,lo8(7)
 1208 04c2 9093 8700 		sts 134+1,r25
 1209 04c6 8093 8600 		sts 134,r24
  21:pwm.h         **** 	(channel == CH_B) ? (OCR1B = onTime) : (OCR1A = onTime);
 1210               		.loc 2 21 0
 1211 04ca 3093 8900 		sts 136+1,r19
 1212 04ce 2093 8800 		sts 136,r18
 1213               	.LVL81:
 1214               	.LBE124:
 1215               	.LBE123:
 1216               	.LBB125:
 1217               	.LBB126:
  20:pwm.h         **** 	ICR1 = period;
 1218               		.loc 2 20 0
 1219 04d2 9093 8700 		sts 134+1,r25
 1220 04d6 8093 8600 		sts 134,r24
  21:pwm.h         **** 	(channel == CH_B) ? (OCR1B = onTime) : (OCR1A = onTime);
 1221               		.loc 2 21 0
 1222 04da 3093 8B00 		sts 138+1,r19
 1223 04de 2093 8A00 		sts 138,r18
 1224               	.LVL82:
 1225               	.LBE126:
 1226               	.LBE125:
 1227               	.LBB127:
 1228               	.LBB128:
 187:/usr/avr/include/util/delay.h **** 
 1229               		.loc 6 187 0
 1230 04e2 5FEF      		ldi r21,lo8(3199999)
 1231 04e4 63ED      		ldi r22,hi8(3199999)
 1232 04e6 70E3      		ldi r23,hlo8(3199999)
 1233 04e8 5150      	1:	subi r21,1
 1234 04ea 6040      		sbci r22,0
 1235 04ec 7040      		sbci r23,0
 1236 04ee 01F4      		brne 1b
 1237 04f0 00C0      		rjmp .
 1238 04f2 0000      		nop
 1239               	.LVL83:
 1240               	.LBE128:
 1241               	.LBE127:
  86:motor_control.h **** 			FORWARD_MODE();
 1242               		.loc 7 86 0
 1243 04f4 48B1      		in r20,0x8
 1244 04f6 4560      		ori r20,lo8(5)
 1245 04f8 48B9      		out 0x8,r20
 1246 04fa 48B1      		in r20,0x8
 1247 04fc 457F      		andi r20,lo8(-11)
 1248 04fe 48B9      		out 0x8,r20
 1249               	.LVL84:
 1250               	.LBB129:
 1251               	.LBB130:
  20:pwm.h         **** 	ICR1 = period;
 1252               		.loc 2 20 0
 1253 0500 9093 8700 		sts 134+1,r25
 1254 0504 8093 8600 		sts 134,r24
  21:pwm.h         **** 	(channel == CH_B) ? (OCR1B = onTime) : (OCR1A = onTime);
 1255               		.loc 2 21 0
 1256 0508 3093 8900 		sts 136+1,r19
 1257 050c 2093 8800 		sts 136,r18
 1258               	.LVL85:
 1259               	.LBE130:
 1260               	.LBE129:
 1261               	.LBB131:
 1262               	.LBB132:
  20:pwm.h         **** 	ICR1 = period;
 1263               		.loc 2 20 0
 1264 0510 9093 8700 		sts 134+1,r25
 1265 0514 8093 8600 		sts 134,r24
  21:pwm.h         **** 	(channel == CH_B) ? (OCR1B = onTime) : (OCR1A = onTime);
 1266               		.loc 2 21 0
 1267 0518 8AE8      		ldi r24,lo8(-118)
 1268 051a 92E0      		ldi r25,lo8(2)
 1269 051c 9093 8B00 		sts 138+1,r25
 1270 0520 8093 8A00 		sts 138,r24
 1271               	.LVL86:
 1272               	.LBE132:
 1273               	.LBE131:
 1274               	.LBB133:
 1275               	.LBB115:
 187:/usr/avr/include/util/delay.h **** 
 1276               		.loc 6 187 0
 1277 0524 8FEF      		ldi r24,lo8(319999)
 1278 0526 91EE      		ldi r25,hi8(319999)
 1279 0528 24E0      		ldi r18,hlo8(319999)
 1280 052a 8150      	1:	subi r24,1
 1281 052c 9040      		sbci r25,0
 1282 052e 2040      		sbci r18,0
 1283 0530 01F4      		brne 1b
 1284 0532 00C0      		rjmp .L67
 1285               	.LVL87:
 1286               	.L54:
 1287               	.LBE115:
 1288               	.LBE133:
 1289               	.LBB134:
 1290               	.LBB135:
  20:pwm.h         **** 	ICR1 = period;
 1291               		.loc 2 20 0
 1292 0534 80ED      		ldi r24,lo8(-48)
 1293 0536 97E0      		ldi r25,lo8(7)
 1294 0538 9093 8700 		sts 134+1,r25
 1295 053c 8093 8600 		sts 134,r24
  21:pwm.h         **** 	(channel == CH_B) ? (OCR1B = onTime) : (OCR1A = onTime);
 1296               		.loc 2 21 0
 1297 0540 1092 8900 		sts 136+1,__zero_reg__
 1298 0544 1092 8800 		sts 136,__zero_reg__
 1299               	.LVL88:
 1300               	.LBE135:
 1301               	.LBE134:
 1302               	.LBB136:
 1303               	.LBB137:
  20:pwm.h         **** 	ICR1 = period;
 1304               		.loc 2 20 0
 1305 0548 9093 8700 		sts 134+1,r25
 1306 054c 8093 8600 		sts 134,r24
  21:pwm.h         **** 	(channel == CH_B) ? (OCR1B = onTime) : (OCR1A = onTime);
 1307               		.loc 2 21 0
 1308 0550 1092 8B00 		sts 138+1,__zero_reg__
 1309 0554 1092 8A00 		sts 138,__zero_reg__
 1310 0558 00C0      		rjmp .L43
 1311               	.LVL89:
 1312               	.L52:
 1313               	.LBE137:
 1314               	.LBE136:
  99:motor_control.h **** 	if(right_motor_pwm > RIGHT_MAX)
 1315               		.loc 7 99 0
 1316 055a 8091 0000 		lds r24,right_motor_pwm
 1317 055e 9091 0000 		lds r25,right_motor_pwm+1
 1318               	.LVL90:
 1319 0562 8D3D      		cpi r24,-35
 1320 0564 9540      		sbci r25,5
 1321 0566 04F0      		brlt .L56
 100:motor_control.h **** 		right_motor_pwm = RIGHT_MAX;
 1322               		.loc 7 100 0
 1323 0568 8CED      		ldi r24,lo8(-36)
 1324 056a 95E0      		ldi r25,lo8(5)
 1325 056c 9093 0000 		sts right_motor_pwm+1,r25
 1326 0570 8093 0000 		sts right_motor_pwm,r24
 1327               	.L56:
 102:motor_control.h **** 	if(left_motor_pwm > LEFT_MAX)
 1328               		.loc 7 102 0
 1329 0574 8091 0000 		lds r24,left_motor_pwm
 1330 0578 9091 0000 		lds r25,left_motor_pwm+1
 1331 057c 8D3D      		cpi r24,-35
 1332 057e 9540      		sbci r25,5
 1333 0580 04F0      		brlt .L57
 103:motor_control.h **** 		left_motor_pwm = LEFT_MAX;
 1334               		.loc 7 103 0
 1335 0582 8CED      		ldi r24,lo8(-36)
 1336 0584 95E0      		ldi r25,lo8(5)
 1337 0586 9093 0000 		sts left_motor_pwm+1,r25
 1338 058a 8093 0000 		sts left_motor_pwm,r24
 1339               	.L57:
 105:motor_control.h **** 	if(right_motor_pwm < 0)
 1340               		.loc 7 105 0
 1341 058e 8091 0000 		lds r24,right_motor_pwm
 1342 0592 9091 0000 		lds r25,right_motor_pwm+1
 1343 0596 97FF      		sbrs r25,7
 1344 0598 00C0      		rjmp .L58
 106:motor_control.h **** 		right_motor_pwm = 0;
 1345               		.loc 7 106 0
 1346 059a 1092 0000 		sts right_motor_pwm+1,__zero_reg__
 1347 059e 1092 0000 		sts right_motor_pwm,__zero_reg__
 1348               	.L58:
 108:motor_control.h **** 	if(left_motor_pwm < 0)
 1349               		.loc 7 108 0
 1350 05a2 8091 0000 		lds r24,left_motor_pwm
 1351 05a6 9091 0000 		lds r25,left_motor_pwm+1
 1352 05aa 97FF      		sbrs r25,7
 1353 05ac 00C0      		rjmp .L59
 109:motor_control.h **** 		left_motor_pwm = 0;
 1354               		.loc 7 109 0
 1355 05ae 1092 0000 		sts left_motor_pwm+1,__zero_reg__
 1356 05b2 1092 0000 		sts left_motor_pwm,__zero_reg__
 1357               	.L59:
 111:motor_control.h **** 	count2 = 0;
 1358               		.loc 7 111 0
 1359 05b6 1092 0000 		sts count2,__zero_reg__
 113:motor_control.h **** 	pwm(CH_A, right_motor_pwm, MAX_SPEED);
 1360               		.loc 7 113 0
 1361 05ba 2091 0000 		lds r18,right_motor_pwm
 1362 05be 3091 0000 		lds r19,right_motor_pwm+1
 1363               	.LVL91:
 1364               	.LBB138:
 1365               	.LBB139:
  20:pwm.h         **** 	ICR1 = period;
 1366               		.loc 2 20 0
 1367 05c2 80ED      		ldi r24,lo8(-48)
 1368 05c4 97E0      		ldi r25,lo8(7)
 1369 05c6 9093 8700 		sts 134+1,r25
 1370 05ca 8093 8600 		sts 134,r24
  21:pwm.h         **** 	(channel == CH_B) ? (OCR1B = onTime) : (OCR1A = onTime);
 1371               		.loc 2 21 0
 1372 05ce 3093 8900 		sts 136+1,r19
 1373 05d2 2093 8800 		sts 136,r18
 1374               	.LVL92:
 1375               	.LBE139:
 1376               	.LBE138:
 114:motor_control.h **** 	pwm(CH_B, left_motor_pwm, MAX_SPEED);
 1377               		.loc 7 114 0
 1378 05d6 2091 0000 		lds r18,left_motor_pwm
 1379 05da 3091 0000 		lds r19,left_motor_pwm+1
 1380               	.LVL93:
 1381               	.LBB140:
 1382               	.LBB141:
  20:pwm.h         **** 	ICR1 = period;
 1383               		.loc 2 20 0
 1384 05de 9093 8700 		sts 134+1,r25
 1385 05e2 8093 8600 		sts 134,r24
  21:pwm.h         **** 	(channel == CH_B) ? (OCR1B = onTime) : (OCR1A = onTime);
 1386               		.loc 2 21 0
 1387 05e6 3093 8B00 		sts 138+1,r19
 1388 05ea 2093 8A00 		sts 138,r18
 1389 05ee 00C0      		rjmp .L43
 1390               	.LBE141:
 1391               	.LBE140:
 1392               		.cfi_endproc
 1393               	.LFE22:
 1395               		.section	.text.startup,"ax",@progbits
 1396               	.global	main
 1398               	main:
 1399               	.LFB23:
 1400               		.file 8 "main.c"
   1:main.c        **** #define F_CPU 16000000UL
   2:main.c        **** 
   3:main.c        **** //Comment the MCU which you're not using.
   4:main.c        **** #define ATMEGA_328P
   5:main.c        **** //#define ATMEGA_32A
   6:main.c        **** 
   7:main.c        **** #include <avr/io.h>
   8:main.c        **** #include <util/delay.h>
   9:main.c        **** 
  10:main.c        **** #include "color_sensor.h"
  11:main.c        **** #include "motor_control.h"
  12:main.c        **** 
  13:main.c        **** int main(void){
 1401               		.loc 8 13 0
 1402               		.cfi_startproc
 1403               	/* prologue: function */
 1404               	/* frame size = 0 */
 1405               	/* stack size = 0 */
 1406               	.L__stack_usage = 0
  14:main.c        **** 
  15:main.c        **** 	setupPWM();
 1407               		.loc 8 15 0
 1408 0000 0E94 0000 		call setupPWM
 1409               	.LVL94:
  16:main.c        **** 	setupMotor();
 1410               		.loc 8 16 0
 1411 0004 0E94 0000 		call setupMotor
 1412               	.LVL95:
  17:main.c        **** 	initIR();
 1413               		.loc 8 17 0
 1414 0008 0E94 0000 		call initIR
 1415               	.LVL96:
  18:main.c        **** 	init_SRF05();
 1416               		.loc 8 18 0
 1417 000c 0E94 0000 		call init_SRF05
 1418               	.LVL97:
  19:main.c        **** 	SRF05_Start();
 1419               		.loc 8 19 0
 1420 0010 0E94 0000 		call SRF05_Start
 1421               	.LVL98:
  20:main.c        **** 	init_ADC();
 1422               		.loc 8 20 0
 1423 0014 0E94 0000 		call init_ADC
 1424               	.LVL99:
 1425               	.L69:
  21:main.c        **** 
  22:main.c        **** 	while(1){
  23:main.c        **** 		controlMotor();
 1426               		.loc 8 23 0 discriminator 1
 1427 0018 0E94 0000 		call controlMotor
 1428               	.LVL100:
 1429 001c 00C0      		rjmp .L69
 1430               		.cfi_endproc
 1431               	.LFE23:
 1433               	.global	previous_error
 1434               		.section .bss
 1437               	previous_error:
 1438 0000 0000      		.zero	2
 1439               	.global	left_motor_pwm
 1442               	left_motor_pwm:
 1443 0002 0000      		.zero	2
 1444               	.global	right_motor_pwm
 1447               	right_motor_pwm:
 1448 0004 0000      		.zero	2
 1449               	.global	PID
 1452               	PID:
 1453 0006 0000      		.zero	2
 1454               	.global	D
 1457               	D:
 1458 0008 0000      		.zero	2
 1459               	.global	I
 1462               	I:
 1463 000a 0000      		.zero	2
 1464               	.global	P
 1467               	P:
 1468 000c 0000      		.zero	2
 1469               	.global	count2
 1472               	count2:
 1473 000e 00        		.zero	1
 1474               	.global	count
 1477               	count:
 1478 000f 0000 0000 		.zero	4
 1479               	.global	interrupt
 1482               	interrupt:
 1483 0013 00        		.zero	1
 1484               	.global	mseconds
 1487               	mseconds:
 1488 0014 0000      		.zero	2
 1489               		.comm	distance,2,1
 1490               	.global	width
 1493               	width:
 1494 0016 00        		.zero	1
 1495               		.text
 1496               	.Letext0:
 1497               		.file 9 "/usr/avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/cc7HUQhY.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc7HUQhY.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc7HUQhY.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc7HUQhY.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc7HUQhY.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc7HUQhY.s:12     .text:0000000000000000 init_ADC
     /tmp/cc7HUQhY.s:45     .text:000000000000001c read_ADC
     /tmp/cc7HUQhY.s:74     .text:0000000000000036 setupPWM
     /tmp/cc7HUQhY.s:101    .text:000000000000004a pwm
     /tmp/cc7HUQhY.s:132    .text:000000000000006a initUSART
     /tmp/cc7HUQhY.s:164    .text:0000000000000086 getCh
     /tmp/cc7HUQhY.s:187    .text:0000000000000094 putCh
     /tmp/cc7HUQhY.s:211    .text:00000000000000a2 initIR
     /tmp/cc7HUQhY.s:235    .text:00000000000000b2 getPosition
     /tmp/cc7HUQhY.s:445    .text:000000000000018c getError
     /tmp/cc7HUQhY.s:470    .text:000000000000019e lineSize
     /tmp/cc7HUQhY.s:528    .text:00000000000001b2 init_SRF05
     /tmp/cc7HUQhY.s:564    .text:00000000000001ce SRF05_Start
     /tmp/cc7HUQhY.s:1487   .bss:0000000000000014 mseconds
     /tmp/cc7HUQhY.s:609    .text:00000000000001ec __vector_1
     /tmp/cc7HUQhY.s:1482   .bss:0000000000000013 interrupt
                            *COM*:0000000000000002 distance
     /tmp/cc7HUQhY.s:735    .text:0000000000000272 __vector_14
     /tmp/cc7HUQhY.s:782    .text:00000000000002a0 setupMotor
     /tmp/cc7HUQhY.s:829    .text:00000000000002c6 controlMotor
     /tmp/cc7HUQhY.s:1477   .bss:000000000000000f count
     /tmp/cc7HUQhY.s:1467   .bss:000000000000000c P
     /tmp/cc7HUQhY.s:1462   .bss:000000000000000a I
     /tmp/cc7HUQhY.s:1437   .bss:0000000000000000 previous_error
     /tmp/cc7HUQhY.s:1457   .bss:0000000000000008 D
     /tmp/cc7HUQhY.s:1452   .bss:0000000000000006 PID
     /tmp/cc7HUQhY.s:1447   .bss:0000000000000004 right_motor_pwm
     /tmp/cc7HUQhY.s:1442   .bss:0000000000000002 left_motor_pwm
     /tmp/cc7HUQhY.s:1472   .bss:000000000000000e count2
     /tmp/cc7HUQhY.s:1398   .text.startup:0000000000000000 main
     /tmp/cc7HUQhY.s:1493   .bss:0000000000000016 width

UNDEFINED SYMBOLS
__udivmodhi4
__do_clear_bss
